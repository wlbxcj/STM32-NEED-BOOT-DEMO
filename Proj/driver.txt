; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\driver.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\driver.d --cpu=Cortex-M3 --apcs=interwork -I..\Source\App -I..\Source\BSP -I..\Source\CMSIS -I..\Source\FWlib\inc -I..\Proj -I..\Source\Starup -I..\Source\uCOS_Ports -I..\Source\uCOS_Source -I..\Source\USER -I..\Source\FWlib -I..\Source\Driver -I"D:\Program Files\Keil\ARM\RV31\Inc" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\driver.crf ..\Source\Driver\driver.c]
                          THUMB

                          AREA ||i.CmdResp1Error||, CODE, READONLY, ALIGN=2

                  CmdResp1Error PROC
;;;2287     */
;;;2288   static SD_Error CmdResp1Error(uint8_t cmd)
000000  b570              PUSH     {r4-r6,lr}
;;;2289   {
;;;2290     SD_Error errorstatus = SD_OK;
;;;2291     uint32_t status;
;;;2292     uint32_t response_r1;
;;;2293   
;;;2294     status = SDIO->STA;
000002  4937              LDR      r1,|L1.224|
000004  4605              MOV      r5,r0                 ;2289
000006  242a              MOVS     r4,#0x2a              ;2290
                  |L1.8|
;;;2295   
;;;2296     while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)))
;;;2297     {
;;;2298       status = SDIO->STA;
000008  6b48              LDR      r0,[r1,#0x34]
00000a  f0100f45          TST      r0,#0x45              ;2296
00000e  d0fb              BEQ      |L1.8|
;;;2299     }
;;;2300     /*命令响应超时*/
;;;2301     if (status & SDIO_FLAG_CTIMEOUT)
000010  0741              LSLS     r1,r0,#29
000012  d502              BPL      |L1.26|
;;;2302     {
;;;2303       errorstatus = SD_CMD_RSP_TIMEOUT;
000014  2403              MOVS     r4,#3
;;;2304       SDIO_ClearFlag(SDIO_FLAG_CTIMEOUT);
000016  2004              MOVS     r0,#4
;;;2305       return(errorstatus);
000018  e003              B        |L1.34|
                  |L1.26|
;;;2306     }
;;;2307     /*已收到命令响R1，但校验失败*/
;;;2308     else if (status & SDIO_FLAG_CCRCFAIL)
00001a  07c0              LSLS     r0,r0,#31
00001c  d004              BEQ      |L1.40|
;;;2309     {
;;;2310       errorstatus = SD_CMD_CRC_FAIL;
00001e  2401              MOVS     r4,#1
;;;2311       SDIO_ClearFlag(SDIO_FLAG_CCRCFAIL);
000020  4620              MOV      r0,r4
                  |L1.34|
000022  f7fffffe          BL       SDIO_ClearFlag
000026  e059              B        |L1.220|
                  |L1.40|
;;;2312       return(errorstatus);
;;;2313     }
;;;2314     /*已收到的命令响应R1，并且校验成功*/
;;;2315     /* 检查收到的响应是不是该命令的，如果不是，返回非法命令错误 */
;;;2316     if (SDIO_GetCommandResponse() != cmd)
000028  f7fffffe          BL       SDIO_GetCommandResponse
00002c  42a8              CMP      r0,r5
00002e  d12b              BNE      |L1.136|
;;;2317     {
;;;2318       errorstatus = SD_ILLEGAL_CMD;
;;;2319       return(errorstatus);
;;;2320     }
;;;2321   
;;;2322     /*清除所有的静态标志 */
;;;2323     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
000030  f24050ff          MOV      r0,#0x5ff
000034  f7fffffe          BL       SDIO_ClearFlag
;;;2324   
;;;2325     /*从SDIO_RESP1寄存器中读取响应R1，并解析 */
;;;2326     response_r1 = SDIO_GetResponse(SDIO_RESP1);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       SDIO_GetResponse
;;;2327     /*如果卡状态寄存器的各位（不考虑CARD_IS_LOCDED,CURRENT_STATE,APP_CMD
;;;2328     以及保留位）都为等于1，则返回SD_OK*/
;;;2329     if ((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
00003e  4929              LDR      r1,|L1.228|
000040  4208              TST      r0,r1
000042  d04b              BEQ      |L1.220|
;;;2330     {
;;;2331       return(errorstatus);
;;;2332     }
;;;2333   
;;;2334     if (response_r1 & SD_OCR_ADDR_OUT_OF_RANGE)
000044  2800              CMP      r0,#0
000046  da01              BGE      |L1.76|
;;;2335     {
;;;2336       return(SD_ADDR_OUT_OF_RANGE);
000048  201c              MOVS     r0,#0x1c
;;;2337     }
;;;2338   
;;;2339     if (response_r1 & SD_OCR_ADDR_MISALIGNED)
;;;2340     {
;;;2341       return(SD_ADDR_MISALIGNED);
;;;2342     }
;;;2343   
;;;2344     if (response_r1 & SD_OCR_BLOCK_LEN_ERR)
;;;2345     {
;;;2346       return(SD_BLOCK_LEN_ERR);
;;;2347     }
;;;2348   
;;;2349     if (response_r1 & SD_OCR_ERASE_SEQ_ERR)
;;;2350     {
;;;2351       return(SD_ERASE_SEQ_ERR);
;;;2352     }
;;;2353   
;;;2354     if (response_r1 & SD_OCR_BAD_ERASE_PARAM)
;;;2355     {
;;;2356       return(SD_BAD_ERASE_PARAM);
;;;2357     }
;;;2358   
;;;2359     if (response_r1 & SD_OCR_WRITE_PROT_VIOLATION)
;;;2360     {
;;;2361       return(SD_WRITE_PROT_VIOLATION);
;;;2362     }
;;;2363   
;;;2364     if (response_r1 & SD_OCR_LOCK_UNLOCK_FAILED)
;;;2365     {
;;;2366       return(SD_LOCK_UNLOCK_FAILED);
;;;2367     }
;;;2368   
;;;2369     if (response_r1 & SD_OCR_COM_CRC_FAILED)
;;;2370     {
;;;2371       return(SD_COM_CRC_FAILED);
;;;2372     }
;;;2373   
;;;2374     if (response_r1 & SD_OCR_ILLEGAL_CMD)
;;;2375     {
;;;2376       return(SD_ILLEGAL_CMD);
;;;2377     }
;;;2378   
;;;2379     if (response_r1 & SD_OCR_CARD_ECC_FAILED)
;;;2380     {
;;;2381       return(SD_CARD_ECC_FAILED);
;;;2382     }
;;;2383   
;;;2384     if (response_r1 & SD_OCR_CC_ERROR)
;;;2385     {
;;;2386       return(SD_CC_ERROR);
;;;2387     }
;;;2388   
;;;2389     if (response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR)
;;;2390     {
;;;2391       return(SD_GENERAL_UNKNOWN_ERROR);
;;;2392     }
;;;2393   
;;;2394     if (response_r1 & SD_OCR_STREAM_READ_UNDERRUN)
;;;2395     {
;;;2396       return(SD_STREAM_READ_UNDERRUN);
;;;2397     }
;;;2398   
;;;2399     if (response_r1 & SD_OCR_STREAM_WRITE_OVERRUN)
;;;2400     {
;;;2401       return(SD_STREAM_WRITE_OVERRUN);
;;;2402     }
;;;2403   
;;;2404     if (response_r1 & SD_OCR_CID_CSD_OVERWRIETE)
;;;2405     {
;;;2406       return(SD_CID_CSD_OVERWRITE);
;;;2407     }
;;;2408   
;;;2409     if (response_r1 & SD_OCR_WP_ERASE_SKIP)
;;;2410     {
;;;2411       return(SD_WP_ERASE_SKIP);
;;;2412     }
;;;2413   
;;;2414     if (response_r1 & SD_OCR_CARD_ECC_DISABLED)
;;;2415     {
;;;2416       return(SD_CARD_ECC_DISABLED);
;;;2417     }
;;;2418   
;;;2419     if (response_r1 & SD_OCR_ERASE_RESET)
;;;2420     {
;;;2421       return(SD_ERASE_RESET);
;;;2422     }
;;;2423   
;;;2424     if (response_r1 & SD_OCR_AKE_SEQ_ERROR)
;;;2425     {
;;;2426       return(SD_AKE_SEQ_ERROR);
;;;2427     }
;;;2428     /*返回SD_OK*/
;;;2429     return(errorstatus);
;;;2430   }
00004a  bd70              POP      {r4-r6,pc}
                  |L1.76|
00004c  0041              LSLS     r1,r0,#1              ;2339
00004e  d501              BPL      |L1.84|
000050  2009              MOVS     r0,#9                 ;2341
000052  bd70              POP      {r4-r6,pc}
                  |L1.84|
000054  0081              LSLS     r1,r0,#2              ;2344
000056  d501              BPL      |L1.92|
000058  200a              MOVS     r0,#0xa               ;2346
00005a  bd70              POP      {r4-r6,pc}
                  |L1.92|
00005c  00c1              LSLS     r1,r0,#3              ;2349
00005e  d501              BPL      |L1.100|
000060  200b              MOVS     r0,#0xb               ;2351
000062  bd70              POP      {r4-r6,pc}
                  |L1.100|
000064  0101              LSLS     r1,r0,#4              ;2354
000066  d501              BPL      |L1.108|
000068  200c              MOVS     r0,#0xc               ;2356
00006a  bd70              POP      {r4-r6,pc}
                  |L1.108|
00006c  0141              LSLS     r1,r0,#5              ;2359
00006e  d501              BPL      |L1.116|
000070  200d              MOVS     r0,#0xd               ;2361
000072  bd70              POP      {r4-r6,pc}
                  |L1.116|
000074  01c1              LSLS     r1,r0,#7              ;2364
000076  d501              BPL      |L1.124|
000078  200e              MOVS     r0,#0xe               ;2366
00007a  bd70              POP      {r4-r6,pc}
                  |L1.124|
00007c  0201              LSLS     r1,r0,#8              ;2369
00007e  d501              BPL      |L1.132|
000080  200f              MOVS     r0,#0xf               ;2371
000082  bd70              POP      {r4-r6,pc}
                  |L1.132|
000084  0241              LSLS     r1,r0,#9              ;2374
000086  d501              BPL      |L1.140|
                  |L1.136|
000088  2010              MOVS     r0,#0x10              ;2376
00008a  bd70              POP      {r4-r6,pc}
                  |L1.140|
00008c  0281              LSLS     r1,r0,#10             ;2379
00008e  d501              BPL      |L1.148|
000090  2011              MOVS     r0,#0x11              ;2381
000092  bd70              POP      {r4-r6,pc}
                  |L1.148|
000094  02c1              LSLS     r1,r0,#11             ;2384
000096  d501              BPL      |L1.156|
000098  2012              MOVS     r0,#0x12              ;2386
00009a  bd70              POP      {r4-r6,pc}
                  |L1.156|
00009c  0301              LSLS     r1,r0,#12             ;2389
00009e  d501              BPL      |L1.164|
0000a0  2013              MOVS     r0,#0x13              ;2391
0000a2  bd70              POP      {r4-r6,pc}
                  |L1.164|
0000a4  0341              LSLS     r1,r0,#13             ;2394
0000a6  d501              BPL      |L1.172|
0000a8  2014              MOVS     r0,#0x14              ;2396
0000aa  bd70              POP      {r4-r6,pc}
                  |L1.172|
0000ac  0381              LSLS     r1,r0,#14             ;2399
0000ae  d501              BPL      |L1.180|
0000b0  2015              MOVS     r0,#0x15              ;2401
0000b2  bd70              POP      {r4-r6,pc}
                  |L1.180|
0000b4  03c1              LSLS     r1,r0,#15             ;2404
0000b6  d501              BPL      |L1.188|
0000b8  2016              MOVS     r0,#0x16              ;2406
0000ba  bd70              POP      {r4-r6,pc}
                  |L1.188|
0000bc  0401              LSLS     r1,r0,#16             ;2409
0000be  d501              BPL      |L1.196|
0000c0  2017              MOVS     r0,#0x17              ;2411
0000c2  bd70              POP      {r4-r6,pc}
                  |L1.196|
0000c4  0441              LSLS     r1,r0,#17             ;2414
0000c6  d501              BPL      |L1.204|
0000c8  2018              MOVS     r0,#0x18              ;2416
0000ca  bd70              POP      {r4-r6,pc}
                  |L1.204|
0000cc  0481              LSLS     r1,r0,#18             ;2419
0000ce  d501              BPL      |L1.212|
0000d0  2019              MOVS     r0,#0x19              ;2421
0000d2  bd70              POP      {r4-r6,pc}
                  |L1.212|
0000d4  0700              LSLS     r0,r0,#28             ;2424
0000d6  d501              BPL      |L1.220|
0000d8  201a              MOVS     r0,#0x1a              ;2426
0000da  bd70              POP      {r4-r6,pc}
                  |L1.220|
0000dc  4620              MOV      r0,r4                 ;2429
0000de  bd70              POP      {r4-r6,pc}
;;;2431   
                          ENDP

                  |L1.224|
                          DCD      0x40018000
                  |L1.228|
                          DCD      0xfdffe008

                          AREA ||i.CmdResp2Error||, CODE, READONLY, ALIGN=2

                  CmdResp2Error PROC
;;;2465     */
;;;2466   static SD_Error CmdResp2Error(void)
000000  b510              PUSH     {r4,lr}
;;;2467   {
;;;2468     SD_Error errorstatus = SD_OK;
;;;2469     uint32_t status;
;;;2470   
;;;2471     status = SDIO->STA;
000002  4a0b              LDR      r2,|L2.48|
000004  242a              MOVS     r4,#0x2a              ;2468
                  |L2.6|
;;;2472   
;;;2473     while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CTIMEOUT | SDIO_FLAG_CMDREND)))
;;;2474     {
;;;2475       status = SDIO->STA;
000006  6b51              LDR      r1,[r2,#0x34]
000008  f0110f45          TST      r1,#0x45              ;2473
00000c  d0fb              BEQ      |L2.6|
;;;2476     }
;;;2477     /*命令响应超时*/
;;;2478     if (status & SDIO_FLAG_CTIMEOUT)
00000e  0748              LSLS     r0,r1,#29
000010  d502              BPL      |L2.24|
;;;2479     {
;;;2480       errorstatus = SD_CMD_RSP_TIMEOUT;
000012  2403              MOVS     r4,#3
;;;2481       SDIO_ClearFlag(SDIO_FLAG_CTIMEOUT);
000014  2004              MOVS     r0,#4
;;;2482       return(errorstatus);
000016  e003              B        |L2.32|
                  |L2.24|
;;;2483     }
;;;2484     /*已收到命令响应R2，但是CRC校验失败*/
;;;2485     else if (status & SDIO_FLAG_CCRCFAIL)
000018  07c8              LSLS     r0,r1,#31
00001a  d005              BEQ      |L2.40|
;;;2486     {
;;;2487       errorstatus = SD_CMD_CRC_FAIL;
00001c  2401              MOVS     r4,#1
;;;2488       SDIO_ClearFlag(SDIO_FLAG_CCRCFAIL);
00001e  4620              MOV      r0,r4
                  |L2.32|
;;;2489       return(errorstatus);
;;;2490     }
;;;2491   
;;;2492     /* Clear all the static flags */
;;;2493     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
000020  f7fffffe          BL       SDIO_ClearFlag
;;;2494   
;;;2495     return(errorstatus);
000024  4620              MOV      r0,r4
;;;2496   }
000026  bd10              POP      {r4,pc}
                  |L2.40|
000028  f24050ff          MOV      r0,#0x5ff             ;2493
00002c  e7f8              B        |L2.32|
;;;2497   
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40018000

                          AREA ||i.CmdResp6Error||, CODE, READONLY, ALIGN=2

                  CmdResp6Error PROC
;;;2503     */
;;;2504   static SD_Error CmdResp6Error(uint8_t cmd, uint16_t *prca)
000000  b570              PUSH     {r4-r6,lr}
;;;2505   {
000002  460c              MOV      r4,r1
;;;2506     SD_Error errorstatus = SD_OK;
;;;2507     uint32_t status;
;;;2508     uint32_t response_r1;
;;;2509   
;;;2510     status = SDIO->STA;
000004  4919              LDR      r1,|L3.108|
000006  4606              MOV      r6,r0                 ;2505
000008  252a              MOVS     r5,#0x2a              ;2506
                  |L3.10|
;;;2511     
;;;2512     while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CTIMEOUT | SDIO_FLAG_CMDREND)))
;;;2513     {
;;;2514       status = SDIO->STA;
00000a  6b48              LDR      r0,[r1,#0x34]
00000c  f0100f45          TST      r0,#0x45              ;2512
000010  d0fb              BEQ      |L3.10|
;;;2515     }
;;;2516     /*命令响应超时*/
;;;2517     if (status & SDIO_FLAG_CTIMEOUT)
000012  0741              LSLS     r1,r0,#29
000014  d502              BPL      |L3.28|
;;;2518     {
;;;2519       errorstatus = SD_CMD_RSP_TIMEOUT;
000016  2403              MOVS     r4,#3
;;;2520       SDIO_ClearFlag(SDIO_FLAG_CTIMEOUT);
000018  2004              MOVS     r0,#4
;;;2521       return(errorstatus);
00001a  e003              B        |L3.36|
                  |L3.28|
;;;2522     }
;;;2523     /*已收到命令响应R6，但是CRC校验失败*/
;;;2524     else if (status & SDIO_FLAG_CCRCFAIL)
00001c  07c0              LSLS     r0,r0,#31
00001e  d005              BEQ      |L3.44|
;;;2525     {
;;;2526       errorstatus = SD_CMD_CRC_FAIL;
000020  2401              MOVS     r4,#1
;;;2527       SDIO_ClearFlag(SDIO_FLAG_CCRCFAIL);
000022  4620              MOV      r0,r4
                  |L3.36|
000024  f7fffffe          BL       SDIO_ClearFlag
;;;2528       return(errorstatus);
000028  4620              MOV      r0,r4
;;;2529     }
;;;2530   
;;;2531     /* Check response received is of desired command */
;;;2532     /*已收到命令响应R6，并且CRC校验成功*/
;;;2533     /*检查收到的响应是不是该命令的，如果不是，返回非法命令错误*/
;;;2534     if (SDIO_GetCommandResponse() != cmd)
;;;2535     {
;;;2536       errorstatus = SD_ILLEGAL_CMD;
;;;2537       return(errorstatus);
;;;2538     }
;;;2539   
;;;2540     /* Clear all the static flags */
;;;2541     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;2542   
;;;2543     /* We have received response, retrieve it.  */
;;;2544     response_r1 = SDIO_GetResponse(SDIO_RESP1);
;;;2545     /* 如果响应R6中没有发生普通或未知错误(卡状态位19:ERROR)、非法命令错误(卡状态位22:ILLEGAL_COMMAND)
;;;2546        以及CRC校验错误(卡状态位23:COM_CEC_ERROR)，则计算出RCA并返回SD_OK。*/
;;;2547     if (SD_ALLZERO == (response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)))
;;;2548     {	 
;;;2549     	/* 相对卡地址RCA位于RCA寄存器的高16位[31:16] */
;;;2550       *prca = (uint16_t) (response_r1 >> 16);
;;;2551       return(errorstatus);
;;;2552     }
;;;2553      /* 普通或未知错误(卡状态位19:ERROR) */
;;;2554     if (response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR)
;;;2555     {
;;;2556       return(SD_GENERAL_UNKNOWN_ERROR);
;;;2557     }
;;;2558      /* 非法命令错误(卡状态位22:ILLEGAL_COMMAND) */
;;;2559     if (response_r1 & SD_R6_ILLEGAL_CMD)
;;;2560     {
;;;2561       return(SD_ILLEGAL_CMD);
;;;2562     }
;;;2563     /* CRC校验错误(卡状态位23:COM_CEC_ERROR) */
;;;2564     if (response_r1 & SD_R6_COM_CRC_FAILED)
;;;2565     {
;;;2566       return(SD_COM_CRC_FAILED);
;;;2567     }
;;;2568     /* 返回SD_OK */
;;;2569     return(errorstatus);
;;;2570   }
00002a  bd70              POP      {r4-r6,pc}
                  |L3.44|
00002c  f7fffffe          BL       SDIO_GetCommandResponse
000030  42b0              CMP      r0,r6                 ;2534
000032  d113              BNE      |L3.92|
000034  f24050ff          MOV      r0,#0x5ff             ;2541
000038  f7fffffe          BL       SDIO_ClearFlag
00003c  2000              MOVS     r0,#0                 ;2544
00003e  f7fffffe          BL       SDIO_GetResponse
000042  f4104f60          TST      r0,#0xe000            ;2547
000046  d003              BEQ      |L3.80|
000048  0481              LSLS     r1,r0,#18             ;2554
00004a  d505              BPL      |L3.88|
00004c  2013              MOVS     r0,#0x13              ;2556
00004e  bd70              POP      {r4-r6,pc}
                  |L3.80|
000050  ea4f4010          LSR      r0,r0,#16             ;2550
000054  8020              STRH     r0,[r4,#0]            ;2550
000056  e007              B        |L3.104|
                  |L3.88|
000058  0441              LSLS     r1,r0,#17             ;2559
00005a  d501              BPL      |L3.96|
                  |L3.92|
00005c  2010              MOVS     r0,#0x10              ;2561
00005e  bd70              POP      {r4-r6,pc}
                  |L3.96|
000060  0400              LSLS     r0,r0,#16             ;2564
000062  d501              BPL      |L3.104|
000064  200f              MOVS     r0,#0xf               ;2566
000066  bd70              POP      {r4-r6,pc}
                  |L3.104|
000068  4628              MOV      r0,r5                 ;2569
00006a  bd70              POP      {r4-r6,pc}
;;;2571   
                          ENDP

                  |L3.108|
                          DCD      0x40018000

                          AREA ||i.DMA_RxConfiguration||, CODE, READONLY, ALIGN=2

                  DMA_RxConfiguration PROC
;;;3085     */
;;;3086   static void DMA_RxConfiguration(uint32_t *BufferDST, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;3087   {
000002  4604              MOV      r4,r0
000004  b08c              SUB      sp,sp,#0x30
000006  460e              MOV      r6,r1
;;;3088     DMA_InitTypeDef DMA_InitStructure;
;;;3089   
;;;3090     DMA_ClearFlag(DMA2_FLAG_TC4 | DMA2_FLAG_TE4 | DMA2_FLAG_HT4 | DMA2_FLAG_GL4);
000008  4811              LDR      r0,|L4.80|
00000a  f7fffffe          BL       DMA_ClearFlag
;;;3091   
;;;3092     /* DMA2 Channel4 disable */
;;;3093     DMA_Cmd(DMA2_Channel4, DISABLE);
00000e  4d11              LDR      r5,|L4.84|
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       DMA_Cmd
;;;3094   
;;;3095     /* DMA2 Channel4 Config */
;;;3096     DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)SDIO_FIFO_Address;
000018  480f              LDR      r0,|L4.88|
00001a  e9cd0400          STRD     r0,r4,[sp,#0]
;;;3097     DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)BufferDST;
;;;3098     DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
00001e  2000              MOVS     r0,#0
;;;3099     DMA_InitStructure.DMA_BufferSize = BufferSize / 4;
000020  08b1              LSRS     r1,r6,#2
000022  e9cd0102          STRD     r0,r1,[sp,#8]
;;;3100     DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;3101     DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000026  2180              MOVS     r1,#0x80
000028  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;3102     DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
00002c  0089              LSLS     r1,r1,#2
;;;3103     DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
00002e  9106              STR      r1,[sp,#0x18]
000030  0089              LSLS     r1,r1,#2
000032  e9cd1007          STRD     r1,r0,[sp,#0x1c]
;;;3104     DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
;;;3105     DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000036  0089              LSLS     r1,r1,#2
000038  e9cd1009          STRD     r1,r0,[sp,#0x24]
;;;3106     DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;3107     DMA_Init(DMA2_Channel4, &DMA_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       DMA_Init
;;;3108   
;;;3109     /* DMA2 Channel4 enable */
;;;3110     DMA_Cmd(DMA2_Channel4, ENABLE);
000044  2101              MOVS     r1,#1
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       DMA_Cmd
;;;3111   }
00004c  b00c              ADD      sp,sp,#0x30
00004e  bd70              POP      {r4-r6,pc}
;;;3112   
                          ENDP

                  |L4.80|
                          DCD      0x1000f000
                  |L4.84|
                          DCD      0x40020444
                  |L4.88|
                          DCD      0x40018080

                          AREA ||i.DMA_TxConfiguration||, CODE, READONLY, ALIGN=2

                  DMA_TxConfiguration PROC
;;;3052     */
;;;3053   static void DMA_TxConfiguration(uint32_t *BufferSRC, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;3054   {
000002  4604              MOV      r4,r0
000004  b08c              SUB      sp,sp,#0x30
000006  460d              MOV      r5,r1
;;;3055     DMA_InitTypeDef DMA_InitStructure;
;;;3056   
;;;3057     DMA_ClearFlag(DMA2_FLAG_TC4 | DMA2_FLAG_TE4 | DMA2_FLAG_HT4 | DMA2_FLAG_GL4);
000008  4812              LDR      r0,|L5.84|
00000a  f7fffffe          BL       DMA_ClearFlag
;;;3058   
;;;3059     /* DMA2 Channel4 disable */
;;;3060     DMA_Cmd(DMA2_Channel4, DISABLE);
00000e  4e12              LDR      r6,|L5.88|
000010  2100              MOVS     r1,#0
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       DMA_Cmd
;;;3061   
;;;3062     /* DMA2 Channel4 Config */
;;;3063     DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)SDIO_FIFO_Address;
000018  4810              LDR      r0,|L5.92|
00001a  e9cd0400          STRD     r0,r4,[sp,#0]
;;;3064     DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)BufferSRC;
;;;3065     DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
00001e  2010              MOVS     r0,#0x10
;;;3066     DMA_InitStructure.DMA_BufferSize = BufferSize / 4;
000020  9002              STR      r0,[sp,#8]
000022  08a8              LSRS     r0,r5,#2
;;;3067     DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000024  9003              STR      r0,[sp,#0xc]
000026  2000              MOVS     r0,#0
;;;3068     DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000028  2180              MOVS     r1,#0x80
00002a  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;3069     DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
00002e  0089              LSLS     r1,r1,#2
;;;3070     DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
000030  9106              STR      r1,[sp,#0x18]
000032  0089              LSLS     r1,r1,#2
000034  e9cd1007          STRD     r1,r0,[sp,#0x1c]
;;;3071     DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
;;;3072     DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000038  0089              LSLS     r1,r1,#2
00003a  e9cd1009          STRD     r1,r0,[sp,#0x24]
;;;3073     DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;3074     DMA_Init(DMA2_Channel4, &DMA_InitStructure);
00003e  4669              MOV      r1,sp
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       DMA_Init
;;;3075   
;;;3076     /* DMA2 Channel4 enable */
;;;3077     DMA_Cmd(DMA2_Channel4, ENABLE);
000046  2101              MOVS     r1,#1
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       DMA_Cmd
;;;3078   }
00004e  b00c              ADD      sp,sp,#0x30
000050  bd70              POP      {r4-r6,pc}
;;;3079   
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      0x1000f000
                  |L5.88|
                          DCD      0x40020444
                  |L5.92|
                          DCD      0x40018080

                          AREA ||i.FindSCR||, CODE, READONLY, ALIGN=2

                  FindSCR PROC
;;;2882     */
;;;2883   static SD_Error FindSCR(uint16_t rca, uint32_t *pscr)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2884   {
;;;2885     uint32_t index = 0;
000004  2400              MOVS     r4,#0
;;;2886     SD_Error errorstatus = SD_OK;
;;;2887     uint32_t tempscr[2] = {0, 0};
;;;2888   
;;;2889     /* Set Block Size To 8 Bytes */
;;;2890     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;2891     /* 由于SCR是通过数据线发送的，因此要设置卡和主机的数据块长度 */
;;;2892     /* CMD16: SET_BLOCKLEN -------------------------------------------------------*/
;;;2893     /* 发送 CMD16 设置卡的数据块长度 */
;;;2894     /* 参数: - [31:0]: 数据块长度 */
;;;2895     /* 响应类型: R1 */
;;;2896     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)8;
000006  4f49              LDR      r7,|L6.300|
000008  9400              STR      r4,[sp,#0]            ;2887
00000a  f04f0a08          MOV      r10,#8
00000e  9401              STR      r4,[sp,#4]
;;;2897     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
000010  2010              MOVS     r0,#0x10
;;;2898     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000012  f04f0840          MOV      r8,#0x40
;;;2899     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2900     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
000016  f8c7a000          STR      r10,[r7,#0]  ; SDIO_CmdInitStructure
00001a  e9c70801          STRD     r0,r8,[r7,#4]
00001e  f44f6980          MOV      r9,#0x400
;;;2901     SDIO_SendCommand(&SDIO_CmdInitStructure);
000022  e9c74903          STRD     r4,r9,[r7,#0xc]
000026  460e              MOV      r6,r1                 ;2884
000028  4625              MOV      r5,r4                 ;2887
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       SDIO_SendCommand
;;;2902   
;;;2903     errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       CmdResp1Error
;;;2904   
;;;2905     if (errorstatus != SD_OK)
000036  282a              CMP      r0,#0x2a
000038  d142              BNE      |L6.192|
;;;2906     {
;;;2907       return(errorstatus);
;;;2908     }
;;;2909   
;;;2910     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;2911     /* CMD55: APP_CMD ------------------------------------------------------------*/
;;;2912     /* 必须在发送 ACMD51 之前发送 CMD55 通知卡，下面一条命令是应用特定命令 */
;;;2913     /* 参数: - [31:16]: 相对卡地址RCA
;;;2914              - [15:0]: 保留('0') */
;;;2915     /* 响应类型: R1 */
;;;2916     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
00003a  483d              LDR      r0,|L6.304|
00003c  6880              LDR      r0,[r0,#8]  ; RCA
00003e  0400              LSLS     r0,r0,#16
;;;2917     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
000040  6038              STR      r0,[r7,#0]  ; SDIO_CmdInitStructure
000042  2037              MOVS     r0,#0x37
000044  e9c70801          STRD     r0,r8,[r7,#4]
;;;2918     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2919     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2920     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2921     SDIO_SendCommand(&SDIO_CmdInitStructure);
000048  e9c75903          STRD     r5,r9,[r7,#0xc]
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       SDIO_SendCommand
;;;2922   
;;;2923     errorstatus = CmdResp1Error(SDIO_APP_CMD);
000052  2037              MOVS     r0,#0x37
000054  f7fffffe          BL       CmdResp1Error
;;;2924   
;;;2925     if (errorstatus != SD_OK)
000058  282a              CMP      r0,#0x2a
00005a  d131              BNE      |L6.192|
;;;2926     {
;;;2927       return(errorstatus);
;;;2928     }
;;;2929     /* 主机的数据块长度在初始化DPSM时设置 */
;;;2930     /* 初始化并使能SDIO数据通道状态机(DPSM) */
;;;2931     SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
00005c  f1070014          ADD      r0,r7,#0x14
000060  4934              LDR      r1,|L6.308|
000062  e9c01a00          STRD     r1,r10,[r0,#0]
;;;2932     SDIO_DataInitStructure.SDIO_DataLength = 8;
;;;2933     SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_8b;
000066  2130              MOVS     r1,#0x30
;;;2934     SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
000068  6081              STR      r1,[r0,#8]  ; SDIO_DataInitStructure
00006a  2102              MOVS     r1,#2
00006c  e9c01503          STRD     r1,r5,[r0,#0xc]
;;;2935     SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;2936     SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
000070  2101              MOVS     r1,#1
;;;2937     SDIO_DataConfig(&SDIO_DataInitStructure);
000072  6141              STR      r1,[r0,#0x14]  ; SDIO_DataInitStructure
000074  f7fffffe          BL       SDIO_DataConfig
;;;2938   
;;;2939   
;;;2940     /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
;;;2941     /* ACMD51: SEND_SCR ----------------------------------------------------------*/
;;;2942     /* 发送 ACMD51 要求卡发送SCR寄存器*/
;;;2943     /* 参数: - [31:0]: 填充位('0') */
;;;2944     /* 响应类型: R1 */
;;;2945     SDIO_CmdInitStructure.SDIO_Argument = 0x0;
;;;2946     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SD_APP_SEND_SCR;
000078  2033              MOVS     r0,#0x33
00007a  e9c75000          STRD     r5,r0,[r7,#0]
;;;2947     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2948     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2949     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
00007e  f8c79010          STR      r9,[r7,#0x10]  ; SDIO_CmdInitStructure
000082  e9c78502          STRD     r8,r5,[r7,#8]
;;;2950     SDIO_SendCommand(&SDIO_CmdInitStructure);
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       SDIO_SendCommand
;;;2951   
;;;2952     errorstatus = CmdResp1Error(SDIO_SD_APP_SEND_SCR);
00008c  2033              MOVS     r0,#0x33
00008e  f7fffffe          BL       CmdResp1Error
000092  4605              MOV      r5,r0
;;;2953   
;;;2954     if (errorstatus != SD_OK)
000094  282a              CMP      r0,#0x2a
000096  d113              BNE      |L6.192|
;;;2955     {
;;;2956       return(errorstatus);
;;;2957     }
;;;2958   
;;;2959     while (!(SDIO->STA & (SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR)))
000098  f8df809c          LDR      r8,|L6.312|
;;;2960     {
;;;2961       /* 如果接收FIFO中还有未读出的有效数据，则将其读出 */
;;;2962   	if (SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET)
00009c  f44f1a00          MOV      r10,#0x200000
0000a0  466f              MOV      r7,sp                 ;2887
0000a2  f240692a          MOV      r9,#0x62a             ;2959
                  |L6.166|
0000a6  f8d80034          LDR      r0,[r8,#0x34]         ;2959
0000aa  ea100f09          TST      r0,r9                 ;2959
0000ae  d009              BEQ      |L6.196|
;;;2963       {
;;;2964   	  /* 从接收FIFO中读出1个字 */
;;;2965         *(tempscr + index) = SDIO_ReadData();
;;;2966         index++;
;;;2967       }
;;;2968     }
;;;2969   
;;;2970     if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
0000b0  2008              MOVS     r0,#8
0000b2  f7fffffe          BL       SDIO_GetFlagStatus
0000b6  b180              CBZ      r0,|L6.218|
;;;2971     {
;;;2972       SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
0000b8  2008              MOVS     r0,#8
0000ba  f7fffffe          BL       SDIO_ClearFlag
;;;2973       errorstatus = SD_DATA_TIMEOUT;
0000be  2004              MOVS     r0,#4
                  |L6.192|
;;;2974       return(errorstatus);
;;;2975     }
;;;2976     else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;2977     {
;;;2978       SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;2979       errorstatus = SD_DATA_CRC_FAIL;
;;;2980       return(errorstatus);
;;;2981     }
;;;2982     else if (SDIO_GetFlagStatus(SDIO_FLAG_RXOVERR) != RESET)
;;;2983     {
;;;2984       SDIO_ClearFlag(SDIO_FLAG_RXOVERR);
;;;2985       errorstatus = SD_RX_OVERRUN;
;;;2986       return(errorstatus);
;;;2987     }
;;;2988     else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;2989     {
;;;2990       SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;2991       errorstatus = SD_START_BIT_ERR;
;;;2992       return(errorstatus);
;;;2993     }
;;;2994   
;;;2995     /* 清除所有静态标志 */
;;;2996     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;2997      /* SCR寄存器的数据包格式属于宽幅数据，先接收的是高字节 */
;;;2998     *(pscr + 1) = ((tempscr[0] & SD_0TO7BITS) << 24) | ((tempscr[0] & SD_8TO15BITS) << 8) | ((tempscr[0] & SD_16TO23BITS) >> 8) | ((tempscr[0] & SD_24TO31BITS) >> 24);
;;;2999   
;;;3000     *(pscr) = ((tempscr[1] & SD_0TO7BITS) << 24) | ((tempscr[1] & SD_8TO15BITS) << 8) | ((tempscr[1] & SD_16TO23BITS) >> 8) | ((tempscr[1] & SD_24TO31BITS) >> 24);
;;;3001   
;;;3002     return(errorstatus);
;;;3003   }
0000c0  e8bd87fc          POP      {r2-r10,pc}
                  |L6.196|
0000c4  4650              MOV      r0,r10                ;2962
0000c6  f7fffffe          BL       SDIO_GetFlagStatus
0000ca  2800              CMP      r0,#0                 ;2962
0000cc  d0eb              BEQ      |L6.166|
0000ce  f7fffffe          BL       SDIO_ReadData
0000d2  f8470024          STR      r0,[r7,r4,LSL #2]     ;2965
0000d6  1c64              ADDS     r4,r4,#1              ;2966
0000d8  e7e5              B        |L6.166|
                  |L6.218|
0000da  2002              MOVS     r0,#2                 ;2976
0000dc  f7fffffe          BL       SDIO_GetFlagStatus
0000e0  b120              CBZ      r0,|L6.236|
0000e2  2002              MOVS     r0,#2                 ;2978
0000e4  f7fffffe          BL       SDIO_ClearFlag
0000e8  2002              MOVS     r0,#2                 ;2979
0000ea  e7e9              B        |L6.192|
                  |L6.236|
0000ec  2020              MOVS     r0,#0x20              ;2982
0000ee  f7fffffe          BL       SDIO_GetFlagStatus
0000f2  b120              CBZ      r0,|L6.254|
0000f4  2020              MOVS     r0,#0x20              ;2984
0000f6  f7fffffe          BL       SDIO_ClearFlag
0000fa  2006              MOVS     r0,#6                 ;2985
0000fc  e7e0              B        |L6.192|
                  |L6.254|
0000fe  f44f7400          MOV      r4,#0x200             ;2988
000102  4620              MOV      r0,r4                 ;2988
000104  f7fffffe          BL       SDIO_GetFlagStatus
000108  b120              CBZ      r0,|L6.276|
00010a  4620              MOV      r0,r4                 ;2990
00010c  f7fffffe          BL       SDIO_ClearFlag
000110  2007              MOVS     r0,#7                 ;2991
000112  e7d5              B        |L6.192|
                  |L6.276|
000114  f24050ff          MOV      r0,#0x5ff             ;2996
000118  f7fffffe          BL       SDIO_ClearFlag
00011c  9800              LDR      r0,[sp,#0]            ;2998
00011e  ba00              REV      r0,r0                 ;2998
000120  6070              STR      r0,[r6,#4]            ;3000
000122  9801              LDR      r0,[sp,#4]            ;3000
000124  ba00              REV      r0,r0                 ;3000
000126  6030              STR      r0,[r6,#0]            ;3002
000128  4628              MOV      r0,r5                 ;3002
00012a  e7c9              B        |L6.192|
;;;3004   
                          ENDP

                  |L6.300|
                          DCD      ||.bss||+0x38
                  |L6.304|
                          DCD      ||.data||
                  |L6.308|
                          DCD      0x000fffff
                  |L6.312|
                          DCD      0x40018000

                          AREA ||i.IsCardProgramming||, CODE, READONLY, ALIGN=2

                  IsCardProgramming PROC
;;;2717     */
;;;2718   static SD_Error IsCardProgramming(uint8_t *pstatus)
000000  b570              PUSH     {r4-r6,lr}
;;;2719   {
000002  4604              MOV      r4,r0
;;;2720     SD_Error errorstatus = SD_OK;
;;;2721     __IO uint32_t respR1 = 0, status = 0;
;;;2722     /* CMD13: SEND_STATUS -------------------------------------------------------------*/
;;;2723     /* 发送 CMD13 要求卡发送状态寄存器(这里指卡状态，如果该命令在紧随CMD55之后发送，则为SD状态) */
;;;2724     /* 参数: - [31:16]: 相对卡地址RCA
;;;2725               - [15:0]: 填充位(‘0’) */
;;;2726     /* 响应类型: R1 */
;;;2727     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
000004  4840              LDR      r0,|L7.264|
000006  252a              MOVS     r5,#0x2a              ;2720
000008  6880              LDR      r0,[r0,#8]  ; RCA
00000a  0401              LSLS     r1,r0,#16
00000c  483f              LDR      r0,|L7.268|
;;;2728     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_STATUS;
00000e  6001              STR      r1,[r0,#0]  ; SDIO_CmdInitStructure
000010  210d              MOVS     r1,#0xd
;;;2729     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000012  6041              STR      r1,[r0,#4]  ; SDIO_CmdInitStructure
000014  2140              MOVS     r1,#0x40
;;;2730     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
000016  6081              STR      r1,[r0,#8]  ; SDIO_CmdInitStructure
000018  2100              MOVS     r1,#0
;;;2731     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
00001a  60c1              STR      r1,[r0,#0xc]  ; SDIO_CmdInitStructure
00001c  f44f6180          MOV      r1,#0x400
;;;2732     SDIO_SendCommand(&SDIO_CmdInitStructure);
000020  6101              STR      r1,[r0,#0x10]  ; SDIO_CmdInitStructure
000022  f7fffffe          BL       SDIO_SendCommand
;;;2733   
;;;2734     status = SDIO->STA;
000026  493a              LDR      r1,|L7.272|
                  |L7.40|
;;;2735     while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)))
;;;2736     {
;;;2737       status = SDIO->STA;
000028  6b48              LDR      r0,[r1,#0x34]
00002a  f0100f45          TST      r0,#0x45              ;2735
00002e  d0fb              BEQ      |L7.40|
;;;2738     }
;;;2739     /* 命令响应超时 */
;;;2740     if (status & SDIO_FLAG_CTIMEOUT)
000030  0741              LSLS     r1,r0,#29
000032  d502              BPL      |L7.58|
;;;2741     {
;;;2742       errorstatus = SD_CMD_RSP_TIMEOUT;
000034  2403              MOVS     r4,#3
;;;2743       SDIO_ClearFlag(SDIO_FLAG_CTIMEOUT);
000036  2004              MOVS     r0,#4
;;;2744       return(errorstatus);
000038  e003              B        |L7.66|
                  |L7.58|
;;;2745     }
;;;2746     /* 已接收到响应，但CRC校验失败 */
;;;2747     else if (status & SDIO_FLAG_CCRCFAIL)
00003a  07c0              LSLS     r0,r0,#31
00003c  d005              BEQ      |L7.74|
;;;2748     {
;;;2749       errorstatus = SD_CMD_CRC_FAIL;
00003e  2401              MOVS     r4,#1
;;;2750       SDIO_ClearFlag(SDIO_FLAG_CCRCFAIL);
000040  4620              MOV      r0,r4
                  |L7.66|
000042  f7fffffe          BL       SDIO_ClearFlag
;;;2751       return(errorstatus);
000046  4620              MOV      r0,r4
;;;2752     }
;;;2753     /* 已接收到响应，并且CRC校验成功 -----------------------------------------------------*/
;;;2754     /* 检查是不是该命令的响应 */
;;;2755     status = (uint32_t)SDIO_GetCommandResponse();
;;;2756   
;;;2757     /* Check response received is of desired command */
;;;2758     if (status != SDIO_SEND_STATUS)
;;;2759     {
;;;2760       errorstatus = SD_ILLEGAL_CMD;
;;;2761       return(errorstatus);
;;;2762     }
;;;2763     /* 清除所有静态标志 */
;;;2764     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;2765   
;;;2766     /* 从SDIO_RESP1寄存器中读取响应R1 */
;;;2767     /* We have received response, retrieve it for analysis  */
;;;2768     respR1 = SDIO_GetResponse(SDIO_RESP1);
;;;2769   
;;;2770     /* Find out card status */
;;;2771     /* 解析 CURRENT_STATE(卡状态位[12:9]) */
;;;2772     *pstatus = (uint8_t) ((respR1 >> 9) & 0x0000000F);
;;;2773   
;;;2774     if ((respR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
;;;2775     {
;;;2776       return(errorstatus);
;;;2777     }
;;;2778   
;;;2779     if (respR1 & SD_OCR_ADDR_OUT_OF_RANGE)
;;;2780     {
;;;2781       return(SD_ADDR_OUT_OF_RANGE);
;;;2782     }
;;;2783   
;;;2784     if (respR1 & SD_OCR_ADDR_MISALIGNED)
;;;2785     {
;;;2786       return(SD_ADDR_MISALIGNED);
;;;2787     }
;;;2788   
;;;2789     if (respR1 & SD_OCR_BLOCK_LEN_ERR)
;;;2790     {
;;;2791       return(SD_BLOCK_LEN_ERR);
;;;2792     }
;;;2793   
;;;2794     if (respR1 & SD_OCR_ERASE_SEQ_ERR)
;;;2795     {
;;;2796       return(SD_ERASE_SEQ_ERR);
;;;2797     }
;;;2798   
;;;2799     if (respR1 & SD_OCR_BAD_ERASE_PARAM)
;;;2800     {
;;;2801       return(SD_BAD_ERASE_PARAM);
;;;2802     }
;;;2803   
;;;2804     if (respR1 & SD_OCR_WRITE_PROT_VIOLATION)
;;;2805     {
;;;2806       return(SD_WRITE_PROT_VIOLATION);
;;;2807     }
;;;2808   
;;;2809     if (respR1 & SD_OCR_LOCK_UNLOCK_FAILED)
;;;2810     {
;;;2811       return(SD_LOCK_UNLOCK_FAILED);
;;;2812     }
;;;2813   
;;;2814     if (respR1 & SD_OCR_COM_CRC_FAILED)
;;;2815     {
;;;2816       return(SD_COM_CRC_FAILED);
;;;2817     }
;;;2818   
;;;2819     if (respR1 & SD_OCR_ILLEGAL_CMD)
;;;2820     {
;;;2821       return(SD_ILLEGAL_CMD);
;;;2822     }
;;;2823   
;;;2824     if (respR1 & SD_OCR_CARD_ECC_FAILED)
;;;2825     {
;;;2826       return(SD_CARD_ECC_FAILED);
;;;2827     }
;;;2828   
;;;2829     if (respR1 & SD_OCR_CC_ERROR)
;;;2830     {
;;;2831       return(SD_CC_ERROR);
;;;2832     }
;;;2833   
;;;2834     if (respR1 & SD_OCR_GENERAL_UNKNOWN_ERROR)
;;;2835     {
;;;2836       return(SD_GENERAL_UNKNOWN_ERROR);
;;;2837     }
;;;2838   
;;;2839     if (respR1 & SD_OCR_STREAM_READ_UNDERRUN)
;;;2840     {
;;;2841       return(SD_STREAM_READ_UNDERRUN);
;;;2842     }
;;;2843   
;;;2844     if (respR1 & SD_OCR_STREAM_WRITE_OVERRUN)
;;;2845     {
;;;2846       return(SD_STREAM_WRITE_OVERRUN);
;;;2847     }
;;;2848   
;;;2849     if (respR1 & SD_OCR_CID_CSD_OVERWRIETE)
;;;2850     {
;;;2851       return(SD_CID_CSD_OVERWRITE);
;;;2852     }
;;;2853   
;;;2854     if (respR1 & SD_OCR_WP_ERASE_SKIP)
;;;2855     {
;;;2856       return(SD_WP_ERASE_SKIP);
;;;2857     }
;;;2858   
;;;2859     if (respR1 & SD_OCR_CARD_ECC_DISABLED)
;;;2860     {
;;;2861       return(SD_CARD_ECC_DISABLED);
;;;2862     }
;;;2863   
;;;2864     if (respR1 & SD_OCR_ERASE_RESET)
;;;2865     {
;;;2866       return(SD_ERASE_RESET);
;;;2867     }
;;;2868   
;;;2869     if (respR1 & SD_OCR_AKE_SEQ_ERROR)
;;;2870     {
;;;2871       return(SD_AKE_SEQ_ERROR);
;;;2872     }
;;;2873   
;;;2874     return(errorstatus);
;;;2875   }
000048  bd70              POP      {r4-r6,pc}
                  |L7.74|
00004a  f7fffffe          BL       SDIO_GetCommandResponse
00004e  280d              CMP      r0,#0xd               ;2758
000050  d12e              BNE      |L7.176|
000052  f24050ff          MOV      r0,#0x5ff             ;2764
000056  f7fffffe          BL       SDIO_ClearFlag
00005a  2000              MOVS     r0,#0                 ;2768
00005c  f7fffffe          BL       SDIO_GetResponse
000060  f3c02143          UBFX     r1,r0,#9,#4           ;2772
000064  7021              STRB     r1,[r4,#0]            ;2772
000066  492b              LDR      r1,|L7.276|
000068  4208              TST      r0,r1                 ;2774
00006a  d04b              BEQ      |L7.260|
00006c  2800              CMP      r0,#0                 ;2779
00006e  da01              BGE      |L7.116|
000070  201c              MOVS     r0,#0x1c              ;2781
000072  bd70              POP      {r4-r6,pc}
                  |L7.116|
000074  0041              LSLS     r1,r0,#1              ;2784
000076  d501              BPL      |L7.124|
000078  2009              MOVS     r0,#9                 ;2786
00007a  bd70              POP      {r4-r6,pc}
                  |L7.124|
00007c  0081              LSLS     r1,r0,#2              ;2789
00007e  d501              BPL      |L7.132|
000080  200a              MOVS     r0,#0xa               ;2791
000082  bd70              POP      {r4-r6,pc}
                  |L7.132|
000084  00c1              LSLS     r1,r0,#3              ;2794
000086  d501              BPL      |L7.140|
000088  200b              MOVS     r0,#0xb               ;2796
00008a  bd70              POP      {r4-r6,pc}
                  |L7.140|
00008c  0101              LSLS     r1,r0,#4              ;2799
00008e  d501              BPL      |L7.148|
000090  200c              MOVS     r0,#0xc               ;2801
000092  bd70              POP      {r4-r6,pc}
                  |L7.148|
000094  0141              LSLS     r1,r0,#5              ;2804
000096  d501              BPL      |L7.156|
000098  200d              MOVS     r0,#0xd               ;2806
00009a  bd70              POP      {r4-r6,pc}
                  |L7.156|
00009c  01c1              LSLS     r1,r0,#7              ;2809
00009e  d501              BPL      |L7.164|
0000a0  200e              MOVS     r0,#0xe               ;2811
0000a2  bd70              POP      {r4-r6,pc}
                  |L7.164|
0000a4  0201              LSLS     r1,r0,#8              ;2814
0000a6  d501              BPL      |L7.172|
0000a8  200f              MOVS     r0,#0xf               ;2816
0000aa  bd70              POP      {r4-r6,pc}
                  |L7.172|
0000ac  0241              LSLS     r1,r0,#9              ;2819
0000ae  d501              BPL      |L7.180|
                  |L7.176|
0000b0  2010              MOVS     r0,#0x10              ;2821
0000b2  bd70              POP      {r4-r6,pc}
                  |L7.180|
0000b4  0281              LSLS     r1,r0,#10             ;2824
0000b6  d501              BPL      |L7.188|
0000b8  2011              MOVS     r0,#0x11              ;2826
0000ba  bd70              POP      {r4-r6,pc}
                  |L7.188|
0000bc  02c1              LSLS     r1,r0,#11             ;2829
0000be  d501              BPL      |L7.196|
0000c0  2012              MOVS     r0,#0x12              ;2831
0000c2  bd70              POP      {r4-r6,pc}
                  |L7.196|
0000c4  0301              LSLS     r1,r0,#12             ;2834
0000c6  d501              BPL      |L7.204|
0000c8  2013              MOVS     r0,#0x13              ;2836
0000ca  bd70              POP      {r4-r6,pc}
                  |L7.204|
0000cc  0341              LSLS     r1,r0,#13             ;2839
0000ce  d501              BPL      |L7.212|
0000d0  2014              MOVS     r0,#0x14              ;2841
0000d2  bd70              POP      {r4-r6,pc}
                  |L7.212|
0000d4  0381              LSLS     r1,r0,#14             ;2844
0000d6  d501              BPL      |L7.220|
0000d8  2015              MOVS     r0,#0x15              ;2846
0000da  bd70              POP      {r4-r6,pc}
                  |L7.220|
0000dc  03c1              LSLS     r1,r0,#15             ;2849
0000de  d501              BPL      |L7.228|
0000e0  2016              MOVS     r0,#0x16              ;2851
0000e2  bd70              POP      {r4-r6,pc}
                  |L7.228|
0000e4  0401              LSLS     r1,r0,#16             ;2854
0000e6  d501              BPL      |L7.236|
0000e8  2017              MOVS     r0,#0x17              ;2856
0000ea  bd70              POP      {r4-r6,pc}
                  |L7.236|
0000ec  0441              LSLS     r1,r0,#17             ;2859
0000ee  d501              BPL      |L7.244|
0000f0  2018              MOVS     r0,#0x18              ;2861
0000f2  bd70              POP      {r4-r6,pc}
                  |L7.244|
0000f4  0481              LSLS     r1,r0,#18             ;2864
0000f6  d501              BPL      |L7.252|
0000f8  2019              MOVS     r0,#0x19              ;2866
0000fa  bd70              POP      {r4-r6,pc}
                  |L7.252|
0000fc  0700              LSLS     r0,r0,#28             ;2869
0000fe  d501              BPL      |L7.260|
000100  201a              MOVS     r0,#0x1a              ;2871
000102  bd70              POP      {r4-r6,pc}
                  |L7.260|
000104  4628              MOV      r0,r5                 ;2874
000106  bd70              POP      {r4-r6,pc}
;;;2876   
                          ENDP

                  |L7.264|
                          DCD      ||.data||
                  |L7.268|
                          DCD      ||.bss||+0x38
                  |L7.272|
                          DCD      0x40018000
                  |L7.276|
                          DCD      0xfdffe008

                          AREA ||i.LCD_DrawCir||, CODE, READONLY, ALIGN=2

                  LCD_DrawCir PROC
;;;606    *************************************************************/
;;;607    void LCD_DrawCir(u16 x,u16 y,u16 r,u16 Colour)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;608    {
000004  4614              MOV      r4,r2
000006  4606              MOV      r6,r0
;;;609    	u16 i,j;	
;;;610    	if(horizontal_or_vertical)			 //横屏显示时
000008  4855              LDR      r0,|L8.352|
;;;611    	{	
;;;612    		if(x+r>320||r-x>0)
00000a  1935              ADDS     r5,r6,r4
00000c  b081              SUB      sp,sp,#4              ;608
00000e  7882              LDRB     r2,[r0,#2]            ;610  ; horizontal_or_vertical
000010  1ba0              SUBS     r0,r4,r6
;;;613    			LCD_PutString(19,190,"ERRO!",Red,Black);
;;;614    		if(r+y>240||r-y>0)
000012  eba40a01          SUB      r10,r4,r1
000016  eb040901          ADD      r9,r4,r1
;;;615    			LCD_PutString(19,190,"ERRO!",Red,Black);
;;;616    
;;;617    		LCD_WR_CMD(0x0044,(y+r-1)<<8); 
00001a  eb010b04          ADD      r11,r1,r4
;;;618    		LCD_WR_CMD(0x004e,y-r);        //设置X方向初始值
00001e  eba10804          SUB      r8,r1,r4
;;;619    		
;;;620    		/*R45、R46   垂直方向的起、止点*/
;;;621    		LCD_WR_CMD(0x0045,x-r);	  
000022  1b37              SUBS     r7,r6,r4
000024  b3a2              CBZ      r2,|L8.144|
000026  f5b57fa0          CMP      r5,#0x140             ;612
00002a  d801              BHI      |L8.48|
00002c  2800              CMP      r0,#0                 ;612
00002e  dd08              BLE      |L8.66|
                  |L8.48|
000030  2000              MOVS     r0,#0                 ;613
000032  9000              STR      r0,[sp,#0]            ;613
000034  f44f4378          MOV      r3,#0xf800            ;613
000038  a24a              ADR      r2,|L8.356|
00003a  21be              MOVS     r1,#0xbe              ;613
00003c  2013              MOVS     r0,#0x13              ;613
00003e  f7fffffe          BL       LCD_PutString
                  |L8.66|
000042  f1b90ff0          CMP      r9,#0xf0              ;614
000046  d802              BHI      |L8.78|
000048  f1ba0f00          CMP      r10,#0                ;614
00004c  dd08              BLE      |L8.96|
                  |L8.78|
00004e  2000              MOVS     r0,#0                 ;615
000050  9000              STR      r0,[sp,#0]            ;615
000052  f44f4378          MOV      r3,#0xf800            ;615
000056  a243              ADR      r2,|L8.356|
000058  21be              MOVS     r1,#0xbe              ;615
00005a  2013              MOVS     r0,#0x13              ;615
00005c  f7fffffe          BL       LCD_PutString
                  |L8.96|
000060  ea4f200b          LSL      r0,r11,#8             ;617
000064  f5a07080          SUB      r0,r0,#0x100          ;617
000068  b281              UXTH     r1,r0                 ;617
00006a  2044              MOVS     r0,#0x44              ;617
00006c  f7fffffe          BL       LCD_WR_CMD
000070  fa1ff188          UXTH     r1,r8                 ;618
000074  204e              MOVS     r0,#0x4e              ;618
000076  f7fffffe          BL       LCD_WR_CMD
00007a  b2b9              UXTH     r1,r7
00007c  2045              MOVS     r0,#0x45
00007e  f7fffffe          BL       LCD_WR_CMD
;;;622    		LCD_WR_CMD(0x0046,x+r-1);
000082  1e6d              SUBS     r5,r5,#1
000084  b2a9              UXTH     r1,r5
000086  2046              MOVS     r0,#0x46
000088  f7fffffe          BL       LCD_WR_CMD
;;;623    	   	LCD_WR_CMD(0x004f,x-r);        //设置y方向初始值
00008c  b2b9              UXTH     r1,r7
00008e  e036              B        |L8.254|
                  |L8.144|
000090  e7ff              B        |L8.146|
                  |L8.146|
;;;624    
;;;625    	}
;;;626    	else								//竖屏显示时
;;;627    	{
;;;628    		if(x+r>240||r-x>0)
000092  2df0              CMP      r5,#0xf0
000094  d801              BHI      |L8.154|
000096  2800              CMP      r0,#0
000098  dd08              BLE      |L8.172|
                  |L8.154|
;;;629    			LCD_PutString(19,190,"ERRO!",Red,Black);;
00009a  2000              MOVS     r0,#0
00009c  9000              STR      r0,[sp,#0]
00009e  f44f4378          MOV      r3,#0xf800
0000a2  a230              ADR      r2,|L8.356|
0000a4  21be              MOVS     r1,#0xbe
0000a6  2013              MOVS     r0,#0x13
0000a8  f7fffffe          BL       LCD_PutString
                  |L8.172|
;;;630    		if(r+y>320||r-y>0)
0000ac  f5b97fa0          CMP      r9,#0x140
0000b0  d802              BHI      |L8.184|
0000b2  f1ba0f00          CMP      r10,#0
0000b6  dd08              BLE      |L8.202|
                  |L8.184|
;;;631    			LCD_PutString(19,190,"ERRO!",Red,Black);;		
0000b8  2000              MOVS     r0,#0
0000ba  9000              STR      r0,[sp,#0]
0000bc  f44f4378          MOV      r3,#0xf800
0000c0  a228              ADR      r2,|L8.356|
0000c2  21be              MOVS     r1,#0xbe
0000c4  2013              MOVS     r0,#0x13
0000c6  f7fffffe          BL       LCD_PutString
                  |L8.202|
;;;632    		LCD_WR_CMD(0x0044,((x+r-1)<<8)+x-r); 
0000ca  0228              LSLS     r0,r5,#8
0000cc  f5a07080          SUB      r0,r0,#0x100
0000d0  4430              ADD      r0,r0,r6
0000d2  1b00              SUBS     r0,r0,r4
0000d4  b281              UXTH     r1,r0
0000d6  2044              MOVS     r0,#0x44
0000d8  f7fffffe          BL       LCD_WR_CMD
;;;633    		LCD_WR_CMD(0x004e,x-r);        //设置X方向初始值
0000dc  b2b9              UXTH     r1,r7
0000de  204e              MOVS     r0,#0x4e
0000e0  f7fffffe          BL       LCD_WR_CMD
;;;634    		
;;;635    		/*R45、R46   垂直方向的起、止点*/
;;;636    		LCD_WR_CMD(0x0045,y-r);	  
0000e4  fa1ff188          UXTH     r1,r8
0000e8  2045              MOVS     r0,#0x45
0000ea  f7fffffe          BL       LCD_WR_CMD
;;;637    		LCD_WR_CMD(0x0046,y+r-1);
0000ee  f1ab0001          SUB      r0,r11,#1
0000f2  b281              UXTH     r1,r0
0000f4  2046              MOVS     r0,#0x46
0000f6  f7fffffe          BL       LCD_WR_CMD
;;;638    	   	LCD_WR_CMD(0x004f,y-r);        //设置y方向初始值
0000fa  fa1ff188          UXTH     r1,r8
                  |L8.254|
0000fe  204f              MOVS     r0,#0x4f
000100  f7fffffe          BL       LCD_WR_CMD
000104  f04f46d8          MOV      r6,#0x6c000000
;;;639    	}
;;;640    	LCD_WR_ADD(0x0022);
000108  2022              MOVS     r0,#0x22
00010a  8030              STRH     r0,[r6,#0]
;;;641    	for(i=0;i<2*r;i++)
00010c  2200              MOVS     r2,#0
00010e  e020              B        |L8.338|
                  |L8.272|
;;;642    		for(j=0;j<2*r;j++)
000110  2000              MOVS     r0,#0
000112  e019              B        |L8.328|
                  |L8.276|
;;;643    		{
;;;644    			if((abs(r-i)*abs(r-i)+abs(r-j)*abs(r-j))<=r*r)
000114  eba40102          SUB      r1,r4,r2
000118  1a23              SUBS     r3,r4,r0
00011a  d401              BMI      |L8.288|
00011c  461d              MOV      r5,r3
00011e  e001              B        |L8.292|
                  |L8.288|
000120  425d              RSBS     r5,r3,#0
000122  462b              MOV      r3,r5
                  |L8.292|
000124  435d              MULS     r5,r3,r5
000126  1e0b              SUBS     r3,r1,#0
000128  da01              BGE      |L8.302|
00012a  425b              RSBS     r3,r3,#0
00012c  4619              MOV      r1,r3
                  |L8.302|
00012e  fb015303          MLA      r3,r1,r3,r5
000132  fb04f104          MUL      r1,r4,r4
000136  428b              CMP      r3,r1
000138  dc01              BGT      |L8.318|
;;;645    				LCD_WR_DATA(Colour);
00013a  9904              LDR      r1,[sp,#0x10]
00013c  e001              B        |L8.322|
                  |L8.318|
;;;646    			else
;;;647    			{
;;;648    				
;;;649    				LCD_WR_DATA(Red);
00013e  f44f4178          MOV      r1,#0xf800
                  |L8.322|
000142  8071              STRH     r1,[r6,#2]
000144  1c40              ADDS     r0,r0,#1              ;642
000146  b280              UXTH     r0,r0                 ;642
                  |L8.328|
000148  ebb00f44          CMP      r0,r4,LSL #1          ;642
00014c  d3e2              BCC      |L8.276|
00014e  1c52              ADDS     r2,r2,#1              ;641
000150  b292              UXTH     r2,r2                 ;641
                  |L8.338|
000152  ebb20f44          CMP      r2,r4,LSL #1          ;641
000156  d3db              BCC      |L8.272|
;;;650    			}
;;;651    				
;;;652    		}		
;;;653    }
000158  b005              ADD      sp,sp,#0x14
00015a  e8bd8ff0          POP      {r4-r11,pc}
;;;654    
                          ENDP

00015e  0000              DCW      0x0000
                  |L8.352|
                          DCD      ||.data||
                  |L8.356|
000164  4552524f          DCB      "ERRO!",0
000168  2100    
00016a  00                DCB      0
00016b  00                DCB      0

                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;537    *************************************************************/
;;;538    void LCD_DrawLine(u16 x,u16 y,u16 Length,u16 Colour) 
000000  b530              PUSH     {r4,r5,lr}
;;;539    {
000002  4614              MOV      r4,r2
;;;540    	u16 i;
;;;541    	if(horizontal_or_vertical)			 //横屏显示时
000004  4a0d              LDR      r2,|L9.60|
000006  461d              MOV      r5,r3                 ;539
000008  7893              LDRB     r3,[r2,#2]  ; horizontal_or_vertical
;;;542    	{	
;;;543    		if(x+Length>320)
00000a  1902              ADDS     r2,r0,r4
00000c  b12b              CBZ      r3,|L9.26|
00000e  f5b27fa0          CMP      r2,#0x140
000012  d907              BLS      |L9.36|
;;;544    			Length=320-Length;
000014  f5c472a0          RSB      r2,r4,#0x140
000018  e003              B        |L9.34|
                  |L9.26|
;;;545    	}
;;;546    	else
;;;547    	{
;;;548    		if(x+Length>240)
00001a  2af0              CMP      r2,#0xf0
00001c  d902              BLS      |L9.36|
;;;549    			Length=240-Length;
00001e  f1c402f0          RSB      r2,r4,#0xf0
                  |L9.34|
000022  b294              UXTH     r4,r2
                  |L9.36|
;;;550    	}
;;;551    	LCD_SetPosition(x,y);
000024  f7fffffe          BL       LCD_SetPosition
;;;552    	for(i=0;i<Length;i++)
000028  2000              MOVS     r0,#0
00002a  f04f41d8          MOV      r1,#0x6c000000
00002e  e002              B        |L9.54|
                  |L9.48|
000030  804d              STRH     r5,[r1,#2]
000032  1c40              ADDS     r0,r0,#1
000034  b280              UXTH     r0,r0
                  |L9.54|
000036  42a0              CMP      r0,r4
000038  d3fa              BCC      |L9.48|
;;;553    		LCD_WR_DATA(Colour);
;;;554    }
00003a  bd30              POP      {r4,r5,pc}
;;;555    
                          ENDP

                  |L9.60|
                          DCD      ||.data||

                          AREA ||i.LCD_DrawRec||, CODE, READONLY, ALIGN=2

                  LCD_DrawRec PROC
;;;566    *************************************************************/
;;;567    void LCD_DrawRec(u16 x,u16 y,u16 Length,u16 High,u16 Colour)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;568    {
000004  4606              MOV      r6,r0
;;;569    	u16 i;	
;;;570    	if(horizontal_or_vertical)			 //横屏显示时
000006  4828              LDR      r0,|L10.168|
000008  4614              MOV      r4,r2                 ;568
00000a  461d              MOV      r5,r3                 ;568
00000c  7882              LDRB     r2,[r0,#2]  ; horizontal_or_vertical
00000e  460f              MOV      r7,r1                 ;568
;;;571    	{	
;;;572    		if(x+Length>320)
000010  1930              ADDS     r0,r6,r4
000012  f8dd8018          LDR      r8,[sp,#0x18]         ;570
000016  f44f73a0          MOV      r3,#0x140
;;;573    			Length=320-Length;
;;;574    		if(High+y>240)
00001a  19e9              ADDS     r1,r5,r7
00001c  b1c2              CBZ      r2,|L10.80|
00001e  4298              CMP      r0,r3                 ;572
000020  d902              BLS      |L10.40|
000022  f5c470a0          RSB      r0,r4,#0x140          ;573
000026  b284              UXTH     r4,r0                 ;573
                  |L10.40|
000028  29f0              CMP      r1,#0xf0
00002a  d902              BLS      |L10.50|
;;;575    			High=240-High;
00002c  f1c500f0          RSB      r0,r5,#0xf0
000030  b285              UXTH     r5,r0
                  |L10.50|
;;;576    		LCD_SetPosition(x,y);
000032  4639              MOV      r1,r7
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       LCD_SetPosition
;;;577    		LCD_WR_CMD(0X0044,((High+y-1)<<8)+y);
00003a  19e8              ADDS     r0,r5,r7
00003c  0200              LSLS     r0,r0,#8
00003e  f5a07080          SUB      r0,r0,#0x100
000042  4438              ADD      r0,r0,r7
000044  b281              UXTH     r1,r0
000046  2044              MOVS     r0,#0x44
000048  f7fffffe          BL       LCD_WR_CMD
;;;578    		LCD_WR_CMD(0X0046,x+Length);
00004c  1930              ADDS     r0,r6,r4
00004e  e017              B        |L10.128|
                  |L10.80|
;;;579    	}
;;;580    	else								//竖屏显示时
;;;581    	{
;;;582    		if(x+Length>240)
000050  28f0              CMP      r0,#0xf0
000052  d902              BLS      |L10.90|
;;;583    			Length=240-Length;
000054  f1c400f0          RSB      r0,r4,#0xf0
000058  b284              UXTH     r4,r0
                  |L10.90|
;;;584    		if(High+y>320)
00005a  4299              CMP      r1,r3
00005c  d902              BLS      |L10.100|
;;;585    			High=320-High;
00005e  f5c570a0          RSB      r0,r5,#0x140
000062  b285              UXTH     r5,r0
                  |L10.100|
;;;586    		LCD_SetPosition(x,y);
000064  4639              MOV      r1,r7
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       LCD_SetPosition
;;;587    		LCD_WR_CMD(0X0044,((Length+x-1)<<8)+x);
00006c  19a0              ADDS     r0,r4,r6
00006e  0200              LSLS     r0,r0,#8
000070  f5a07080          SUB      r0,r0,#0x100
000074  4430              ADD      r0,r0,r6
000076  b281              UXTH     r1,r0
000078  2044              MOVS     r0,#0x44
00007a  f7fffffe          BL       LCD_WR_CMD
;;;588    		LCD_WR_CMD(0X0046,y+High);
00007e  1978              ADDS     r0,r7,r5
                  |L10.128|
000080  b281              UXTH     r1,r0
000082  2046              MOVS     r0,#0x46
000084  f7fffffe          BL       LCD_WR_CMD
000088  f04f42d8          MOV      r2,#0x6c000000
;;;589    	}
;;;590    	LCD_WR_ADD(0x0022);
00008c  2022              MOVS     r0,#0x22
00008e  8010              STRH     r0,[r2,#0]
;;;591    	for(i=0;i<Length*High;i++)
000090  2000              MOVS     r0,#0
000092  436c              MULS     r4,r5,r4
000094  e003              B        |L10.158|
                  |L10.150|
000096  f8a28002          STRH     r8,[r2,#2]
00009a  1c40              ADDS     r0,r0,#1
00009c  b280              UXTH     r0,r0
                  |L10.158|
00009e  4284              CMP      r4,r0
0000a0  dcf9              BGT      |L10.150|
;;;592    	{
;;;593    		LCD_WR_DATA(Colour);
;;;594    	}	
;;;595    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
;;;596    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L10.168|
                          DCD      ||.data||

                          AREA ||i.LCD_MyInit||, CODE, READONLY, ALIGN=1

                  LCD_MyInit PROC
;;;199    ********************************************************/
;;;200    void LCD_MyInit(u8 ver)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	unsigned long n;       
;;;203    	LCD_Set_Ver(ver);					//0为水平显示
000002  f7fffffe          BL       LCD_Set_Ver
;;;204    
;;;205    	LCD_WR_CMD(0x0000,0x0001);
000006  2101              MOVS     r1,#1
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       LCD_WR_CMD
;;;206        LCD_WR_CMD(0x0000,0x0001);      //打开晶振
00000e  2101              MOVS     r1,#1
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       LCD_WR_CMD
;;;207    	LCD_WR_CMD(0x0003,0x6664);      //0xA8A4//  调整功耗，使用默认值
000016  f2466164          MOV      r1,#0x6664
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       LCD_WR_CMD
;;;208    	LCD_WR_CMD(0x000C,0x0000);      //电源控制   5.1V  	   ，好像没什么用
000020  2100              MOVS     r1,#0
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       LCD_WR_CMD
;;;209    	LCD_WR_CMD(0x000D,0x080C);      //Vlcd63振幅的放大倍数 ，好像没什么用 
000028  f640010c          MOV      r1,#0x80c
00002c  200d              MOVS     r0,#0xd
00002e  f7fffffe          BL       LCD_WR_CMD
;;;210    	LCD_WR_CMD(0x000E,0x2B00);      //Vlcd63使用外部参考电压  
000032  f44f512c          MOV      r1,#0x2b00
000036  200e              MOVS     r0,#0xe
000038  f7fffffe          BL       LCD_WR_CMD
;;;211    	LCD_WR_CMD(0x001E,0x00b0);      //不重新设置LCD的复位电平    b0  
00003c  21b0              MOVS     r1,#0xb0
00003e  201e              MOVS     r0,#0x1e
000040  f7fffffe          BL       LCD_WR_CMD
;;;212        	
;;;213    	LCD_WR_CMD(0x0002,0x0600);     //LCD Driving Waveform control
000044  f44f61c0          MOV      r1,#0x600
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       LCD_WR_CMD
;;;214    	LCD_WR_CMD(0x0010,0x0000);     //禁止睡眠模式
00004e  2100              MOVS     r1,#0
000050  2010              MOVS     r0,#0x10
000052  f7fffffe          BL       LCD_WR_CMD
;;;215    	
;;;216    	/*这两个为比较寄存器？？在读写数据时进行比较，不能在外部显示模式下使用***/
;;;217    	LCD_WR_CMD(0x0005,0x0000);     
000056  2100              MOVS     r1,#0
000058  2005              MOVS     r0,#5
00005a  f7fffffe          BL       LCD_WR_CMD
;;;218    	LCD_WR_CMD(0x0006,0x0000);     	
00005e  2100              MOVS     r1,#0
000060  2006              MOVS     r0,#6
000062  f7fffffe          BL       LCD_WR_CMD
;;;219    	/************************************************************************/
;;;220    	LCD_WR_CMD(0x0016,0xEF1C);     	//设置像素，这里使用最高 240（POR）像素,30个（hsync）延迟
000066  f64e711c          MOV      r1,#0xef1c
00006a  2016              MOVS     r0,#0x16
00006c  f7fffffe          BL       LCD_WR_CMD
;;;221    	LCD_WR_CMD(0x0017,0x0003);     	//开始时 1个（hsync）延迟，结束时4个延迟
000070  2103              MOVS     r1,#3
000072  2017              MOVS     r0,#0x17
000074  f7fffffe          BL       LCD_WR_CMD
;;;222    	LCD_WR_CMD(0x0007,0x0233);      //0x0233  //控制是否启动LCD     
000078  f2402133          MOV      r1,#0x233
00007c  2007              MOVS     r0,#7
00007e  f7fffffe          BL       LCD_WR_CMD
;;;223    	LCD_WR_CMD(0x000B,0x0000);     	//画面、周期控制
000082  2100              MOVS     r1,#0
000084  200b              MOVS     r0,#0xb
000086  f7fffffe          BL       LCD_WR_CMD
;;;224    	LCD_WR_CMD(0x000F,0x0000);      //扫描开始地址，从G0开始，即原点
00008a  2100              MOVS     r1,#0
00008c  200f              MOVS     r0,#0xf
00008e  f7fffffe          BL       LCD_WR_CMD
;;;225    	/***********************************************************************/
;;;226    	/**********这两个寄存器好像是设置显示效果的，如切换效果*****************/
;;;227    	/**********这里不使用效果，所以全为0，以后可以试试**********************/
;;;228    	LCD_WR_CMD(0x0041,0x0000);     
000092  2100              MOVS     r1,#0
000094  2041              MOVS     r0,#0x41
000096  f7fffffe          BL       LCD_WR_CMD
;;;229    	LCD_WR_CMD(0x0042,0x0000);    
00009a  2100              MOVS     r1,#0
00009c  2042              MOVS     r0,#0x42
00009e  f7fffffe          BL       LCD_WR_CMD
;;;230    	/***********************************************************************/    
;;;231    	LCD_WR_CMD(0x0048,0x0000); 	//指定开始时的扫描位置，这里默认    
0000a2  2100              MOVS     r1,#0
0000a4  2048              MOVS     r0,#0x48
0000a6  f7fffffe          BL       LCD_WR_CMD
;;;232    	LCD_WR_CMD(0x0049,0x013F);  //指定结束时的扫描位置，这里默认   
0000aa  f240133f          MOV      r3,#0x13f
0000ae  4619              MOV      r1,r3
0000b0  2049              MOVS     r0,#0x49
0000b2  f7fffffe          BL       LCD_WR_CMD
;;;233    	LCD_WR_CMD(0x004A,0x0000);  //指定二次开始时的扫描位置，这里默认   
0000b6  2100              MOVS     r1,#0
0000b8  204a              MOVS     r0,#0x4a
0000ba  f7fffffe          BL       LCD_WR_CMD
;;;234    	LCD_WR_CMD(0x004B,0x0000);	//指定二次结束时的扫描位置，这里默认  
0000be  2100              MOVS     r1,#0
0000c0  204b              MOVS     r0,#0x4b
0000c2  f7fffffe          BL       LCD_WR_CMD
;;;235    	        
;;;236    	LCD_WR_CMD(0x0044,0xEF00);	//指定水平扫描时的地址范围，这里默认   
0000c6  f44f416f          MOV      r1,#0xef00
0000ca  2044              MOVS     r0,#0x44
0000cc  f7fffffe          BL       LCD_WR_CMD
;;;237    	LCD_WR_CMD(0x0045,0x0000);  //指定垂直扫描时的地址范围，这里默认   
0000d0  2100              MOVS     r1,#0
0000d2  2045              MOVS     r0,#0x45
0000d4  f7fffffe          BL       LCD_WR_CMD
;;;238    	LCD_WR_CMD(0x0046,0x013F);	//指定垂直扫描时的地址范围，这里默认
0000d8  4619              MOV      r1,r3
0000da  2046              MOVS     r0,#0x46
0000dc  f7fffffe          BL       LCD_WR_CMD
;;;239    	/*******************************************************************        
;;;240    	*************这些寄存器在数据手册里说是调整电压输出*****************
;;;241    	*************好像是调整其灰度值的。这里使用默认值******************/
;;;242    	LCD_WR_CMD(0x0030,0x0707);  
0000e0  f2407107          MOV      r1,#0x707
0000e4  2030              MOVS     r0,#0x30
0000e6  f7fffffe          BL       LCD_WR_CMD
;;;243    	LCD_WR_CMD(0x0031,0x0204);  
0000ea  f44f7301          MOV      r3,#0x204
0000ee  4619              MOV      r1,r3
0000f0  2031              MOVS     r0,#0x31
0000f2  f7fffffe          BL       LCD_WR_CMD
;;;244    	LCD_WR_CMD(0x0032,0x0204);	     
0000f6  4619              MOV      r1,r3
0000f8  2032              MOVS     r0,#0x32
0000fa  f7fffffe          BL       LCD_WR_CMD
;;;245    	LCD_WR_CMD(0x0033,0x0502);     
0000fe  f2405402          MOV      r4,#0x502
000102  4621              MOV      r1,r4
000104  2033              MOVS     r0,#0x33
000106  f7fffffe          BL       LCD_WR_CMD
;;;246    	LCD_WR_CMD(0x0034,0x0507);     
00010a  1d61              ADDS     r1,r4,#5
00010c  2034              MOVS     r0,#0x34
00010e  f7fffffe          BL       LCD_WR_CMD
;;;247    	LCD_WR_CMD(0x0035,0x0204);     
000112  4619              MOV      r1,r3
000114  2035              MOVS     r0,#0x35
000116  f7fffffe          BL       LCD_WR_CMD
;;;248    	LCD_WR_CMD(0x0036,0x0204);     
00011a  4619              MOV      r1,r3
00011c  2036              MOVS     r0,#0x36
00011e  f7fffffe          BL       LCD_WR_CMD
;;;249    	LCD_WR_CMD(0x0037,0x0502);     
000122  4621              MOV      r1,r4
000124  2037              MOVS     r0,#0x37
000126  f7fffffe          BL       LCD_WR_CMD
;;;250    	LCD_WR_CMD(0x003A,0x0302);     
00012a  f2403302          MOV      r3,#0x302
00012e  4619              MOV      r1,r3
000130  203a              MOVS     r0,#0x3a
000132  f7fffffe          BL       LCD_WR_CMD
;;;251    	LCD_WR_CMD(0x003B,0x0302);
000136  4619              MOV      r1,r3
000138  203b              MOVS     r0,#0x3b
00013a  f7fffffe          BL       LCD_WR_CMD
;;;252    	/*****************************************************************/        
;;;253    	LCD_WR_CMD(0x0023,0x0000);     //所有数据都可以写入GDDRAM
00013e  2100              MOVS     r1,#0
000140  2023              MOVS     r0,#0x23
000142  f7fffffe          BL       LCD_WR_CMD
;;;254    	LCD_WR_CMD(0x0024,0x0000);     //所有数据都可以写入GDDRAM  
000146  2100              MOVS     r1,#0
000148  2024              MOVS     r0,#0x24
00014a  f7fffffe          BL       LCD_WR_CMD
00014e  f04f41d8          MOV      r1,#0x6c000000
;;;255    
;;;256    	//LCD_WR_CMD(0x0025,0x8000);	   	//好像数据手册里没有提到这个寄存器
;;;257    	
;;;258    	//GRAM写入数据，白色清屏*/							   
;;;259    	LCD_WR_ADD(0x0022);			   //准备写数据
000152  2022              MOVS     r0,#0x22
000154  8008              STRH     r0,[r1,#0]
;;;260    	for(n=0;n<320*240;n++)
000156  2000              MOVS     r0,#0
;;;261    	{
;;;262    		LCD_WR_DATA(White);
000158  f64f72ff          MOV      r2,#0xffff
00015c  f44f3396          MOV      r3,#0x12c00           ;260
                  |L11.352|
000160  804a              STRH     r2,[r1,#2]            ;260
000162  1c40              ADDS     r0,r0,#1              ;260
000164  4298              CMP      r0,r3                 ;260
000166  d3fb              BCC      |L11.352|
;;;263    	}
;;;264    }	
000168  bd10              POP      {r4,pc}
;;;265    
                          ENDP


                          AREA ||i.LCD_PutChar||, CODE, READONLY, ALIGN=1

                  LCD_PutChar PROC
;;;452    *************************************************************/
;;;453    void LCD_PutChar(u16 x, u16 y, char c, u16 fColor, u16 bColor) 
000000  b518              PUSH     {r3,r4,lr}
;;;454    {
;;;455    	LCD_PutChar8x16( x, y, c, fColor, bColor );
000002  9c03              LDR      r4,[sp,#0xc]
000004  9400              STR      r4,[sp,#0]
000006  f7fffffe          BL       LCD_PutChar8x16
;;;456    }
00000a  bd18              POP      {r3,r4,pc}
;;;457    
                          ENDP


                          AREA ||i.LCD_PutChar8x16||, CODE, READONLY, ALIGN=2

                  LCD_PutChar8x16 PROC
;;;468    *************************************************************/
;;;469    void LCD_PutChar8x16(u16 x, u16 y, char c, u16 fColor, u16 bColor)
000000  b5f0              PUSH     {r4-r7,lr}
;;;470    {
000002  461c              MOV      r4,r3
;;;471    	unsigned int i,j;
;;;472    	char_or_word=0;		//设置为显示为字符，1则为显示汉字	
000004  4b0f              LDR      r3,|L13.68|
000006  4616              MOV      r6,r2                 ;470
000008  2200              MOVS     r2,#0
00000a  9d05              LDR      r5,[sp,#0x14]
00000c  705a              STRB     r2,[r3,#1]
;;;473    	LCD_SetPos(x,y);
00000e  f7fffffe          BL       LCD_SetPos
;;;474     	
;;;475    	for(i=0; i<16;i++) 
;;;476    	{
;;;477    		unsigned char m=Font8x16[c*16+i];		  //直接找到字符
000012  f8dfc034          LDR      r12,|L13.72|
000016  2200              MOVS     r2,#0                 ;475
000018  f04f47d8          MOV      r7,#0x6c000000        ;475
                  |L13.28|
00001c  eb021006          ADD      r0,r2,r6,LSL #4
000020  f81c1000          LDRB     r1,[r12,r0]
;;;478    		for(j=0;j<8;j++) 
000024  f04f0000          MOV      r0,#0
                  |L13.40|
;;;479    		{
;;;480    			if((m&0x80)==0x80)
000028  060b              LSLS     r3,r1,#24
00002a  d501              BPL      |L13.48|
00002c  807c              STRH     r4,[r7,#2]
;;;481    				LCD_WR_DATA(fColor);
00002e  e000              B        |L13.50|
                  |L13.48|
000030  807d              STRH     r5,[r7,#2]
                  |L13.50|
;;;482    			else
;;;483    				LCD_WR_DATA(bColor);
;;;484    			m<<=1;
000032  0649              LSLS     r1,r1,#25
000034  0e09              LSRS     r1,r1,#24
000036  1c40              ADDS     r0,r0,#1              ;478
000038  2808              CMP      r0,#8                 ;478
00003a  d3f5              BCC      |L13.40|
00003c  1c52              ADDS     r2,r2,#1              ;475
00003e  2a10              CMP      r2,#0x10              ;475
000040  d3ec              BCC      |L13.28|
;;;485    		}
;;;486    	}
;;;487    }
000042  bdf0              POP      {r4-r7,pc}
;;;488    /*************************************************************
                          ENDP

                  |L13.68|
                          DCD      ||.data||
                  |L13.72|
                          DCD      ||.constdata||

                          AREA ||i.LCD_PutGB1616||, CODE, READONLY, ALIGN=2

                  LCD_PutGB1616 PROC
;;;377    *************************************************************/
;;;378    void LCD_PutGB1616(u16 x, u16  y, u8 c[2], u16 fColor,u16 bColor)
000000  b5f0              PUSH     {r4-r7,lr}
;;;379    {
000002  461c              MOV      r4,r3
;;;380    	unsigned int i,j,k;
;;;381    	char_or_word=1;		//设置为显示汉字，为0则为显示字符
000004  4b18              LDR      r3,|L14.104|
000006  4615              MOV      r5,r2                 ;379
000008  2201              MOVS     r2,#1
00000a  9e05              LDR      r6,[sp,#0x14]
00000c  705a              STRB     r2,[r3,#1]
;;;382    	LCD_SetPos(x,y);
00000e  f7fffffe          BL       LCD_SetPos
;;;383    
;;;384    	for(k=0;k<67;k++) 
;;;385    	{ //64标示自建汉字库中的个数，循环查询内码
;;;386    	    if ((codeGB_16[k].Index[0]==c[0])&&(codeGB_16[k].Index[1]==c[1]))	 //找到对应的汉字
000012  782f              LDRB     r7,[r5,#0]
000014  f8dfc054          LDR      r12,|L14.108|
000018  2000              MOVS     r0,#0                 ;384
                  |L14.26|
00001a  eb001100          ADD      r1,r0,r0,LSL #4
00001e  f81c2011          LDRB     r2,[r12,r1,LSL #1]
000022  42ba              CMP      r2,r7
000024  d11b              BNE      |L14.94|
000026  eb0c0141          ADD      r1,r12,r1,LSL #1
00002a  786b              LDRB     r3,[r5,#1]
00002c  784a              LDRB     r2,[r1,#1]
00002e  429a              CMP      r2,r3
000030  d115              BNE      |L14.94|
;;;387    	    {
;;;388                for(i=0;i<32;i++) 
000032  2300              MOVS     r3,#0
000034  f04f47d8          MOV      r7,#0x6c000000
                  |L14.56|
;;;389        		{											
;;;390        		 	unsigned short m=codeGB_16[k].Msk[i];
000038  eb010003          ADD      r0,r1,r3
00003c  7882              LDRB     r2,[r0,#2]
;;;391        		  	for(j=0;j<8;j++) 
00003e  f04f0000          MOV      r0,#0
                  |L14.66|
;;;392        		  	{
;;;393        				if((m&0x80)==0x80) 
000042  0615              LSLS     r5,r2,#24
000044  d501              BPL      |L14.74|
000046  807c              STRH     r4,[r7,#2]
;;;394        					LCD_WR_DATA(fColor);		 //开始写入汉字颜色
000048  e000              B        |L14.76|
                  |L14.74|
00004a  807e              STRH     r6,[r7,#2]
                  |L14.76|
;;;395        				else 
;;;396        					LCD_WR_DATA(bColor);		 //开始写入背景颜色
;;;397        				m<<=1;
00004c  0452              LSLS     r2,r2,#17
00004e  0c12              LSRS     r2,r2,#16
000050  1c40              ADDS     r0,r0,#1              ;391
000052  2808              CMP      r0,#8                 ;391
000054  d3f5              BCC      |L14.66|
000056  1c5b              ADDS     r3,r3,#1              ;388
000058  2b20              CMP      r3,#0x20              ;388
00005a  d3ed              BCC      |L14.56|
;;;398        			} 
;;;399        		}
;;;400                break;
;;;401    	    }
;;;402    	}	
;;;403    }
00005c  bdf0              POP      {r4-r7,pc}
                  |L14.94|
00005e  1c40              ADDS     r0,r0,#1              ;384
000060  2843              CMP      r0,#0x43              ;384
000062  d3da              BCC      |L14.26|
000064  bdf0              POP      {r4-r7,pc}
;;;404    /*************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L14.104|
                          DCD      ||.data||
                  |L14.108|
                          DCD      ||.constdata||+0x800

                          AREA ||i.LCD_PutString||, CODE, READONLY, ALIGN=1

                  LCD_PutString PROC
;;;414    *************************************************************/
;;;415    void LCD_PutString(u16 x, u16 y, u8 *s, u16 fColor, u16 bColor) 
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;416    {
000004  4615              MOV      r5,r2
000006  4699              MOV      r9,r3
;;;417    	unsigned char l=0;
000008  2400              MOVS     r4,#0
;;;418        uint16 b = 0;
;;;419    
;;;420        //if (!horizontal_or_vertical)
;;;421        {
;;;422            b = x;
;;;423            x = y;
00000a  460e              MOV      r6,r1
;;;424            y = b;
00000c  4680              MOV      r8,r0
;;;425        }
;;;426    	while(*s) 
00000e  9f08              LDR      r7,[sp,#0x20]
000010  e013              B        |L15.58|
                  |L15.18|
;;;427    	{
;;;428    		if( *s < 0x80) 								 //判断是否为字符
;;;429    		{
;;;430    			LCD_PutChar(x+l*8,y,*s,fColor,bColor);
;;;431    			s++;
;;;432    			l++;
;;;433    		}
;;;434    		else
;;;435    		{
;;;436    			LCD_PutGB1616(x+l*8,y,(u8 *)s,fColor,bColor);
000012  eb0600c4          ADD      r0,r6,r4,LSL #3
000016  2a80              CMP      r2,#0x80              ;428
000018  b280              UXTH     r0,r0
00001a  464b              MOV      r3,r9
00001c  9700              STR      r7,[sp,#0]            ;428
00001e  d205              BCS      |L15.44|
000020  4641              MOV      r1,r8                 ;430
000022  f7fffffe          BL       LCD_PutChar
000026  1c6d              ADDS     r5,r5,#1              ;431
000028  1c64              ADDS     r4,r4,#1              ;432
00002a  e005              B        |L15.56|
                  |L15.44|
00002c  462a              MOV      r2,r5
00002e  4641              MOV      r1,r8
000030  f7fffffe          BL       LCD_PutGB1616
;;;437    			s+=2;
000034  1cad              ADDS     r5,r5,#2
;;;438    			l+=2;
000036  1ca4              ADDS     r4,r4,#2
                  |L15.56|
000038  b2e4              UXTB     r4,r4                 ;432
                  |L15.58|
00003a  782a              LDRB     r2,[r5,#0]            ;426
00003c  2a00              CMP      r2,#0                 ;426
00003e  d1e8              BNE      |L15.18|
;;;439    		}
;;;440    	}
;;;441    }
000040  e8bd83f8          POP      {r3-r9,pc}
;;;442    /*************************************************************
                          ENDP


                          AREA ||i.LCD_RD_data||, CODE, READONLY, ALIGN=1

                  LCD_RD_data PROC
;;;32      */
;;;33     u16 LCD_RD_data(void)
000000  f04f40d8          MOV      r0,#0x6c000000
;;;34     {
;;;35         u16 a = 0;
;;;36         a = (*(__IO u16 *) (Bank1_LCD_Data)); 	//Dummy	
000004  8841              LDRH     r1,[r0,#2]
;;;37         a = *(__IO u16 *) (Bank1_LCD_Data);     //L
000006  8840              LDRH     r0,[r0,#2]
;;;38         
;;;39         return(a);	
;;;40     }
000008  4770              BX       lr
;;;41     
                          ENDP


                          AREA ||i.LCD_SetPos||, CODE, READONLY, ALIGN=2

                  LCD_SetPos PROC
;;;327    *************************************************************/
;;;328    void LCD_SetPos(u16 x0,u16 y0)
000000  b530              PUSH     {r4,r5,lr}
;;;329    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;330    		u16 xx;
;;;331    		switch (horizontal_or_vertical)
000006  4823              LDR      r0,|L17.148|
000008  4922              LDR      r1,|L17.148|
00000a  7880              LDRB     r0,[r0,#2]  ; horizontal_or_vertical
;;;332    		{									 //水平显示的时候
;;;333    		 	case 0:
;;;334    				{					
;;;335    					if (char_or_word)	
00000c  7849              LDRB     r1,[r1,#1]
00000e  b110              CBZ      r0,|L17.22|
000010  2801              CMP      r0,#1                 ;331
000012  d13a              BNE      |L17.138|
000014  e01c              B        |L17.80|
                  |L17.22|
;;;336    		  				xx=(x0+15)<<8;	//若显示汉字
000016  0218              LSLS     r0,r3,#8
000018  b111              CBZ      r1,|L17.32|
00001a  f5006070          ADD      r0,r0,#0xf00
00001e  e001              B        |L17.36|
                  |L17.32|
;;;337    					else
;;;338    						xx=(x0+7)<<8;	//若显示字符
000020  f50060e0          ADD      r0,r0,#0x700
                  |L17.36|
000024  b280              UXTH     r0,r0
;;;339    					xx=xx+x0;				
000026  4418              ADD      r0,r0,r3
000028  b281              UXTH     r1,r0
;;;340    					LCD_WR_CMD(0x0044,xx); 
00002a  2044              MOVS     r0,#0x44
00002c  f7fffffe          BL       LCD_WR_CMD
;;;341    					LCD_WR_CMD(0x004e,x0);        //设置X方向初始值
000030  4619              MOV      r1,r3
000032  204e              MOVS     r0,#0x4e
000034  f7fffffe          BL       LCD_WR_CMD
;;;342    		
;;;343    					/*R45、R46   垂直方向的起、止点*/
;;;344    					LCD_WR_CMD(0x0045,y0);	  
000038  4621              MOV      r1,r4
00003a  2045              MOVS     r0,#0x45
00003c  f7fffffe          BL       LCD_WR_CMD
;;;345    					LCD_WR_CMD(0x0046,y0+15);
000040  f104000f          ADD      r0,r4,#0xf
000044  b281              UXTH     r1,r0
000046  2046              MOVS     r0,#0x46
000048  f7fffffe          BL       LCD_WR_CMD
;;;346    	   				LCD_WR_CMD(0x004f,y0);        //设置y方向初始值		
00004c  4621              MOV      r1,r4
;;;347    				}break;
00004e  e019              B        |L17.132|
                  |L17.80|
;;;348    			case 1:
;;;349    				{					
;;;350    					if (char_or_word)	
000050  b111              CBZ      r1,|L17.88|
;;;351    		  				xx=x0+15;	//显示汉字
000052  f103000f          ADD      r0,r3,#0xf
000056  e000              B        |L17.90|
                  |L17.88|
;;;352    					else
;;;353    						xx=x0+7;	//若显示字符
000058  1dd8              ADDS     r0,r3,#7
                  |L17.90|
00005a  b285              UXTH     r5,r0
;;;354    					
;;;355    					/*垂直方向，高位为终止位*/				
;;;356    					LCD_WR_CMD(0x0044,(y0+15)<<8); 
00005c  0220              LSLS     r0,r4,#8
00005e  f5006070          ADD      r0,r0,#0xf00
000062  b281              UXTH     r1,r0
000064  2044              MOVS     r0,#0x44
000066  f7fffffe          BL       LCD_WR_CMD
;;;357    					LCD_WR_CMD(0x004e,y0);        //设置X方向初始值
00006a  4621              MOV      r1,r4
00006c  204e              MOVS     r0,#0x4e
00006e  f7fffffe          BL       LCD_WR_CMD
;;;358    		
;;;359    					/*R45、R46   水平方向的起、止点*/
;;;360    					LCD_WR_CMD(0x0045,x0);	  
000072  4619              MOV      r1,r3
000074  2045              MOVS     r0,#0x45
000076  f7fffffe          BL       LCD_WR_CMD
;;;361    					LCD_WR_CMD(0x0046,xx);
00007a  4629              MOV      r1,r5
00007c  2046              MOVS     r0,#0x46
00007e  f7fffffe          BL       LCD_WR_CMD
;;;362    	   				LCD_WR_CMD(0x004f,x0);        //设置y方向初始值
000082  4619              MOV      r1,r3
                  |L17.132|
000084  204f              MOVS     r0,#0x4f              ;346
000086  f7fffffe          BL       LCD_WR_CMD
                  |L17.138|
00008a  f04f41d8          MOV      r1,#0x6c000000        ;346
;;;363    				}break;
;;;364    		}	
;;;365    		LCD_WR_ADD(0x0022);			  //准备写数据
00008e  2022              MOVS     r0,#0x22
000090  8008              STRH     r0,[r1,#0]
;;;366    }
000092  bd30              POP      {r4,r5,pc}
;;;367    /*************************************************************
                          ENDP

                  |L17.148|
                          DCD      ||.data||

                          AREA ||i.LCD_SetPosition||, CODE, READONLY, ALIGN=2

                  LCD_SetPosition PROC
;;;290    *************************************************************/
;;;291    void LCD_SetPosition(u16 x0,u16 y0)
000000  b530              PUSH     {r4,r5,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293    	switch (horizontal_or_vertical)
000004  481b              LDR      r0,|L18.116|
000006  460b              MOV      r3,r1                 ;292
;;;294    	{									 
;;;295    	 	case 0:							 //水平显示的时候
;;;296    		{									
;;;297    			LCD_WR_CMD(0x0044,0xef00+x0); 
;;;298    			LCD_WR_CMD(0x004e,x0);        //设置X方向初始值
;;;299    
;;;300    			/*R45、R46   垂直方向的起、止点*/
;;;301    			LCD_WR_CMD(0x0045,y0);	  
;;;302    			LCD_WR_CMD(0x0046,0x13f);
000008  f240153f          MOV      r5,#0x13f
00000c  7881              LDRB     r1,[r0,#2]            ;293  ; horizontal_or_vertical
00000e  b111              CBZ      r1,|L18.22|
000010  2901              CMP      r1,#1                 ;293
000012  d12a              BNE      |L18.106|
000014  e013              B        |L18.62|
                  |L18.22|
000016  f504406f          ADD      r0,r4,#0xef00         ;297
00001a  b281              UXTH     r1,r0                 ;297
00001c  2044              MOVS     r0,#0x44              ;297
00001e  f7fffffe          BL       LCD_WR_CMD
000022  4621              MOV      r1,r4                 ;298
000024  204e              MOVS     r0,#0x4e              ;298
000026  f7fffffe          BL       LCD_WR_CMD
00002a  4619              MOV      r1,r3                 ;301
00002c  2045              MOVS     r0,#0x45              ;301
00002e  f7fffffe          BL       LCD_WR_CMD
000032  4629              MOV      r1,r5
000034  2046              MOVS     r0,#0x46
000036  f7fffffe          BL       LCD_WR_CMD
;;;303    			LCD_WR_CMD(0x004f,y0);        //设置y方向初始值		
00003a  4619              MOV      r1,r3
;;;304    		}break;
00003c  e012              B        |L18.100|
                  |L18.62|
;;;305    		case 1:							 //横屏显示的时候
;;;306    		{				
;;;307    			/*垂直方向，高位为终止位*/				
;;;308    			LCD_WR_CMD(0x0044,0xef+y0); 
00003e  f10300ef          ADD      r0,r3,#0xef
000042  b281              UXTH     r1,r0
000044  2044              MOVS     r0,#0x44
000046  f7fffffe          BL       LCD_WR_CMD
;;;309    			LCD_WR_CMD(0x004e,y0);        //设置X方向初始值
00004a  4619              MOV      r1,r3
00004c  204e              MOVS     r0,#0x4e
00004e  f7fffffe          BL       LCD_WR_CMD
;;;310    
;;;311    			/*R45、R46   水平方向的起、止点*/
;;;312    			LCD_WR_CMD(0x0045,x0);	  
000052  4621              MOV      r1,r4
000054  2045              MOVS     r0,#0x45
000056  f7fffffe          BL       LCD_WR_CMD
;;;313    			LCD_WR_CMD(0x0046,0x13f);
00005a  4629              MOV      r1,r5
00005c  2046              MOVS     r0,#0x46
00005e  f7fffffe          BL       LCD_WR_CMD
;;;314    			LCD_WR_CMD(0x004f,x0);        //设置y方向初始值
000062  4621              MOV      r1,r4
                  |L18.100|
000064  204f              MOVS     r0,#0x4f              ;303
000066  f7fffffe          BL       LCD_WR_CMD
                  |L18.106|
00006a  f04f41d8          MOV      r1,#0x6c000000        ;303
;;;315    		}break;
;;;316    	}	
;;;317    	LCD_WR_ADD(0x0022);			  //准备写数据	
00006e  2022              MOVS     r0,#0x22
000070  8008              STRH     r0,[r1,#0]
;;;318    }
000072  bd30              POP      {r4,r5,pc}
;;;319    
                          ENDP

                  |L18.116|
                          DCD      ||.data||

                          AREA ||i.LCD_Set_Ver||, CODE, READONLY, ALIGN=2

                  LCD_Set_Ver PROC
;;;158    ********************************************************/
;;;159    void LCD_Set_Ver(unsigned char ver)
000000  b500              PUSH     {lr}
;;;160    {
;;;161    	switch (ver)
;;;162    	{
;;;163    		case 0:	
;;;164    			{
;;;165    				horizontal_or_vertical=0; //水平显示
000002  490e              LDR      r1,|L19.60|
000004  2200              MOVS     r2,#0                 ;160
000006  b118              CBZ      r0,|L19.16|
000008  2801              CMP      r0,#1                 ;161
00000a  d00a              BEQ      |L19.34|
;;;166    				/*********************************************************************
;;;167    				*当R01为0x6b3f时RGB从S719到S0，为2b3f时从s0到s719...并且选择BGR模式***
;;;168    				*********************************************************************/
;;;169    				LCD_WR_CMD(0x0001,0x2b3f);     //驱动输出控制320*240  0x6B3F和0x2b3f可选
;;;170    				//LCD_WR_CMD(0x0001,0x6b3f);
;;;171    			
;;;172    				/************************************************************************
;;;173    				 *		  这里设置颜色的格式是16色还是262色，0x6000代表显示16色，
;;;174    				 *		  0x4000代表显示262色，
;;;175    				 *		  0x0030代表平行扫描，0x0038代表垂直扫描，详见SSD1289
;;;176    				 *		  数据手册 寄存器R11 的说明。   
;;;177    				************************************************************************/
;;;178    				LCD_WR_CMD(0x0011,0x6030);   	//  16位色 竖屏 从左到右扫描
;;;179    				//LCD_WR_CMD(0x0011,0x6038);	//16色 横屏显示		从左到右扫描
;;;180    				/************************************************************************/
;;;181    			}break;
;;;182    		case 1:
;;;183    			{
;;;184    				horizontal_or_vertical=1; //垂直显示
;;;185    				LCD_WR_CMD(0x0001,0x6b3f);
;;;186    				LCD_WR_CMD(0x0011,0x6038);
;;;187    
;;;188    			}break;
;;;189    		default:horizontal_or_vertical=0; break; //水平显示
00000c  708a              STRB     r2,[r1,#2]
;;;190    	}
;;;191    }
00000e  bd00              POP      {pc}
                  |L19.16|
000010  708a              STRB     r2,[r1,#2]            ;165
000012  f642313f          MOV      r1,#0x2b3f            ;169
000016  2001              MOVS     r0,#1                 ;169
000018  f7fffffe          BL       LCD_WR_CMD
00001c  f2460130          MOV      r1,#0x6030            ;178
000020  e007              B        |L19.50|
                  |L19.34|
000022  2001              MOVS     r0,#1                 ;184
000024  7088              STRB     r0,[r1,#2]            ;184
000026  f646313f          MOV      r1,#0x6b3f            ;185
00002a  f7fffffe          BL       LCD_WR_CMD
00002e  f2460138          MOV      r1,#0x6038            ;186
                  |L19.50|
000032  2011              MOVS     r0,#0x11              ;186
000034  f85deb04          POP      {lr}                  ;186
000038  f7ffbffe          B.W      LCD_WR_CMD
;;;192    
                          ENDP

                  |L19.60|
                          DCD      ||.data||

                          AREA ||i.LCD_TEST_Picture1||, CODE, READONLY, ALIGN=2

                  LCD_TEST_Picture1 PROC
;;;498    *************************************************************/
;;;499    void LCD_TEST_Picture1(unsigned char const *picture1)
000000  4603              MOV      r3,r0
;;;500    {
000002  b530              PUSH     {r4,r5,lr}
;;;501         unsigned	char i,j;
;;;502    	 u16 picdata,pixH,pixL;
;;;503         if	(horizontal_or_vertical)
000004  4819              LDR      r0,|L20.108|
;;;504    	 {
;;;505    	 	LCD_WR_CMD(0x0044,0xef00);        	//hs		  横屏时
000006  f44f416f          MOV      r1,#0xef00
00000a  7880              LDRB     r0,[r0,#2]            ;503  ; horizontal_or_vertical
00000c  2800              CMP      r0,#0                 ;503
;;;506    	 	LCD_WR_CMD(0x0046,0x00ef);        	//vs
;;;507    	 }
;;;508    	 else
;;;509    	 {
;;;510    	 	LCD_WR_CMD(0x0044,0xef00);        	//hs  竖屏时
00000e  f04f0044          MOV      r0,#0x44
000012  d003              BEQ      |L20.28|
000014  f7fffffe          BL       LCD_WR_CMD
000018  21ef              MOVS     r1,#0xef              ;506
00001a  e003              B        |L20.36|
                  |L20.28|
00001c  f7fffffe          BL       LCD_WR_CMD
;;;511    		LCD_WR_CMD(0x0046,0x013f);       	
000020  f240113f          MOV      r1,#0x13f
                  |L20.36|
000024  2046              MOVS     r0,#0x46
000026  f7fffffe          BL       LCD_WR_CMD
;;;512    	 } 									 	
;;;513         
;;;514    	 LCD_WR_CMD(0x004e,0x0000);        		//h	 	 
00002a  2100              MOVS     r1,#0
00002c  204e              MOVS     r0,#0x4e
00002e  f7fffffe          BL       LCD_WR_CMD
;;;515    	 LCD_WR_CMD(0x045,0x0000);        		//he 
000032  2100              MOVS     r1,#0
000034  2045              MOVS     r0,#0x45
000036  f7fffffe          BL       LCD_WR_CMD
;;;516    	 LCD_WR_CMD(0x004f,0x0000);        		//v     
00003a  2100              MOVS     r1,#0
00003c  204f              MOVS     r0,#0x4f
00003e  f7fffffe          BL       LCD_WR_CMD
000042  f04f44d8          MOV      r4,#0x6c000000
;;;517         LCD_WR_ADD(0x0022);
000046  2022              MOVS     r0,#0x22
000048  8020              STRH     r0,[r4,#0]
;;;518         for (i=0;i<240;i++)
00004a  2000              MOVS     r0,#0
                  |L20.76|
;;;519    		for (j=0;j<180;j++)
00004c  2100              MOVS     r1,#0
                  |L20.78|
;;;520    		{
;;;521    			pixH=*picture1++;
00004e  781a              LDRB     r2,[r3,#0]
;;;522    			pixL=*picture1++;
000050  785d              LDRB     r5,[r3,#1]
000052  1c9b              ADDS     r3,r3,#2
;;;523    			picdata=((pixH<<8)+pixL);
000054  eb052202          ADD      r2,r5,r2,LSL #8
000058  8062              STRH     r2,[r4,#2]
00005a  1c49              ADDS     r1,r1,#1              ;519
00005c  b2c9              UXTB     r1,r1                 ;519
00005e  29b4              CMP      r1,#0xb4              ;519
000060  d3f5              BCC      |L20.78|
000062  1c40              ADDS     r0,r0,#1              ;518
000064  b2c0              UXTB     r0,r0                 ;518
000066  28f0              CMP      r0,#0xf0              ;518
000068  d3f0              BCC      |L20.76|
;;;524    			LCD_WR_DATA(picdata);                              
;;;525    		}
;;;526    }
00006a  bd30              POP      {r4,r5,pc}
;;;527    
                          ENDP

                  |L20.108|
                          DCD      ||.data||

                          AREA ||i.LCD_WR_ADD||, CODE, READONLY, ALIGN=1

                  LCD_WR_ADD PROC
;;;17     //LCD写寄存器地址函数	 
;;;18     void LCD_WR_ADD(u16 index) 
000000  f04f41d8          MOV      r1,#0x6c000000
;;;19     {																
;;;20     	*(vu16 *)(Bank1_LCD_Reg) = index; 		
000004  8008              STRH     r0,[r1,#0]
;;;21     }
000006  4770              BX       lr
;;;22     //LCD写数据函数							
                          ENDP


                          AREA ||i.LCD_WR_CMD||, CODE, READONLY, ALIGN=1

                  LCD_WR_CMD PROC
;;;146    ********************************************************/
;;;147    void LCD_WR_CMD(u16 index, u16 val)
000000  f04f42d8          MOV      r2,#0x6c000000
;;;148    {
;;;149    	*(vu16 *)(Bank1_LCD_Reg) = index; 
000004  8010              STRH     r0,[r2,#0]
;;;150           *(vu16 *)(Bank1_LCD_Data) = val;	
000006  8051              STRH     r1,[r2,#2]
;;;151    }
000008  4770              BX       lr
;;;152    
                          ENDP


                          AREA ||i.LCD_WR_DATA||, CODE, READONLY, ALIGN=1

                  LCD_WR_DATA PROC
;;;22     //LCD写数据函数							
;;;23     void LCD_WR_DATA(u16 val)		 
000000  f04f41d8          MOV      r1,#0x6c000000
;;;24     {															
;;;25     	*(vu16 *)(Bank1_LCD_Data) = val;
000004  8048              STRH     r0,[r1,#2]
;;;26     }	
000006  4770              BX       lr
;;;27     
                          ENDP


                          AREA ||i.LED_GPIO_Config||, CODE, READONLY, ALIGN=2

                  LED_GPIO_Config PROC
;;;24      */
;;;25     void LED_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;26     {
;;;27     	GPIO_InitTypeDef GPIO_InitStructure;
;;;28     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE);
000002  2101              MOVS     r1,#1
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;29     
;;;30       	GPIO_InitStructure.GPIO_Pin =GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;	
00000a  203c              MOVS     r0,#0x3c
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;31       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;32       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;33       	GPIO_Init(GPIOE, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L24.48|
000020  f7fffffe          BL       GPIO_Init
;;;34     
;;;35     	GPIO_SetBits(GPIOD,GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5);	 // turn off all led
000024  213c              MOVS     r1,#0x3c
000026  4803              LDR      r0,|L24.52|
000028  f7fffffe          BL       GPIO_SetBits
;;;36     }
00002c  bd08              POP      {r3,pc}
;;;37     
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
                          DCD      0x40011800
                  |L24.52|
                          DCD      0x40011400

                          AREA ||i.Lcd_Clear||, CODE, READONLY, ALIGN=1

                  Lcd_Clear PROC
;;;665     *******************************************************************************/
;;;666    void Lcd_Clear(void)
000000  2101              MOVS     r1,#1
;;;667    {
;;;668        uint16 n = 0;
;;;669        LCD_WR_CMD(0x0000,0x0001);      //打开晶振
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       LCD_WR_CMD
;;;670    	LCD_WR_CMD(0x0044,0xEF00);	//指定水平扫描时的地址范围，这里默认   
000008  f44f416f          MOV      r1,#0xef00
00000c  2044              MOVS     r0,#0x44
00000e  f7fffffe          BL       LCD_WR_CMD
;;;671    	LCD_WR_CMD(0x0045,0x0000);  //指定垂直扫描时的地址范围，这里默认   
000012  2100              MOVS     r1,#0
000014  2045              MOVS     r0,#0x45
000016  f7fffffe          BL       LCD_WR_CMD
;;;672    	LCD_WR_CMD(0x0046,0x013F);	//指定垂直扫描时的地址范围，这里默认
00001a  f240113f          MOV      r1,#0x13f
00001e  2046              MOVS     r0,#0x46
000020  f7fffffe          BL       LCD_WR_CMD
;;;673        LCD_WR_CMD(0x004e,0);        //设置X方向初始值
000024  2100              MOVS     r1,#0
000026  204e              MOVS     r0,#0x4e
000028  f7fffffe          BL       LCD_WR_CMD
;;;674        LCD_WR_CMD(0x004f,0);
00002c  2100              MOVS     r1,#0
00002e  204f              MOVS     r0,#0x4f
000030  f7fffffe          BL       LCD_WR_CMD
;;;675        LCD_WR_CMD(0x0023,0x0000);     //所有数据都可以写入GDDRAM
000034  2100              MOVS     r1,#0
000036  2023              MOVS     r0,#0x23
000038  f7fffffe          BL       LCD_WR_CMD
;;;676    	LCD_WR_CMD(0x0024,0x0000);     //所有数据都可以写入GDDRAM  
00003c  2100              MOVS     r1,#0
00003e  2024              MOVS     r0,#0x24
000040  f7fffffe          BL       LCD_WR_CMD
000044  f04f40d8          MOV      r0,#0x6c000000
;;;677    
;;;678        LCD_WR_ADD(0x0022);
000048  2122              MOVS     r1,#0x22
00004a  8001              STRH     r1,[r0,#0]
;;;679        for(n=0;n<320*240;n++)
;;;680    	{
;;;681    		LCD_WR_DATA(White);
00004c  f64f71ff          MOV      r1,#0xffff
                  |L25.80|
000050  8041              STRH     r1,[r0,#2]
000052  e7fd              B        |L25.80|
;;;682    	}
;;;683    
;;;684        return;
;;;685    }
;;;686    
                          ENDP


                          AREA ||i.Lcd_FMSC_Config||, CODE, READONLY, ALIGN=1

                  Lcd_FMSC_Config PROC
;;;95     ********************************************************/
;;;96     void Lcd_FMSC_Config(void)
000000  b500              PUSH     {lr}
;;;97     {
000002  b097              SUB      sp,sp,#0x5c
;;;98     	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;99       	FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;100    	/***********Color LCD configuration***************************************
;;;101         LCD configured as follow:
;;;102            - Data/Address MUX = Disable
;;;103            - Memory Type = SRAM
;;;104            - Data Width = 16bit
;;;105            - Write Operation = Enable
;;;106            - Extended Mode = Enable
;;;107            - Asynchronous Wait = Disable 
;;;108    	*************************************************************************/	
;;;109    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 1;
000004  2001              MOVS     r0,#1
;;;110    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;
000006  900f              STR      r0,[sp,#0x3c]
000008  2000              MOVS     r0,#0
;;;111    	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime =0X02;
00000a  2102              MOVS     r1,#2
00000c  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;112    	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0;
;;;113    	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0;
;;;114    	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0;
;;;115    	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_B;
000010  06c9              LSLS     r1,r1,#27
000012  e9cd0114          STRD     r0,r1,[sp,#0x50]
;;;116      	/*******FSMC Configuration********************************************/
;;;117      	/*******SRAM Bank 4***************************************************/
;;;118      	/*******FSMC_Bank1_NORSRAM4 configuration*****************************/
;;;119    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4; //BANK1 的 NE4
000016  2106              MOVS     r1,#6
000018  e9cd1000          STRD     r1,r0,[sp,#0]
;;;120    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; //关掉地址复用
;;;121    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_NOR;//FSMC_MemoryType_SRAM; //GRAM 当成MCU的SRAM处理
00001c  2108              MOVS     r1,#8
;;;122    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b; //16位总线
00001e  9102              STR      r1,[sp,#8]
000020  9012              STR      r0,[sp,#0x48]         ;113
000022  9013              STR      r0,[sp,#0x4c]         ;115
000024  2110              MOVS     r1,#0x10
000026  e9cd1003          STRD     r1,r0,[sp,#0xc]
;;;123    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable; //突发模式访问，不是PSRAM所以Disable
;;;124    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
;;;125    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00002a  9005              STR      r0,[sp,#0x14]
;;;126    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
00002c  9006              STR      r0,[sp,#0x18]
;;;127    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;128    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable; //写使能
00002e  0209              LSLS     r1,r1,#8
000030  9007              STR      r0,[sp,#0x1c]
000032  e9cd0108          STRD     r0,r1,[sp,#0x20]
;;;129    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;130    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000036  900a              STR      r0,[sp,#0x28]
;;;131    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000038  900b              STR      r0,[sp,#0x2c]
;;;132    	
;;;133    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
00003a  900c              STR      r0,[sp,#0x30]
00003c  a80f              ADD      r0,sp,#0x3c
;;;134    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
00003e  900d              STR      r0,[sp,#0x34]
;;;135    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
000040  900e              STR      r0,[sp,#0x38]
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       FSMC_NORSRAMInit
;;;136    
;;;137      	/* - BANK  (of NOR/SRAM Bank 0~3) is enabled */
;;;138      	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
000048  2101              MOVS     r1,#1
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       FSMC_NORSRAMCmd
;;;139    }
000050  b017              ADD      sp,sp,#0x5c
000052  bd00              POP      {pc}
;;;140    
                          ENDP


                          AREA ||i.Lcd_GPIO_Config||, CODE, READONLY, ALIGN=2

                  Lcd_GPIO_Config PROC
;;;47     ********************************************************/
;;;48     void Lcd_GPIO_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;49     {
;;;50     	GPIO_InitTypeDef GPIO_InitStructure;	
;;;51     		
;;;52     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);
000002  2101              MOVS     r1,#1
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);
000012  2101              MOVS     r1,#1
000014  2080              MOVS     r0,#0x80
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;55     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG,ENABLE);		
00001a  2101              MOVS     r1,#1
00001c  020c              LSLS     r4,r1,#8
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;56     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000024  2101              MOVS     r1,#1
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;57     	
;;;58     	
;;;59     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 | 
00002c  f24c7033          MOV      r0,#0xc733
000030  f8ad0000          STRH     r0,[sp,#0]
;;;60     								  GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |GPIO_Pin_15;
;;;61     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000034  2403              MOVS     r4,#3
000036  f88d4002          STRB     r4,[sp,#2]
;;;62     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00003a  2018              MOVS     r0,#0x18
00003c  f88d0003          STRB     r0,[sp,#3]
;;;63     	GPIO_Init(GPIOD, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  4816              LDR      r0,|L27.156|
000044  f7fffffe          BL       GPIO_Init
;;;64     	
;;;65     	/* 设置 PE.01(RESET) , PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;66     	     PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;67     	/* PE3,PE4 用于A19, A20, STM32F103ZE-EK(REV 2.0)必须使能 */
;;;68     	/* PE5,PE6 用于A19, A20, STM32F103ZE-EK(REV 2.0)必须使能 */
;;;69     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000048  f64f7080          MOV      r0,#0xff80
00004c  f8ad0000          STRH     r0,[sp,#0]
;;;70     	                      			GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;71     	                      			GPIO_Pin_15;
;;;72     	GPIO_Init(GPIOE, &GPIO_InitStructure);
000050  4669              MOV      r1,sp
000052  4813              LDR      r0,|L27.160|
000054  f7fffffe          BL       GPIO_Init
;;;73     	
;;;74     	  /* 设置 PF.00(A0 (RS))  为复用推挽输出 */
;;;75     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000058  2001              MOVS     r0,#1
00005a  f8ad0000          STRH     r0,[sp,#0]
;;;76     	GPIO_Init(GPIOF, &GPIO_InitStructure);
00005e  4669              MOV      r1,sp
000060  4810              LDR      r0,|L27.164|
000062  f7fffffe          BL       GPIO_Init
;;;77     	
;;;78     	  /* 设置 PG.12(NE4 (LCD/CS)) 为复用推挽输出 - CE3(LCD /CS) */
;;;79     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000066  f44f5080          MOV      r0,#0x1000
;;;80     	GPIO_Init(GPIOG, &GPIO_InitStructure);
00006a  4d0f              LDR      r5,|L27.168|
00006c  f8ad0000          STRH     r0,[sp,#0]            ;79
000070  4669              MOV      r1,sp
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       GPIO_Init
;;;81     	
;;;82     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000078  2102              MOVS     r1,#2
00007a  f8ad1000          STRH     r1,[sp,#0]
;;;83     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00007e  2010              MOVS     r0,#0x10
000080  f88d0003          STRB     r0,[sp,#3]
;;;84     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000084  f88d4002          STRB     r4,[sp,#2]
;;;85     	GPIO_Init(GPIOG, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       GPIO_Init
;;;86     	GPIO_SetBits(GPIOG, GPIO_Pin_1);
000090  2102              MOVS     r1,#2
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       GPIO_SetBits
;;;87     }
000098  bd38              POP      {r3-r5,pc}
;;;88     
                          ENDP

00009a  0000              DCW      0x0000
                  |L27.156|
                          DCD      0x40011400
                  |L27.160|
                          DCD      0x40011800
                  |L27.164|
                          DCD      0x40011c00
                  |L27.168|
                          DCD      0x40012000

                          AREA ||i.Lcd_Init||, CODE, READONLY, ALIGN=1

                  Lcd_Init PROC
;;;276     *******************************************************************************/
;;;277    void Lcd_Init(void)
000000  b510              PUSH     {r4,lr}
;;;278    {
;;;279        Lcd_GPIO_Config();
000002  f7fffffe          BL       Lcd_GPIO_Config
;;;280        Lcd_FMSC_Config();
000006  f7fffffe          BL       Lcd_FMSC_Config
;;;281        LCD_MyInit(0);
00000a  e8bd4010          POP      {r4,lr}
00000e  2000              MOVS     r0,#0
000010  f7ffbffe          B.W      LCD_MyInit
;;;282    }
;;;283    /*************************************************************
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;83     *****************************************************/
;;;84     void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;85     {
;;;86     	NVIC_InitTypeDef	NVIC_InitStructure;
;;;87     	
;;;88     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);	   //先占优先级1位，从优先级3位
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;89     	//使能串口1中断
;;;90     	NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;91     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1;
000010  2001              MOVS     r0,#1
000012  f88d0001          STRB     r0,[sp,#1]
;;;92     	NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;
000016  f88d0002          STRB     r0,[sp,#2]
;;;93     	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
00001a  f88d0003          STRB     r0,[sp,#3]
;;;94     	NVIC_Init(&NVIC_InitStructure);	
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       NVIC_Init
;;;95     }
000024  bd08              POP      {r3,pc}
;;;96     
                          ENDP


                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=2

                  RTC_Configuration PROC
;;;112     *******************************************************************************/
;;;113    void RTC_Configuration(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;114    {
;;;115        NVIC_InitTypeDef NVIC_InitStructure;
;;;116        if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       BKP_ReadBackupRegister
000008  f24a57a5          MOV      r7,#0xa5a5
;;;117        {      
;;;118    		//??oó±?óòìá1?ê±?ó
;;;119    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);
00000c  2601              MOVS     r6,#1
;;;120    		PWR_BackupAccessCmd(ENABLE);				 	  //oó±?óò?a??
;;;121    		BKP_DeInit();
;;;122    		RCC_LSEConfig(RCC_LSE_ON);						  //′ò?aía2?μí?μ?§??
;;;123    		while(RCC_GetFlagStatus(RCC_FLAG_LSERDY)==RESET); //μè′yía2?μí?μ?§??1¤×÷?y3￡
;;;124    		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);			  //ía2?μí?μ?§??×÷?aRTC?§???′
;;;125    		RCC_RTCCLKCmd(ENABLE);							  //ê1?üRTC
;;;126    		RTC_WaitForSynchro();
;;;127    		RTC_WaitForLastTask();
;;;128    		RTC_ITConfig(RTC_IT_SEC, ENABLE);				  // ê1?üRTC???D??
;;;129    		RTC_WaitForLastTask();
;;;130    		RTC_SetPrescaler(32767);						  //(32.768 KHz)/(32767+1)
;;;131    		RTC_WaitForLastTask();
;;;132    		
;;;133    		/********óD1?NVICμ?éè??2?・?****************/
;;;134    	  	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
00000e  2503              MOVS     r5,#3
;;;135    	  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2400              MOVS     r4,#0
000012  42b8              CMP      r0,r7                 ;116
000014  d043              BEQ      |L30.158|
000016  2101              MOVS     r1,#1                 ;119
000018  06e8              LSLS     r0,r5,#27             ;119
00001a  f7fffffe          BL       RCC_APB1PeriphClockCmd
00001e  2001              MOVS     r0,#1                 ;120
000020  f7fffffe          BL       PWR_BackupAccessCmd
000024  f7fffffe          BL       BKP_DeInit
000028  2001              MOVS     r0,#1                 ;122
00002a  f7fffffe          BL       RCC_LSEConfig
                  |L30.46|
00002e  2041              MOVS     r0,#0x41              ;123
000030  f7fffffe          BL       RCC_GetFlagStatus
000034  2800              CMP      r0,#0                 ;123
000036  d0fa              BEQ      |L30.46|
000038  f44f7080          MOV      r0,#0x100             ;124
00003c  f7fffffe          BL       RCC_RTCCLKConfig
000040  2001              MOVS     r0,#1                 ;125
000042  f7fffffe          BL       RCC_RTCCLKCmd
000046  f7fffffe          BL       RTC_WaitForSynchro
00004a  f7fffffe          BL       RTC_WaitForLastTask
00004e  2101              MOVS     r1,#1                 ;128
000050  4608              MOV      r0,r1                 ;128
000052  f7fffffe          BL       RTC_ITConfig
000056  f7fffffe          BL       RTC_WaitForLastTask
00005a  f64770ff          MOV      r0,#0x7fff            ;130
00005e  f7fffffe          BL       RTC_SetPrescaler
000062  f7fffffe          BL       RTC_WaitForLastTask
000066  f88d5008          STRB     r5,[sp,#8]            ;134
00006a  f88d4009          STRB     r4,[sp,#9]
;;;136    	  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00006e  f88d400a          STRB     r4,[sp,#0xa]
;;;137    	  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000072  f88d600b          STRB     r6,[sp,#0xb]
;;;138    	  	NVIC_Init(&NVIC_InitStructure); 
000076  a802              ADD      r0,sp,#8
000078  f7fffffe          BL       NVIC_Init
;;;139    		//????íê3éoó￡??òoó±???′??÷?DD′ì?êa×?・?0xA5A5
;;;140    	    SetRtcTime(10,5,3,16,3,0);
00007c  e9cd5400          STRD     r5,r4,[sp,#0]
000080  2310              MOVS     r3,#0x10
000082  2203              MOVS     r2,#3
000084  2105              MOVS     r1,#5
000086  200a              MOVS     r0,#0xa
000088  f7fffffe          BL       SetRtcTime
;;;141    		RTC_WaitForLastTask();
00008c  f7fffffe          BL       RTC_WaitForLastTask
;;;142    		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
000090  4639              MOV      r1,r7
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       BKP_WriteBackupRegister
;;;143    		RTC_WaitForLastTask();
000098  f7fffffe          BL       RTC_WaitForLastTask
;;;144        }
;;;145    	 else
;;;146        {
;;;147    		//è?oó±???′??÷??óDμ?μ?￡??ò?TDè??D?????RTC
;;;148            //?aà??ò???éò?à?ó?RCC_GetFlagStatus()oˉêy2é?′±?′??′??ààDí
;;;149            if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)		//?aê?é?μ??′??
;;;150            {
;;;151                GPIO_ResetBits(GPIOE,GPIO_Pin_4|GPIO_Pin_5);
;;;152    			GPIO_SetBits(GPIOE,GPIO_Pin_2|GPIO_Pin_3);						
;;;153            }
;;;154            else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)	//?aê?ía2?RST1ü???′??
;;;155            {
;;;156                GPIO_ResetBits(GPIOE,GPIO_Pin_2|GPIO_Pin_3);	  
;;;157    			GPIO_SetBits(GPIOE,GPIO_Pin_4|GPIO_Pin_5);			
;;;158            }
;;;159            RCC_ClearFlag();//??3yRCC?D?′??±ê??
;;;160            //??è?RTC?￡?é2?Dèòa??D?????￡??òμ?μ?oóòà??oó±?μ?3?òàè???DD
;;;161            //μ?ê???′?é?μ?oó￡??1ê?òaê1?üRTCCLK???????
;;;162            //RCC_RTCCLKCmd(ENABLE);
;;;163            //μè′yRTCê±?óó?APB1ê±?óí?2?
;;;164            RTC_WaitForSynchro();
;;;165            //ê1?ü???D??
;;;166            RTC_ITConfig(RTC_IT_SEC, ENABLE);
;;;167            //μè′y2ù×÷íê3é
;;;168            RTC_WaitForLastTask();
;;;169    		/********óD1?NVICμ?éè??2?・?****************/
;;;170    	  	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
;;;171    	  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;172    	  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;173    	  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;174    	  	NVIC_Init(&NVIC_InitStructure);
;;;175        }
;;;176    
;;;177    }
00009c  bdfe              POP      {r1-r7,pc}
                  |L30.158|
00009e  207b              MOVS     r0,#0x7b              ;149
0000a0  f7fffffe          BL       RCC_GetFlagStatus
0000a4  4f14              LDR      r7,|L30.248|
0000a6  b128              CBZ      r0,|L30.180|
0000a8  2130              MOVS     r1,#0x30              ;151
0000aa  4638              MOV      r0,r7                 ;151
0000ac  f7fffffe          BL       GPIO_ResetBits
0000b0  210c              MOVS     r1,#0xc               ;152
0000b2  e008              B        |L30.198|
                  |L30.180|
0000b4  207a              MOVS     r0,#0x7a              ;154
0000b6  f7fffffe          BL       RCC_GetFlagStatus
0000ba  b138              CBZ      r0,|L30.204|
0000bc  210c              MOVS     r1,#0xc               ;156
0000be  4638              MOV      r0,r7                 ;156
0000c0  f7fffffe          BL       GPIO_ResetBits
0000c4  2130              MOVS     r1,#0x30              ;157
                  |L30.198|
0000c6  4638              MOV      r0,r7                 ;157
0000c8  f7fffffe          BL       GPIO_SetBits
                  |L30.204|
0000cc  f7fffffe          BL       RCC_ClearFlag
0000d0  f7fffffe          BL       RTC_WaitForSynchro
0000d4  2101              MOVS     r1,#1                 ;166
0000d6  4608              MOV      r0,r1                 ;166
0000d8  f7fffffe          BL       RTC_ITConfig
0000dc  f7fffffe          BL       RTC_WaitForLastTask
0000e0  f88d5008          STRB     r5,[sp,#8]            ;170
0000e4  f88d4009          STRB     r4,[sp,#9]            ;171
0000e8  f88d400a          STRB     r4,[sp,#0xa]          ;172
0000ec  f88d600b          STRB     r6,[sp,#0xb]          ;173
0000f0  a802              ADD      r0,sp,#8              ;174
0000f2  f7fffffe          BL       NVIC_Init
0000f6  bdfe              POP      {r1-r7,pc}
;;;178    
                          ENDP

                  |L30.248|
                          DCD      0x40011800

                          AREA ||i.Read_RTC_Time||, CODE, READONLY, ALIGN=1

                  Read_RTC_Time PROC
;;;54     *****************************************************/
;;;55     void Read_RTC_Time(void)
000000  4770              BX       lr
;;;56     {
;;;57         #if 0
;;;58     	unsigned long Time_Value;
;;;59     	unsigned long Day_Value;
;;;60     	//Time_Struct TimeStruct1;
;;;61     	Time_Value=RTC_GetCounter();
;;;62     	Day_Value=Time_Value/(86400);	//24*3600
;;;63     	
;;;64     	Year=Day_Value/360;
;;;65     	Month=(Day_Value-Year*360)/30;
;;;66     	Day=(Day_Value-Year*360)%30;
;;;67     	Month+=1;
;;;68     	Day+=1;
;;;69     	Hour=(Time_Value-Day_Value*24*3600)/3600;
;;;70     	Min=(Time_Value-Day_Value*24*3600-Hour*3600)/60;
;;;71     	Sec=Time_Value-Day_Value*24*3600-Hour*3600-Min*60;
;;;72     
;;;73     	Uart1_PutChar(0x32);                      
;;;74     	Uart1_PutChar(0x30);
;;;75     	Uart1_PutChar(Year/10+0x30);
;;;76     	Uart1_PutChar(Year%10+0x30);
;;;77     	Uart1_PutChar('-');
;;;78     	Uart1_PutChar('-');
;;;79     	Uart1_PutChar(Month/10+0x30);
;;;80     	Uart1_PutChar(Month%10+0x30);
;;;81     	Uart1_PutChar('-');
;;;82     	Uart1_PutChar('-');
;;;83     	Uart1_PutChar(Day/10+0x30);
;;;84     	Uart1_PutChar(Day%10+0x30);
;;;85     	Uart1_PutChar('-');
;;;86     	Uart1_PutChar('-');
;;;87     	Uart1_PutChar(Hour/10+0x30);
;;;88     	Uart1_PutChar(Hour%10+0x30);
;;;89     	Uart1_PutChar('-');
;;;90     	Uart1_PutChar('-');
;;;91     	Uart1_PutChar(Min/10+0x30);
;;;92     	Uart1_PutChar(Min%10+0x30);
;;;93     	Uart1_PutChar('-');
;;;94     	Uart1_PutChar('-');
;;;95     	Uart1_PutChar(Sec/10+0x30);
;;;96     	Uart1_PutChar(Sec%10+0x30);
;;;97     	Uart1_PutChar(0xd);
;;;98     	Uart1_PutChar(0xa);
;;;99         #endif 
;;;100    }
;;;101    
                          ENDP


                          AREA ||i.SDEnWideBus||, CODE, READONLY, ALIGN=2

                  SDEnWideBus PROC
;;;2577     */
;;;2578   static SD_Error SDEnWideBus(FunctionalState NewState)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2579   {
;;;2580     SD_Error errorstatus = SD_OK;
;;;2581   
;;;2582     uint32_t scr[2] = {0, 0};
000004  2400              MOVS     r4,#0
000006  4681              MOV      r9,r0                 ;2579
000008  9400              STR      r4,[sp,#0]
;;;2583     /* 确认卡未被上锁 */
;;;2584     if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
00000a  4620              MOV      r0,r4
00000c  9401              STR      r4,[sp,#4]
00000e  f7fffffe          BL       SDIO_GetResponse
000012  0180              LSLS     r0,r0,#6
000014  d502              BPL      |L32.28|
;;;2585     {
;;;2586       errorstatus = SD_LOCK_UNLOCK_FAILED;
000016  200e              MOVS     r0,#0xe
                  |L32.24|
;;;2587       return(errorstatus);
;;;2588     }
;;;2589   
;;;2590     /* Get SCR Register */
;;;2591      /* 获得 SCR 寄存器 */
;;;2592     errorstatus = FindSCR(RCA, scr);
;;;2593   
;;;2594     if (errorstatus != SD_OK)
;;;2595     {
;;;2596       return(errorstatus);
;;;2597     }
;;;2598   
;;;2599     /* If wide bus operation to be enabled */
;;;2600     /* 使能宽总线操作 */
;;;2601     if (NewState == ENABLE)
;;;2602     {
;;;2603       /* If requested card supports wide bus operation */
;;;2604   	/* 如果卡支持宽总线操作，即SD_BUS_WIDTHS(SCR[51:48]) = 0100b */
;;;2605       if ((scr[1] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
;;;2606       {
;;;2607         /* Send CMD55 APP_CMD with argument as card's RCA.*/
;;;2608   	  /* CMD55: APP_CMD ------------------------------------------------------------*/
;;;2609         /* 必须在发送 ACMD6 之前发送 CMD55 通知卡，下面一条命令是应用特定命令 */
;;;2610         /* 参数: - [31:16]: RCA 
;;;2611                  - [15:0]: 保留('0') */
;;;2612         /* 响应类型: R1 */
;;;2613         SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
;;;2614         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
;;;2615         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2616         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2617         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2618         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;2619   
;;;2620         errorstatus = CmdResp1Error(SDIO_APP_CMD);
;;;2621   
;;;2622         if (errorstatus != SD_OK)
;;;2623         {
;;;2624           return(errorstatus);
;;;2625         }
;;;2626   
;;;2627         /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
;;;2628   	  /* ACMD6: SET_BUS_WIDTH ------------------------------------------------------*/
;;;2629         /* 发送 ACMD6 设置总线宽度 */
;;;2630         /* 参数: - [31:2]: 填充位('0') 
;;;2631                   - [1:0]: 总线宽度(‘00’=1位，‘10’=4位) */
;;;2632         /* 响应类型: R1 */
;;;2633         SDIO_CmdInitStructure.SDIO_Argument = 0x2;
;;;2634         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_SD_SET_BUSWIDTH;
;;;2635         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2636         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2637         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2638         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;2639   
;;;2640         errorstatus = CmdResp1Error(SDIO_APP_SD_SET_BUSWIDTH);
;;;2641   
;;;2642         if (errorstatus != SD_OK)
;;;2643         {
;;;2644           return(errorstatus);
;;;2645         }
;;;2646         return(errorstatus);
;;;2647       }
;;;2648       else
;;;2649       {
;;;2650         errorstatus = SD_REQUEST_NOT_APPLICABLE;
;;;2651         return(errorstatus);
;;;2652       }
;;;2653     }   
;;;2654     /* If wide bus operation to be disabled */
;;;2655     /* 失能宽总线操作 */
;;;2656     else
;;;2657     {
;;;2658       /* If requested card supports 1 bit mode operation */
;;;2659   	 /* 如果卡支持1位总线操作，即SD_BUS_WIDTHS(SCR[51:48]) = 0001b */
;;;2660       if ((scr[1] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
;;;2661       {
;;;2662         /* Send CMD55 APP_CMD with argument as card's RCA.*/
;;;2663   	  /* CMD55: APP_CMD ------------------------------------------------------------*/
;;;2664         /* 必须在发送 ACMD6 之前发送 CMD55 通知卡，下面一条命令是应用特定命令 */
;;;2665         /* 参数: - [31:16]: RCA 
;;;2666                  - [15:0]: 保留('0') */
;;;2667         /* 响应类型: R1 */
;;;2668         SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
;;;2669         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
;;;2670         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2671         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2672         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2673         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;2674   
;;;2675   
;;;2676         errorstatus = CmdResp1Error(SDIO_APP_CMD);
;;;2677   
;;;2678         if (errorstatus != SD_OK)
;;;2679         {
;;;2680           return(errorstatus);
;;;2681         }
;;;2682   
;;;2683         /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
;;;2684   	  /* ACMD6: SET_BUS_WIDTH ------------------------------------------------------*/
;;;2685         /* 发送 ACMD6 设置总线宽度 */
;;;2686         /* 参数: - [31:2]: 填充位('0') 
;;;2687                 - [1:0]: 总线宽度(‘00’=1位，‘10’=4位) */
;;;2688         /* 响应类型: R1 */
;;;2689         SDIO_CmdInitStructure.SDIO_Argument = 0x00;
;;;2690         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_SD_SET_BUSWIDTH;
;;;2691         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2692         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2693         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2694         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;2695   
;;;2696         errorstatus = CmdResp1Error(SDIO_APP_SD_SET_BUSWIDTH);
;;;2697   
;;;2698         if (errorstatus != SD_OK)
;;;2699         {
;;;2700           return(errorstatus);
;;;2701         }
;;;2702   
;;;2703         return(errorstatus);
;;;2704       }
;;;2705       else
;;;2706       {
;;;2707         errorstatus = SD_REQUEST_NOT_APPLICABLE;
;;;2708         return(errorstatus);
;;;2709       }
;;;2710     }
;;;2711   }
000018  e8bd87fc          POP      {r2-r10,pc}
                  |L32.28|
00001c  4d26              LDR      r5,|L32.184|
00001e  4669              MOV      r1,sp                 ;2592
000020  68a8              LDR      r0,[r5,#8]            ;2592  ; RCA
000022  b280              UXTH     r0,r0                 ;2592
000024  f7fffffe          BL       FindSCR
000028  282a              CMP      r0,#0x2a              ;2594
00002a  d1f5              BNE      |L32.24|
00002c  2037              MOVS     r0,#0x37              ;2614
00002e  4e23              LDR      r6,|L32.188|
000030  9901              LDR      r1,[sp,#4]            ;2601
000032  f04f0a06          MOV      r10,#6                ;2634
000036  f04f0840          MOV      r8,#0x40              ;2615
00003a  f44f6780          MOV      r7,#0x400             ;2617
00003e  f1b90f01          CMP      r9,#1                 ;2601
000042  d01e              BEQ      |L32.130|
000044  03c9              LSLS     r1,r1,#15             ;2660
000046  d534              BPL      |L32.178|
000048  68a9              LDR      r1,[r5,#8]            ;2668  ; RCA
00004a  f8c68008          STR      r8,[r6,#8]            ;2670  ; SDIO_CmdInitStructure
00004e  0409              LSLS     r1,r1,#16             ;2668
000050  e9c61000          STRD     r1,r0,[r6,#0]         ;2670
000054  e9c64703          STRD     r4,r7,[r6,#0xc]       ;2673
000058  4630              MOV      r0,r6                 ;2673
00005a  f7fffffe          BL       SDIO_SendCommand
00005e  2037              MOVS     r0,#0x37              ;2676
000060  f7fffffe          BL       CmdResp1Error
000064  282a              CMP      r0,#0x2a              ;2678
000066  d1d7              BNE      |L32.24|
000068  f8c68008          STR      r8,[r6,#8]            ;2691  ; SDIO_CmdInitStructure
00006c  e9c64a00          STRD     r4,r10,[r6,#0]        ;2691
                  |L32.112|
000070  e9c64703          STRD     r4,r7,[r6,#0xc]       ;2691
000074  4811              LDR      r0,|L32.188|
000076  f7fffffe          BL       SDIO_SendCommand
00007a  2006              MOVS     r0,#6                 ;2696
00007c  f7fffffe          BL       CmdResp1Error
000080  e7ca              B        |L32.24|
                  |L32.130|
000082  0349              LSLS     r1,r1,#13             ;2605
000084  d515              BPL      |L32.178|
000086  68a9              LDR      r1,[r5,#8]            ;2613  ; RCA
000088  f8c68008          STR      r8,[r6,#8]            ;2615  ; SDIO_CmdInitStructure
00008c  0409              LSLS     r1,r1,#16             ;2613
00008e  e9c61000          STRD     r1,r0,[r6,#0]         ;2615
000092  e9c64703          STRD     r4,r7,[r6,#0xc]       ;2618
000096  4809              LDR      r0,|L32.188|
000098  f7fffffe          BL       SDIO_SendCommand
00009c  2037              MOVS     r0,#0x37              ;2620
00009e  f7fffffe          BL       CmdResp1Error
0000a2  282a              CMP      r0,#0x2a              ;2622
0000a4  d1b8              BNE      |L32.24|
0000a6  2002              MOVS     r0,#2                 ;2633
0000a8  f8c68008          STR      r8,[r6,#8]            ;2635  ; SDIO_CmdInitStructure
0000ac  e9c60a00          STRD     r0,r10,[r6,#0]        ;2635
0000b0  e7de              B        |L32.112|
                  |L32.178|
0000b2  2025              MOVS     r0,#0x25              ;2707
0000b4  e7b0              B        |L32.24|
;;;2712   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L32.184|
                          DCD      ||.data||
                  |L32.188|
                          DCD      ||.bss||+0x38

                          AREA ||i.SD_EnableWideBusOperation||, CODE, READONLY, ALIGN=2

                  SD_EnableWideBusOperation PROC
;;;655     */
;;;656    SD_Error SD_EnableWideBusOperation(uint32_t WideMode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;657    {
000004  4601              MOV      r1,r0
;;;658      SD_Error errorstatus = SD_OK;
;;;659    
;;;660      /* MMC Card doesn't support this feature */
;;;661      /* MMC不支持宽总线操作模式 */
;;;662      if (SDIO_MULTIMEDIA_CARD == CardType)
000006  481e              LDR      r0,|L33.128|
000008  242a              MOVS     r4,#0x2a              ;658
00000a  6840              LDR      r0,[r0,#4]  ; CardType
00000c  2803              CMP      r0,#3
00000e  d015              BEQ      |L33.60|
;;;663      {
;;;664        errorstatus = SD_UNSUPPORTED_FEATURE;
;;;665        return(errorstatus);
;;;666      }
;;;667      else if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
000010  b118              CBZ      r0,|L33.26|
000012  2801              CMP      r0,#1
000014  d001              BEQ      |L33.26|
000016  2802              CMP      r0,#2
000018  d130              BNE      |L33.124|
                  |L33.26|
;;;668      {
;;;669        /* 以上这些卡不支持8位宽总线操作模式 */
;;;670    	if (SDIO_BusWide_8b == WideMode)
00001a  f5b15f80          CMP      r1,#0x1000
00001e  d00d              BEQ      |L33.60|
;;;671        {
;;;672          errorstatus = SD_UNSUPPORTED_FEATURE;
;;;673          return(errorstatus);
;;;674        }
;;;675        else if (SDIO_BusWide_4b == WideMode)
000020  f44f6800          MOV      r8,#0x800
000024  2600              MOVS     r6,#0                 ;662
000026  2701              MOVS     r7,#1                 ;662
;;;676        {
;;;677          errorstatus = SDEnWideBus(ENABLE);
;;;678    
;;;679          if (SD_OK == errorstatus)
;;;680          {
;;;681            /* Configure the SDIO peripheral */
;;;682    		/* 配置SDIO外设的总线宽度为4位 */
;;;683            SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV; 
000028  4d16              LDR      r5,|L33.132|
00002a  4541              CMP      r1,r8                 ;675
00002c  d117              BNE      |L33.94|
00002e  2001              MOVS     r0,#1                 ;677
000030  f7fffffe          BL       SDEnWideBus
000034  4604              MOV      r4,r0                 ;677
000036  282a              CMP      r0,#0x2a              ;679
000038  d003              BEQ      |L33.66|
00003a  e01f              B        |L33.124|
                  |L33.60|
00003c  2027              MOVS     r0,#0x27              ;672
                  |L33.62|
;;;684            SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
;;;685            SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
;;;686            SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
;;;687            SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_4b;
;;;688            SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
;;;689            SDIO_Init(&SDIO_InitStructure);
;;;690            DBG_Print(3, "SDIO_BusWide_4b is ok\r\n");
;;;691          }
;;;692        }
;;;693        else
;;;694        {
;;;695          errorstatus = SDEnWideBus(DISABLE);
;;;696    
;;;697          if (SD_OK == errorstatus)
;;;698          {
;;;699            /* Configure the SDIO peripheral */
;;;700    		/* 配置SDIO外设的总线宽度为1位 */
;;;701            SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV; 
;;;702            SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
;;;703            SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
;;;704            SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
;;;705            SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
;;;706            SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
;;;707            SDIO_Init(&SDIO_InitStructure);
;;;708          }
;;;709        }
;;;710      }
;;;711    
;;;712      return(errorstatus);
;;;713    }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L33.66|
000042  752f              STRB     r7,[r5,#0x14]         ;683
000044  602e              STR      r6,[r5,#0]            ;685  ; SDIO_InitStructure
000046  606e              STR      r6,[r5,#4]            ;685  ; SDIO_InitStructure
000048  e9c56802          STRD     r6,r8,[r5,#8]         ;685
00004c  480d              LDR      r0,|L33.132|
00004e  612e              STR      r6,[r5,#0x10]         ;689  ; SDIO_InitStructure
000050  f7fffffe          BL       SDIO_Init
000054  a10c              ADR      r1,|L33.136|
000056  2003              MOVS     r0,#3                 ;690
000058  f7fffffe          BL       DBG_Print
00005c  e00e              B        |L33.124|
                  |L33.94|
00005e  2000              MOVS     r0,#0                 ;695
000060  f7fffffe          BL       SDEnWideBus
000064  4604              MOV      r4,r0                 ;695
000066  282a              CMP      r0,#0x2a              ;697
000068  d108              BNE      |L33.124|
00006a  752f              STRB     r7,[r5,#0x14]         ;701
00006c  602e              STR      r6,[r5,#0]            ;703  ; SDIO_InitStructure
00006e  606e              STR      r6,[r5,#4]            ;704  ; SDIO_InitStructure
000070  60ae              STR      r6,[r5,#8]            ;705  ; SDIO_InitStructure
000072  60ee              STR      r6,[r5,#0xc]          ;706  ; SDIO_InitStructure
000074  4803              LDR      r0,|L33.132|
000076  612e              STR      r6,[r5,#0x10]         ;707  ; SDIO_InitStructure
000078  f7fffffe          BL       SDIO_Init
                  |L33.124|
00007c  4620              MOV      r0,r4                 ;712
00007e  e7de              B        |L33.62|
;;;714    
                          ENDP

                  |L33.128|
                          DCD      ||.data||
                  |L33.132|
                          DCD      ||.bss||+0x20
                  |L33.136|
000088  5344494f          DCB      "SDIO_BusWide_4b is ok\r\n",0
00008c  5f427573
000090  57696465
000094  5f346220
000098  6973206f
00009c  6b0d0a00

                          AREA ||i.SD_Erase||, CODE, READONLY, ALIGN=2

                  SD_Erase PROC
;;;1795     */
;;;1796   SD_Error SD_Erase(uint32_t startaddr, uint32_t endaddr)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1797   {
000004  4605              MOV      r5,r0
;;;1798     SD_Error errorstatus = SD_OK;
;;;1799     uint32_t delay = 0;
;;;1800     __IO uint32_t maxdelay = 0;
;;;1801     uint8_t cardstate = 0;
;;;1802   
;;;1803     /* Check if the card coomnd class supports erase command */
;;;1804     /* 检查卡是否支持擦出命令类(class 5)，即CCC(CSD[95:84])D5位是否为1 */
;;;1805     /* 如果不支持，则返回错误代码 */
;;;1806     if (((CSD_Tab[1] >> 20) & SD_CCCC_ERASE) == 0)
000006  4839              LDR      r0,|L34.236|
000008  2400              MOVS     r4,#0                 ;1799
00000a  f88d4000          STRB     r4,[sp,#0]            ;1801
00000e  6840              LDR      r0,[r0,#4]  ; CSD_Tab
000010  460e              MOV      r6,r1                 ;1797
000012  ea4f5010          LSR      r0,r0,#20
000016  46a0              MOV      r8,r4                 ;1801
000018  0680              LSLS     r0,r0,#26
00001a  d402              BMI      |L34.34|
;;;1807     {
;;;1808       errorstatus = SD_REQUEST_NOT_APPLICABLE;
00001c  2025              MOVS     r0,#0x25
                  |L34.30|
;;;1809       return(errorstatus);
;;;1810     }
;;;1811   /*有见过不是72000而是120000的****************************************************11111111111111111111111111111111111111111111111111111111111111***/
;;;1812     maxdelay = 72000 / ((SDIO->CLKCR & 0xFF) + 2);
;;;1813      /* 如果卡已被上锁 */
;;;1814     if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
;;;1815     {
;;;1816       errorstatus = SD_LOCK_UNLOCK_FAILED;
;;;1817       return(errorstatus);
;;;1818     }
;;;1819      /* 在标准容量SD存储卡中，地址是以字节为单位的，
;;;1820      而在高容量SD存储卡中，地址是以块(512字节)为单位的 */
;;;1821     if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;1822     {
;;;1823       startaddr /= 512;
;;;1824       endaddr /= 512;
;;;1825     }
;;;1826      /* 设置待擦除连续块的起始地址和结束地址 */
;;;1827     /* According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
;;;1828     if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || 
;;;1829     													(SDIO_HIGH_CAPACITY_SD_CARD == CardType))
;;;1830     {
;;;1831       /* Send CMD32 SD_ERASE_GRP_START with argument as addr  */
;;;1832   	 /* CMD32: ERASE_WR_BLK_START ----------------------------------------------------*/
;;;1833       /* 发送 CMD32 设置待擦除连续块的起始地址 */
;;;1834       /* 参数: - [31:0]: 数据地址 */
;;;1835       /* 响应类型: R1 */
;;;1836       SDIO_CmdInitStructure.SDIO_Argument = startaddr;
;;;1837       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SD_ERASE_GRP_START;
;;;1838       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1839       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1840       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1841       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1842   
;;;1843       errorstatus = CmdResp1Error(SDIO_SD_ERASE_GRP_START);
;;;1844       if (errorstatus != SD_OK)
;;;1845       {
;;;1846         return(errorstatus);
;;;1847       }
;;;1848   
;;;1849       /* Send CMD33 SD_ERASE_GRP_END with argument as addr  */
;;;1850   	/* CMD33: ERASE_WR_BLK_END ------------------------------------------------------*/
;;;1851       /* 发送 CMD33 设置待擦除连续块的起始地址 */
;;;1852       /* 参数: - [31:0]: 数据地址 */
;;;1853       /* 响应类型: R1 */
;;;1854       SDIO_CmdInitStructure.SDIO_Argument = endaddr;
;;;1855       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SD_ERASE_GRP_END;
;;;1856       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1857       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1858       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1859       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1860   
;;;1861       errorstatus = CmdResp1Error(SDIO_SD_ERASE_GRP_END);
;;;1862       if (errorstatus != SD_OK)
;;;1863       {
;;;1864         return(errorstatus);
;;;1865       }
;;;1866     }
;;;1867   
;;;1868     /* Send CMD38 ERASE */
;;;1869      /* CMD38: ERASE -------------------------------------------------------------------*/
;;;1870     /* 发送 CMD38 擦除之前CMD32和CMD33选择的连续块 */
;;;1871     /* 参数: - [31:0]: 填充位(‘0’) */
;;;1872     /* 响应类型: R1b */
;;;1873     SDIO_CmdInitStructure.SDIO_Argument = 0;
;;;1874     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_ERASE;
;;;1875     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1876     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1877     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1878     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1879   
;;;1880     errorstatus = CmdResp1Error(SDIO_ERASE);
;;;1881   
;;;1882     if (errorstatus != SD_OK)
;;;1883     {
;;;1884       return(errorstatus);
;;;1885     }
;;;1886   
;;;1887     for (delay = 0; delay < maxdelay; delay++)
;;;1888     {}
;;;1889      /* 等待直到擦除操作完成 */
;;;1890     /* Wait till the card is in programming state */
;;;1891     errorstatus = IsCardProgramming(&cardstate);
;;;1892   
;;;1893     while ((errorstatus == SD_OK) && ((SD_CARD_PROGRAMMING == cardstate) || (SD_CARD_RECEIVING == cardstate)))
;;;1894     {
;;;1895       errorstatus = IsCardProgramming(&cardstate);
;;;1896     }
;;;1897   
;;;1898     return(errorstatus);
;;;1899   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.34|
000022  4833              LDR      r0,|L34.240|
000024  6840              LDR      r0,[r0,#4]            ;1812
000026  4933              LDR      r1,|L34.244|
000028  b2c0              UXTB     r0,r0                 ;1812
00002a  1c80              ADDS     r0,r0,#2              ;1812
00002c  fbb1f7f0          UDIV     r7,r1,r0              ;1812
000030  2000              MOVS     r0,#0                 ;1814
000032  f7fffffe          BL       SDIO_GetResponse
000036  0180              LSLS     r0,r0,#6              ;1814
000038  d501              BPL      |L34.62|
00003a  200e              MOVS     r0,#0xe               ;1816
00003c  e7ef              B        |L34.30|
                  |L34.62|
00003e  482e              LDR      r0,|L34.248|
000040  f8df90a8          LDR      r9,|L34.236|
000044  f04f0b40          MOV      r11,#0x40             ;1838
000048  6840              LDR      r0,[r0,#4]            ;1821  ; CardType
00004a  f1090938          ADD      r9,r9,#0x38           ;1836
00004e  f44f6a80          MOV      r10,#0x400            ;1840
000052  2802              CMP      r0,#2                 ;1821
000054  d005              BEQ      |L34.98|
000056  b130              CBZ      r0,|L34.102|
000058  2801              CMP      r0,#1                 ;1828
00005a  d004              BEQ      |L34.102|
00005c  2802              CMP      r0,#2                 ;1829
00005e  d002              BEQ      |L34.102|
000060  e025              B        |L34.174|
                  |L34.98|
000062  0a6d              LSRS     r5,r5,#9              ;1823
000064  0a76              LSRS     r6,r6,#9              ;1824
                  |L34.102|
000066  4648              MOV      r0,r9                 ;1836
000068  2120              MOVS     r1,#0x20              ;1837
00006a  e9c05100          STRD     r5,r1,[r0,#0]         ;1837
00006e  e9c9b802          STRD     r11,r8,[r9,#8]        ;1838
000072  481e              LDR      r0,|L34.236|
000074  465d              MOV      r5,r11                ;1838
000076  3038              ADDS     r0,r0,#0x38           ;1841
000078  f8c9a010          STR      r10,[r9,#0x10]        ;1841  ; SDIO_CmdInitStructure
00007c  f7fffffe          BL       SDIO_SendCommand
000080  2020              MOVS     r0,#0x20              ;1843
000082  f7fffffe          BL       CmdResp1Error
000086  282a              CMP      r0,#0x2a              ;1844
000088  d1c9              BNE      |L34.30|
00008a  f1090004          ADD      r0,r9,#4              ;1855
00008e  2121              MOVS     r1,#0x21              ;1855
000090  f8c96000          STR      r6,[r9,#0]            ;1855  ; SDIO_CmdInitStructure
000094  e8a00122          STM      r0!,{r1,r5,r8}        ;1855
000098  4814              LDR      r0,|L34.236|
00009a  f8c9a010          STR      r10,[r9,#0x10]        ;1859  ; SDIO_CmdInitStructure
00009e  3038              ADDS     r0,r0,#0x38           ;1859
0000a0  f7fffffe          BL       SDIO_SendCommand
0000a4  2021              MOVS     r0,#0x21              ;1861
0000a6  f7fffffe          BL       CmdResp1Error
0000aa  282a              CMP      r0,#0x2a              ;1862
0000ac  d1b7              BNE      |L34.30|
                  |L34.174|
0000ae  4641              MOV      r1,r8                 ;1873
0000b0  2226              MOVS     r2,#0x26              ;1874
0000b2  e8890806          STM      r9,{r1,r2,r11}        ;1874
0000b6  480d              LDR      r0,|L34.236|
0000b8  e9c98a03          STRD     r8,r10,[r9,#0xc]      ;1878
0000bc  3038              ADDS     r0,r0,#0x38           ;1878
0000be  f7fffffe          BL       SDIO_SendCommand
0000c2  2026              MOVS     r0,#0x26              ;1880
0000c4  f7fffffe          BL       CmdResp1Error
0000c8  282a              CMP      r0,#0x2a              ;1882
0000ca  d1a8              BNE      |L34.30|
0000cc  e000              B        |L34.208|
                  |L34.206|
0000ce  1c64              ADDS     r4,r4,#1              ;1887
                  |L34.208|
0000d0  42bc              CMP      r4,r7                 ;1887
0000d2  d3fc              BCC      |L34.206|
                  |L34.212|
0000d4  4668              MOV      r0,sp                 ;1891
0000d6  f7fffffe          BL       IsCardProgramming
0000da  282a              CMP      r0,#0x2a              ;1893
0000dc  d19f              BNE      |L34.30|
0000de  f89d1000          LDRB     r1,[sp,#0]            ;1893
0000e2  2907              CMP      r1,#7                 ;1893
0000e4  d0f6              BEQ      |L34.212|
0000e6  2906              CMP      r1,#6                 ;1893
0000e8  d0f4              BEQ      |L34.212|
0000ea  e798              B        |L34.30|
;;;1900   
                          ENDP

                  |L34.236|
                          DCD      ||.bss||
                  |L34.240|
                          DCD      0x40018000
                  |L34.244|
                          DCD      0x00011940
                  |L34.248|
                          DCD      ||.data||

                          AREA ||i.SD_GetCardInfo||, CODE, READONLY, ALIGN=2

                  SD_GetCardInfo PROC
;;;441     */
;;;442    SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;443    {
;;;444      SD_Error errorstatus = SD_OK;
;;;445      uint8_t tmp = 0;
;;;446    
;;;447      cardinfo->CardType = (uint8_t)CardType;		 // 卡的类型，初始化为0
000004  4997              LDR      r1,|L35.612|
;;;448      cardinfo->RCA = (uint16_t)RCA;						 // ?
;;;449    
;;;450      // Byte 0 //
;;;451      tmp = (uint8_t)((CSD_Tab[0] & 0xFF000000) >> 24);
000006  f8dfa260          LDR      r10,|L35.616|
00000a  f04f0c2a          MOV      r12,#0x2a             ;444
00000e  684b              LDR      r3,[r1,#4]            ;447  ; CardType
000010  f880304e          STRB     r3,[r0,#0x4e]         ;447
000014  6889              LDR      r1,[r1,#8]            ;448  ; RCA
000016  f8a0104c          STRH     r1,[r0,#0x4c]         ;448
00001a  f8da1000          LDR      r1,[r10,#0]  ; CSD_Tab
00001e  0e0a              LSRS     r2,r1,#24
;;;452      cardinfo->SD_csd.CSDStruct = (tmp & 0xC0) >> 6;
000020  0995              LSRS     r5,r2,#6
000022  7005              STRB     r5,[r0,#0]
;;;453      cardinfo->SD_csd.SysSpecVersion = (tmp & 0x3C) >> 2;
000024  f3c20583          UBFX     r5,r2,#2,#4
000028  7045              STRB     r5,[r0,#1]
;;;454      cardinfo->SD_csd.Reserved1 = tmp & 0x03;
00002a  f0020203          AND      r2,r2,#3
00002e  7082              STRB     r2,[r0,#2]
;;;455    
;;;456      // Byte 1 //
;;;457      tmp = (uint8_t)((CSD_Tab[0] & 0x00FF0000) >> 16);
000030  0c0a              LSRS     r2,r1,#16
;;;458      cardinfo->SD_csd.TAAC = tmp;
000032  70c2              STRB     r2,[r0,#3]
;;;459    
;;;460      // Byte 2 //
;;;461      tmp = (uint8_t)((CSD_Tab[0] & 0x0000FF00) >> 8);
000034  0a0a              LSRS     r2,r1,#8
;;;462      cardinfo->SD_csd.NSAC = tmp;
000036  7102              STRB     r2,[r0,#4]
;;;463    
;;;464      // Byte 3 //
;;;465      tmp = (uint8_t)(CSD_Tab[0] & 0x000000FF);
;;;466      cardinfo->SD_csd.MaxBusClkFrec = tmp;
000038  7141              STRB     r1,[r0,#5]
;;;467    
;;;468      // Byte 4 //
;;;469      tmp = (uint8_t)((CSD_Tab[1] & 0xFF000000) >> 24);
00003a  f8da2004          LDR      r2,[r10,#4]  ; CSD_Tab
00003e  0e11              LSRS     r1,r2,#24
;;;470      cardinfo->SD_csd.CardComdClasses = tmp << 4;
000040  0109              LSLS     r1,r1,#4
000042  80c1              STRH     r1,[r0,#6]
;;;471    
;;;472      // Byte 5 //
;;;473      tmp = (uint8_t)((CSD_Tab[1] & 0x00FF0000) >> 16);
;;;474      cardinfo->SD_csd.CardComdClasses |= (tmp & 0xF0) >> 4;
000044  88c4              LDRH     r4,[r0,#6]
000046  f3c24107          UBFX     r1,r2,#16,#8          ;473
00004a  ea441411          ORR      r4,r4,r1,LSR #4
00004e  80c4              STRH     r4,[r0,#6]
;;;475      cardinfo->SD_csd.RdBlockLen = tmp & 0x0F;
000050  f001010f          AND      r1,r1,#0xf
000054  7201              STRB     r1,[r0,#8]
;;;476    
;;;477      // Byte 6 //
;;;478      tmp = (uint8_t)((CSD_Tab[1] & 0x0000FF00) >> 8);
000056  f3c22107          UBFX     r1,r2,#8,#8
;;;479      cardinfo->SD_csd.PartBlockRead = (tmp & 0x80) >> 7;
00005a  09cc              LSRS     r4,r1,#7
00005c  7244              STRB     r4,[r0,#9]
;;;480      cardinfo->SD_csd.WrBlockMisalign = (tmp & 0x40) >> 6;
00005e  f3c11480          UBFX     r4,r1,#6,#1
000062  7284              STRB     r4,[r0,#0xa]
;;;481      cardinfo->SD_csd.RdBlockMisalign = (tmp & 0x20) >> 5;
000064  f3c11440          UBFX     r4,r1,#5,#1
000068  72c4              STRB     r4,[r0,#0xb]
;;;482      cardinfo->SD_csd.DSRImpl = (tmp & 0x10) >> 4;
00006a  f3c11400          UBFX     r4,r1,#4,#1
00006e  7304              STRB     r4,[r0,#0xc]
;;;483      cardinfo->SD_csd.Reserved2 = 0; //Reserved //
000070  f04f0800          MOV      r8,#0
000074  f880800d          STRB     r8,[r0,#0xd]
000078  4654              MOV      r4,r10                ;451
00007a  f04f0901          MOV      r9,#1                 ;447
;;;484    
;;;485      if ((CardType == SDIO_STD_CAPACITY_SD_CARD_V1_1) || (CardType == SDIO_STD_CAPACITY_SD_CARD_V2_0))
;;;486      {
;;;487        cardinfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
;;;488    
;;;489        // Byte 7 //
;;;490        tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
;;;491        cardinfo->SD_csd.DeviceSize |= (tmp) << 2;
;;;492    
;;;493        // Byte 8 //
;;;494        tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
00007e  68a4              LDR      r4,[r4,#8]
000080  0e25              LSRS     r5,r4,#24
;;;495        cardinfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
;;;496    
;;;497        cardinfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
;;;498        cardinfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
;;;499    
;;;500        // Byte 9 //
;;;501        tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
000082  f3c44607          UBFX     r6,r4,#16,#8
;;;502        cardinfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
;;;503        cardinfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
;;;504        cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
;;;505        // Byte 10 //
;;;506        tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
000086  f3c42707          UBFX     r7,r4,#8,#8
00008a  b123              CBZ      r3,|L35.150|
00008c  2b01              CMP      r3,#1                 ;485
00008e  d002              BEQ      |L35.150|
;;;507        cardinfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
;;;508        
;;;509        cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
;;;510        cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
;;;511        cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
;;;512        cardinfo->CardCapacity *= cardinfo->CardBlockSize;
;;;513      }
;;;514      else if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
000090  2b02              CMP      r3,#2
000092  d02b              BEQ      |L35.236|
000094  e03c              B        |L35.272|
                  |L35.150|
000096  0789              LSLS     r1,r1,#30             ;487
000098  0d09              LSRS     r1,r1,#20             ;487
00009a  6101              STR      r1,[r0,#0x10]         ;487
00009c  b2d1              UXTB     r1,r2                 ;490
00009e  6902              LDR      r2,[r0,#0x10]         ;491
0000a0  ea420181          ORR      r1,r2,r1,LSL #2       ;491
0000a4  6101              STR      r1,[r0,#0x10]         ;491
0000a6  6901              LDR      r1,[r0,#0x10]         ;495
0000a8  ea411195          ORR      r1,r1,r5,LSR #6       ;495
0000ac  6101              STR      r1,[r0,#0x10]         ;495
0000ae  f3c501c2          UBFX     r1,r5,#3,#3           ;497
0000b2  7501              STRB     r1,[r0,#0x14]         ;497
0000b4  f0050107          AND      r1,r5,#7              ;498
0000b8  7541              STRB     r1,[r0,#0x15]         ;498
0000ba  0971              LSRS     r1,r6,#5              ;502
0000bc  7581              STRB     r1,[r0,#0x16]         ;502
0000be  f3c60182          UBFX     r1,r6,#2,#3           ;503
0000c2  75c1              STRB     r1,[r0,#0x17]         ;503
0000c4  07b1              LSLS     r1,r6,#30             ;504
0000c6  0f49              LSRS     r1,r1,#29             ;504
0000c8  7601              STRB     r1,[r0,#0x18]         ;504
0000ca  7e02              LDRB     r2,[r0,#0x18]         ;507
0000cc  4639              MOV      r1,r7                 ;504
0000ce  ea4212d1          ORR      r2,r2,r1,LSR #7       ;507
0000d2  7602              STRB     r2,[r0,#0x18]         ;507
0000d4  6903              LDR      r3,[r0,#0x10]         ;509
0000d6  7e02              LDRB     r2,[r0,#0x18]         ;510
0000d8  1c5b              ADDS     r3,r3,#1              ;509
0000da  1c92              ADDS     r2,r2,#2              ;510
0000dc  7a05              LDRB     r5,[r0,#8]            ;511
0000de  4093              LSLS     r3,r3,r2              ;510
0000e0  fa09f205          LSL      r2,r9,r5              ;511
0000e4  4353              MULS     r3,r2,r3              ;512
0000e6  e9c03211          STRD     r3,r2,[r0,#0x44]      ;512
0000ea  e011              B        |L35.272|
                  |L35.236|
;;;515      {
;;;516        // Byte 7 //
;;;517        tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
;;;518        cardinfo->SD_csd.DeviceSize = (tmp & 0x3F) << 16;
0000ec  0691              LSLS     r1,r2,#26
0000ee  0a89              LSRS     r1,r1,#10
0000f0  6101              STR      r1,[r0,#0x10]
;;;519    
;;;520        // Byte 8 //
;;;521        tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
;;;522    
;;;523        cardinfo->SD_csd.DeviceSize |= (tmp << 8);
0000f2  6901              LDR      r1,[r0,#0x10]
0000f4  ea412105          ORR      r1,r1,r5,LSL #8
0000f8  6101              STR      r1,[r0,#0x10]
;;;524    
;;;525        // Byte 9 //
;;;526        tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
;;;527    
;;;528        cardinfo->SD_csd.DeviceSize |= (tmp);
0000fa  6901              LDR      r1,[r0,#0x10]
0000fc  4331              ORRS     r1,r1,r6
0000fe  6101              STR      r1,[r0,#0x10]
;;;529    
;;;530        // Byte 10 //
;;;531        tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
;;;532        
;;;533        cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) * 512 * 1024;
000100  6902              LDR      r2,[r0,#0x10]
000102  4639              MOV      r1,r7                 ;528
000104  1c52              ADDS     r2,r2,#1
000106  04d2              LSLS     r2,r2,#19
;;;534        cardinfo->CardBlockSize = 512;    
000108  6442              STR      r2,[r0,#0x44]
00010a  f44f7200          MOV      r2,#0x200
00010e  6482              STR      r2,[r0,#0x48]
                  |L35.272|
;;;535      }
;;;536    
;;;537    
;;;538      cardinfo->SD_csd.EraseGrSize = (tmp & 0x40) >> 6;
000110  f1000018          ADD      r0,r0,#0x18
000114  f3c11280          UBFX     r2,r1,#6,#1
000118  7042              STRB     r2,[r0,#1]
;;;539      cardinfo->SD_csd.EraseGrMul = (tmp & 0x3F) << 1;
00011a  ea4f6181          LSL      r1,r1,#26
00011e  ea4f6151          LSR      r1,r1,#25
000122  7081              STRB     r1,[r0,#2]
;;;540    
;;;541      // Byte 11 //
;;;542      tmp = (uint8_t)(CSD_Tab[2] & 0x000000FF);
;;;543      cardinfo->SD_csd.EraseGrMul |= (tmp & 0x80) >> 7;
000124  7883              LDRB     r3,[r0,#2]
000126  b2e1              UXTB     r1,r4                 ;542
000128  ea4313d1          ORR      r3,r3,r1,LSR #7
00012c  7083              STRB     r3,[r0,#2]
;;;544      cardinfo->SD_csd.WrProtectGrSize = (tmp & 0x7F);
00012e  f001017f          AND      r1,r1,#0x7f
000132  70c1              STRB     r1,[r0,#3]
;;;545    
;;;546      // Byte 12 //
;;;547      tmp = (uint8_t)((CSD_Tab[3] & 0xFF000000) >> 24);
000134  f8da200c          LDR      r2,[r10,#0xc]  ; CSD_Tab
000138  ea4f6112          LSR      r1,r2,#24
;;;548      cardinfo->SD_csd.WrProtectGrEnable = (tmp & 0x80) >> 7;
00013c  ea4f13d1          LSR      r3,r1,#7
000140  7103              STRB     r3,[r0,#4]
;;;549      cardinfo->SD_csd.ManDeflECC = (tmp & 0x60) >> 5;
000142  f3c11341          UBFX     r3,r1,#5,#2
000146  7143              STRB     r3,[r0,#5]
;;;550      cardinfo->SD_csd.WrSpeedFact = (tmp & 0x1C) >> 2;
000148  f3c10382          UBFX     r3,r1,#2,#3
00014c  7183              STRB     r3,[r0,#6]
;;;551      cardinfo->SD_csd.MaxWrBlockLen = (tmp & 0x03) << 2;
00014e  ea4f7181          LSL      r1,r1,#30
000152  ea4f7111          LSR      r1,r1,#28
000156  71c1              STRB     r1,[r0,#7]
;;;552    
;;;553      // Byte 13 //
;;;554      tmp = (uint8_t)((CSD_Tab[3] & 0x00FF0000) >> 16);
;;;555      cardinfo->SD_csd.MaxWrBlockLen |= (tmp & 0xC0) >> 6;
000158  79c3              LDRB     r3,[r0,#7]
00015a  f3c24107          UBFX     r1,r2,#16,#8          ;554
00015e  ea431391          ORR      r3,r3,r1,LSR #6
000162  71c3              STRB     r3,[r0,#7]
;;;556      cardinfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20) >> 5;
000164  f3c11340          UBFX     r3,r1,#5,#1
000168  7203              STRB     r3,[r0,#8]
;;;557      cardinfo->SD_csd.Reserved3 = 0;
00016a  f8808009          STRB     r8,[r0,#9]
;;;558      cardinfo->SD_csd.ContentProtectAppli = (tmp & 0x01);
00016e  f0010101          AND      r1,r1,#1
000172  7281              STRB     r1,[r0,#0xa]
;;;559    
;;;560      // Byte 14 //
;;;561      tmp = (uint8_t)((CSD_Tab[3] & 0x0000FF00) >> 8);
000174  f3c22107          UBFX     r1,r2,#8,#8
;;;562      cardinfo->SD_csd.FileFormatGrouop = (tmp & 0x80) >> 7;
000178  ea4f13d1          LSR      r3,r1,#7
00017c  72c3              STRB     r3,[r0,#0xb]
;;;563      cardinfo->SD_csd.CopyFlag = (tmp & 0x40) >> 6;
00017e  f3c11380          UBFX     r3,r1,#6,#1
000182  7303              STRB     r3,[r0,#0xc]
;;;564      cardinfo->SD_csd.PermWrProtect = (tmp & 0x20) >> 5;
000184  f3c11340          UBFX     r3,r1,#5,#1
000188  7343              STRB     r3,[r0,#0xd]
;;;565      cardinfo->SD_csd.TempWrProtect = (tmp & 0x10) >> 4;
00018a  f3c11300          UBFX     r3,r1,#4,#1
00018e  7383              STRB     r3,[r0,#0xe]
;;;566      cardinfo->SD_csd.FileFormat = (tmp & 0x0C) >> 2;
000190  f3c10381          UBFX     r3,r1,#2,#2
000194  73c3              STRB     r3,[r0,#0xf]
;;;567      cardinfo->SD_csd.ECC = (tmp & 0x03);
000196  f0010103          AND      r1,r1,#3
00019a  7401              STRB     r1,[r0,#0x10]
;;;568    
;;;569      // Byte 15 //
;;;570      tmp = (uint8_t)(CSD_Tab[3] & 0x000000FF);
;;;571      cardinfo->SD_csd.CSD_CRC = (tmp & 0xFE) >> 1;
00019c  f3c20146          UBFX     r1,r2,#1,#7
0001a0  7441              STRB     r1,[r0,#0x11]
;;;572      cardinfo->SD_csd.Reserved4 = 1;
0001a2  464b              MOV      r3,r9
0001a4  f8809012          STRB     r9,[r0,#0x12]
;;;573    
;;;574    
;;;575      // Byte 0 //
;;;576      tmp = (uint8_t)((CID_Tab[0] & 0xFF000000) >> 24);
0001a8  4a2f              LDR      r2,|L35.616|
0001aa  f1020210          ADD      r2,r2,#0x10
0001ae  6811              LDR      r1,[r2,#0]  ; CID_Tab
0001b0  ea4f6411          LSR      r4,r1,#24
;;;577      cardinfo->SD_cid.ManufacturerID = tmp;
0001b4  7504              STRB     r4,[r0,#0x14]
;;;578    
;;;579      // Byte 1 //
;;;580      tmp = (uint8_t)((CID_Tab[0] & 0x00FF0000) >> 16);
0001b6  f3c14407          UBFX     r4,r1,#16,#8
;;;581      cardinfo->SD_cid.OEM_AppliID = tmp << 8;
0001ba  ea4f2404          LSL      r4,r4,#8
0001be  82c4              STRH     r4,[r0,#0x16]
;;;582    
;;;583      // Byte 2 //
;;;584      tmp = (uint8_t)((CID_Tab[0] & 0x000000FF00) >> 8);
;;;585      cardinfo->SD_cid.OEM_AppliID |= tmp;
0001c0  8ac5              LDRH     r5,[r0,#0x16]
0001c2  f3c12407          UBFX     r4,r1,#8,#8           ;584
0001c6  ea450504          ORR      r5,r5,r4
0001ca  82c5              STRH     r5,[r0,#0x16]
;;;586    
;;;587      // Byte 3 //
;;;588      tmp = (uint8_t)(CID_Tab[0] & 0x000000FF);
;;;589      cardinfo->SD_cid.ProdName1 = tmp << 24;
0001cc  ea4f6101          LSL      r1,r1,#24
0001d0  6181              STR      r1,[r0,#0x18]
;;;590    
;;;591      // Byte 4 //
;;;592      tmp = (uint8_t)((CID_Tab[1] & 0xFF000000) >> 24);
0001d2  6851              LDR      r1,[r2,#4]  ; CID_Tab
;;;593      cardinfo->SD_cid.ProdName1 |= tmp << 16;
0001d4  6985              LDR      r5,[r0,#0x18]
0001d6  ea4f6411          LSR      r4,r1,#24             ;592
0001da  ea454404          ORR      r4,r5,r4,LSL #16
0001de  6184              STR      r4,[r0,#0x18]
;;;594    
;;;595      // Byte 5 //
;;;596      tmp = (uint8_t)((CID_Tab[1] & 0x00FF0000) >> 16);
;;;597      cardinfo->SD_cid.ProdName1 |= tmp << 8;
0001e0  6985              LDR      r5,[r0,#0x18]
0001e2  f3c14407          UBFX     r4,r1,#16,#8          ;596
0001e6  ea452404          ORR      r4,r5,r4,LSL #8
0001ea  6184              STR      r4,[r0,#0x18]
;;;598    
;;;599      //Byte 6 //
;;;600      tmp = (uint8_t)((CID_Tab[1] & 0x0000FF00) >> 8);
;;;601      cardinfo->SD_cid.ProdName1 |= tmp;
0001ec  6985              LDR      r5,[r0,#0x18]
0001ee  f3c12407          UBFX     r4,r1,#8,#8           ;600
0001f2  ea450504          ORR      r5,r5,r4
0001f6  6185              STR      r5,[r0,#0x18]
;;;602    
;;;603      // Byte 7 //
;;;604      tmp = (uint8_t)(CID_Tab[1] & 0x000000FF);
;;;605      cardinfo->SD_cid.ProdName2 = tmp;
0001f8  7701              STRB     r1,[r0,#0x1c]
;;;606    
;;;607      // Byte 8 //
;;;608      tmp = (uint8_t)((CID_Tab[2] & 0xFF000000) >> 24);
0001fa  6891              LDR      r1,[r2,#8]  ; CID_Tab
0001fc  ea4f6411          LSR      r4,r1,#24
;;;609      cardinfo->SD_cid.ProdRev = tmp;
000200  7744              STRB     r4,[r0,#0x1d]
;;;610    
;;;611      // Byte 9 //
;;;612      tmp = (uint8_t)((CID_Tab[2] & 0x00FF0000) >> 16);
000202  f3c14407          UBFX     r4,r1,#16,#8
;;;613      cardinfo->SD_cid.ProdSN = tmp << 24;
000206  ea4f6404          LSL      r4,r4,#24
00020a  6204              STR      r4,[r0,#0x20]
;;;614    
;;;615      // Byte 10 //
;;;616      tmp = (uint8_t)((CID_Tab[2] & 0x0000FF00) >> 8);
;;;617      cardinfo->SD_cid.ProdSN |= tmp << 16;
00020c  6a05              LDR      r5,[r0,#0x20]
00020e  f3c12407          UBFX     r4,r1,#8,#8           ;616
000212  ea454404          ORR      r4,r5,r4,LSL #16
000216  6204              STR      r4,[r0,#0x20]
;;;618    
;;;619      // Byte 11 //
;;;620      tmp = (uint8_t)(CID_Tab[2] & 0x000000FF);
;;;621      cardinfo->SD_cid.ProdSN |= tmp << 8;
000218  6a04              LDR      r4,[r0,#0x20]
00021a  b2c9              UXTB     r1,r1                 ;620
00021c  ea442101          ORR      r1,r4,r1,LSL #8
000220  6201              STR      r1,[r0,#0x20]
;;;622    
;;;623      // Byte 12 //
;;;624      tmp = (uint8_t)((CID_Tab[3] & 0xFF000000) >> 24);
;;;625      cardinfo->SD_cid.ProdSN |= tmp;
000222  68d1              LDR      r1,[r2,#0xc]  ; CID_Tab
000224  6a04              LDR      r4,[r0,#0x20]
000226  ea446411          ORR      r4,r4,r1,LSR #24
00022a  6204              STR      r4,[r0,#0x20]
;;;626    
;;;627      // Byte 13 //
;;;628      tmp = (uint8_t)((CID_Tab[3] & 0x00FF0000) >> 16);
;;;629      cardinfo->SD_cid.Reserved1 |= (tmp & 0xF0) >> 4;
00022c  f8904024          LDRB     r4,[r0,#0x24]
000230  f3c14207          UBFX     r2,r1,#16,#8          ;628
000234  ea441412          ORR      r4,r4,r2,LSR #4
000238  f8804024          STRB     r4,[r0,#0x24]
;;;630      cardinfo->SD_cid.ManufactDate = (tmp & 0x0F) << 8;
00023c  ea4f7202          LSL      r2,r2,#28
000240  ea4f5212          LSR      r2,r2,#20
000244  84c2              STRH     r2,[r0,#0x26]
;;;631    
;;;632      // Byte 14 //
;;;633      tmp = (uint8_t)((CID_Tab[3] & 0x0000FF00) >> 8);
;;;634      cardinfo->SD_cid.ManufactDate |= tmp;
000246  8cc4              LDRH     r4,[r0,#0x26]
000248  f3c12207          UBFX     r2,r1,#8,#8           ;633
00024c  ea440402          ORR      r4,r4,r2
000250  84c4              STRH     r4,[r0,#0x26]
;;;635    
;;;636      // Byte 15 
;;;637      tmp = (uint8_t)(CID_Tab[3] & 0x000000FF);
;;;638      cardinfo->SD_cid.CID_CRC = (tmp & 0xFE) >> 1;
000252  f3c10146          UBFX     r1,r1,#1,#7
000256  f8801028          STRB     r1,[r0,#0x28]
;;;639      cardinfo->SD_cid.Reserved2 = 1;
00025a  f8803029          STRB     r3,[r0,#0x29]
;;;640      
;;;641      return(errorstatus);
00025e  4660              MOV      r0,r12
;;;642    }
000260  e8bd87f0          POP      {r4-r10,pc}
;;;643    
                          ENDP

                  |L35.612|
                          DCD      ||.data||
                  |L35.616|
                          DCD      ||.bss||

                          AREA ||i.SD_GetTransferState||, CODE, READONLY, ALIGN=2

                  SD_GetTransferState PROC
;;;1752     */
;;;1753   SDTransferState SD_GetTransferState(void)
000000  4803              LDR      r0,|L36.16|
;;;1754   {
;;;1755     if (SDIO->STA & (SDIO_FLAG_TXACT | SDIO_FLAG_RXACT))
000002  6b40              LDR      r0,[r0,#0x34]
000004  f4105040          ANDS     r0,r0,#0x3000
000008  d000              BEQ      |L36.12|
;;;1756     {
;;;1757       return(SD_TRANSFER_IN_PROGRESS);
00000a  2001              MOVS     r0,#1
                  |L36.12|
;;;1758     }
;;;1759     else
;;;1760     {
;;;1761       return(SD_NO_TRANSFER);
;;;1762     }
;;;1763   }
00000c  4770              BX       lr
;;;1764   
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40018000

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=2

                  SD_Init PROC
;;;116     */
;;;117    SD_Error SD_Init(void)
000000  b538              PUSH     {r3-r5,lr}
000002  2101              MOVS     r1,#1
000004  2030              MOVS     r0,#0x30
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
00000a  f44f50f8          MOV      r0,#0x1f00
00000e  f8ad0000          STRH     r0,[sp,#0]
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
000018  2018              MOVS     r0,#0x18
00001a  f88d0003          STRB     r0,[sp,#3]
00001e  4669              MOV      r1,sp
000020  4814              LDR      r0,|L37.116|
000022  f7fffffe          BL       GPIO_Init
000026  2004              MOVS     r0,#4
000028  f8ad0000          STRH     r0,[sp,#0]
00002c  4669              MOV      r1,sp
00002e  4812              LDR      r0,|L37.120|
000030  f7fffffe          BL       GPIO_Init
;;;118    {
;;;119      SD_Error errorstatus = SD_OK;
;;;120    
;;;121      /* Configure SDIO interface GPIO */
;;;122      GPIO_Configuration();
;;;123    
;;;124      /* Enable the SDIO AHB Clock */
;;;125      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_SDIO, ENABLE);
000034  2101              MOVS     r1,#1
000036  0288              LSLS     r0,r1,#10
000038  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;126    
;;;127      /* Enable the DMA2 Clock */
;;;128      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;129    
;;;130      SDIO_DeInit();
000044  f7fffffe          BL       SDIO_DeInit
;;;131    
;;;132      errorstatus = SD_PowerON();
000048  f7fffffe          BL       SD_PowerON
;;;133    
;;;134      if (errorstatus != SD_OK)
00004c  282a              CMP      r0,#0x2a
00004e  d110              BNE      |L37.114|
;;;135      {
;;;136        /* CMD Response TimeOut (wait for CMDSENT flag) */
;;;137        return(errorstatus);
;;;138      }
;;;139    
;;;140      errorstatus = SD_InitializeCards();
000050  f7fffffe          BL       SD_InitializeCards
000054  4604              MOV      r4,r0
;;;141    
;;;142      if (errorstatus != SD_OK)
000056  282a              CMP      r0,#0x2a
000058  d10b              BNE      |L37.114|
;;;143      {
;;;144        /* CMD Response TimeOut (wait for CMDSENT flag) */
;;;145        return(errorstatus);
;;;146      }
;;;147    
;;;148      /* Configure the SDIO peripheral */
;;;149      /* HCLK = 72 MHz, SDIOCLK = 72 MHz, SDIO_CK = HCLK/(2 + 1) = 24 MHz */  
;;;150      SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV; 
00005a  4808              LDR      r0,|L37.124|
00005c  2101              MOVS     r1,#1
00005e  7501              STRB     r1,[r0,#0x14]
;;;151      SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
000060  2100              MOVS     r1,#0
;;;152      SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
000062  6001              STR      r1,[r0,#0]  ; SDIO_InitStructure
;;;153      SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
000064  6041              STR      r1,[r0,#4]  ; SDIO_InitStructure
;;;154      SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
000066  6081              STR      r1,[r0,#8]  ; SDIO_InitStructure
;;;155      SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
000068  60c1              STR      r1,[r0,#0xc]  ; SDIO_InitStructure
;;;156      SDIO_Init(&SDIO_InitStructure);
00006a  6101              STR      r1,[r0,#0x10]  ; SDIO_InitStructure
00006c  f7fffffe          BL       SDIO_Init
;;;157    
;;;158      return(errorstatus);
000070  4620              MOV      r0,r4
                  |L37.114|
;;;159    }
000072  bd38              POP      {r3-r5,pc}
;;;160    
                          ENDP

                  |L37.116|
                          DCD      0x40011000
                  |L37.120|
                          DCD      0x40011400
                  |L37.124|
                          DCD      ||.bss||+0x20

                          AREA ||i.SD_InitializeCards||, CODE, READONLY, ALIGN=2

                  SD_InitializeCards PROC
;;;339     */
;;;340    SD_Error SD_InitializeCards(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;341    {
;;;342      SD_Error errorstatus = SD_OK;
;;;343      uint16_t rca = 0x01;
000004  2001              MOVS     r0,#1
000006  242a              MOVS     r4,#0x2a              ;342
000008  f8ad0000          STRH     r0,[sp,#0]
;;;344    
;;;345      if (SDIO_GetPowerState() == SDIO_PowerState_OFF)
00000c  f7fffffe          BL       SDIO_GetPowerState
000010  b3b8              CBZ      r0,|L38.130|
;;;346      {
;;;347        errorstatus = SD_REQUEST_NOT_APPLICABLE;
;;;348        return(errorstatus);
;;;349      }
;;;350      /*如果不是SDIO卡，则发送CMD2*/
;;;351      if (SDIO_SECURE_DIGITAL_IO_CARD != CardType)
000012  f8df90ec          LDR      r9,|L38.256|
000016  f8d90004          LDR      r0,[r9,#4]  ; CardType
00001a  2804              CMP      r0,#4
00001c  d06e              BEQ      |L38.252|
;;;352      {
;;;353        /* Send CMD2 ALL_SEND_CID */
;;;354    	/*发送CMD2 要求所有牌就绪状态下的卡发送卡识别寄存器（CID）*/
;;;355    	/*参数：-【31：0】：填充位（‘0’）*/
;;;356    	/*响应类型：R2*/
;;;357        SDIO_CmdInitStructure.SDIO_Argument = 0x0;
00001e  4d39              LDR      r5,|L38.260|
;;;358        SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_ALL_SEND_CID;
;;;359        SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Long;
000020  f04f0ac0          MOV      r10,#0xc0
000024  2600              MOVS     r6,#0                 ;357
000026  2002              MOVS     r0,#2                 ;358
000028  f8c5a008          STR      r10,[r5,#8]  ; SDIO_CmdInitStructure
00002c  e9c56000          STRD     r6,r0,[r5,#0]
;;;360        SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;361        SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
000030  f44f6880          MOV      r8,#0x400
;;;362        SDIO_SendCommand(&SDIO_CmdInitStructure);
000034  e9c56803          STRD     r6,r8,[r5,#0xc]
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SDIO_SendCommand
;;;363    
;;;364        errorstatus = CmdResp2Error();
00003e  f7fffffe          BL       CmdResp2Error
000042  4604              MOV      r4,r0
;;;365    	/*命令响应超时或CRC校验失败*/
;;;366        if (SD_OK != errorstatus)
000044  282a              CMP      r0,#0x2a
000046  d11e              BNE      |L38.134|
;;;367        {
;;;368          return(errorstatus);
;;;369        }
;;;370    	/*从SDIO_RESP1..4寄存器中读取响应R2（CID寄存器）*/
;;;371        CID_Tab[0] = SDIO_GetResponse(SDIO_RESP1);
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SDIO_GetResponse
00004e  f1a50728          SUB      r7,r5,#0x28
;;;372        CID_Tab[1] = SDIO_GetResponse(SDIO_RESP2);
000052  6038              STR      r0,[r7,#0]  ; CID_Tab
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       SDIO_GetResponse
;;;373        CID_Tab[2] = SDIO_GetResponse(SDIO_RESP3);
00005a  6078              STR      r0,[r7,#4]  ; CID_Tab
00005c  2008              MOVS     r0,#8
00005e  f7fffffe          BL       SDIO_GetResponse
;;;374        CID_Tab[3] = SDIO_GetResponse(SDIO_RESP4);
000062  60b8              STR      r0,[r7,#8]  ; CID_Tab
000064  200c              MOVS     r0,#0xc
000066  f7fffffe          BL       SDIO_GetResponse
;;;375      }
;;;376      /*下面开始SD卡初始化流程*/
;;;377      if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) ||  (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) ||  (SDIO_SECURE_DIGITAL_IO_COMBO_CARD == CardType)
00006a  60f8              STR      r0,[r7,#0xc]  ; CID_Tab
00006c  f8d90004          LDR      r0,[r9,#4]  ; CardType
000070  464f              MOV      r7,r9
000072  b150              CBZ      r0,|L38.138|
000074  2801              CMP      r0,#1
000076  d008              BEQ      |L38.138|
000078  2806              CMP      r0,#6
00007a  d006              BEQ      |L38.138|
;;;378          ||  (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
00007c  2802              CMP      r0,#2
00007e  d004              BEQ      |L38.138|
000080  e015              B        |L38.174|
                  |L38.130|
000082  e7ff              B        |L38.132|
                  |L38.132|
000084  2025              MOVS     r0,#0x25              ;347
                  |L38.134|
;;;379      {
;;;380        /* Send CMD3 SET_REL_ADDR with argument 0 */
;;;381        /* 发送CMD3要求卡发布一新的相对卡地址（RCA） . */
;;;382    	/*参数：-【31：0】;填充位（‘0’）*/
;;;383    	/*响应类型：R6*/
;;;384        SDIO_CmdInitStructure.SDIO_Argument = 0x00;
;;;385        SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_REL_ADDR;
;;;386        SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;387        SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;388        SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;389        SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;390    	//把接收到的卡相对地址存起来。
;;;391        errorstatus = CmdResp6Error(SDIO_SET_REL_ADDR, &rca);
;;;392    	/*如果发生了错误，则返回错误代码*/
;;;393        if (SD_OK != errorstatus)
;;;394        {
;;;395          return(errorstatus);
;;;396        }
;;;397      }
;;;398      /*如果不是SDIO卡*/
;;;399      if (SDIO_SECURE_DIGITAL_IO_CARD != CardType)
;;;400      {
;;;401        RCA = rca;
;;;402    
;;;403        /* Send CMD9 SEND_CSD with argument as card's RCA */
;;;404    	/*DMD9:SEND_CSD*/
;;;405    	/*发送CMD9要求被寻址的卡发送卡特定数据寄存器（CSD）*/
;;;406    	/*参数：-【31：16】;相对卡地址RCA   -【15：0】;填充位（‘0’）*/
;;;407    	/*响应类型：R2*/
;;;408        SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)(rca << 16);
;;;409        SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_CSD;
;;;410        SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Long;
;;;411        SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;412        SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;413        SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;414    	/*在之前发送DMD2时，已经分析过*/
;;;415        errorstatus = CmdResp2Error();
;;;416    
;;;417        if (SD_OK != errorstatus)
;;;418        {
;;;419          return(errorstatus);
;;;420        }
;;;421        /*从SDIO_RESP1..4寄存器中读取响应R2（CSD寄存器）*/
;;;422        CSD_Tab[0] = SDIO_GetResponse(SDIO_RESP1);
;;;423        CSD_Tab[1] = SDIO_GetResponse(SDIO_RESP2);
;;;424        CSD_Tab[2] = SDIO_GetResponse(SDIO_RESP3);
;;;425        CSD_Tab[3] = SDIO_GetResponse(SDIO_RESP4);
;;;426      }
;;;427      /*卡识别结束，返回SD_OK*/
;;;428      errorstatus = SD_OK; /* All cards get intialized */
;;;429    
;;;430      return(errorstatus);
;;;431    }
000086  e8bd8ff8          POP      {r3-r11,pc}
                  |L38.138|
00008a  2003              MOVS     r0,#3                 ;385
00008c  e9c56000          STRD     r6,r0,[r5,#0]         ;385
000090  f1050108          ADD      r1,r5,#8              ;386
000094  2040              MOVS     r0,#0x40              ;386
000096  e8a10141          STM      r1!,{r0,r6,r8}        ;386
00009a  481a              LDR      r0,|L38.260|
00009c  f7fffffe          BL       SDIO_SendCommand
0000a0  4669              MOV      r1,sp                 ;391
0000a2  2003              MOVS     r0,#3                 ;391
0000a4  f7fffffe          BL       CmdResp6Error
0000a8  4604              MOV      r4,r0                 ;391
0000aa  282a              CMP      r0,#0x2a              ;393
0000ac  d1eb              BNE      |L38.134|
                  |L38.174|
0000ae  6878              LDR      r0,[r7,#4]            ;399  ; CardType
0000b0  2804              CMP      r0,#4                 ;399
0000b2  d023              BEQ      |L38.252|
0000b4  f8bd0000          LDRH     r0,[sp,#0]            ;401
0000b8  60b8              STR      r0,[r7,#8]            ;408  ; RCA
0000ba  0400              LSLS     r0,r0,#16             ;408
0000bc  6028              STR      r0,[r5,#0]            ;409  ; SDIO_CmdInitStructure
0000be  2009              MOVS     r0,#9                 ;409
0000c0  e9c50a01          STRD     r0,r10,[r5,#4]        ;409
0000c4  e9c56803          STRD     r6,r8,[r5,#0xc]       ;409
0000c8  480e              LDR      r0,|L38.260|
0000ca  f7fffffe          BL       SDIO_SendCommand
0000ce  f7fffffe          BL       CmdResp2Error
0000d2  4604              MOV      r4,r0                 ;415
0000d4  282a              CMP      r0,#0x2a              ;417
0000d6  d1d6              BNE      |L38.134|
0000d8  2000              MOVS     r0,#0                 ;422
0000da  f7fffffe          BL       SDIO_GetResponse
0000de  4d09              LDR      r5,|L38.260|
0000e0  3d38              SUBS     r5,r5,#0x38           ;422
0000e2  6028              STR      r0,[r5,#0]            ;423  ; CSD_Tab
0000e4  2004              MOVS     r0,#4                 ;423
0000e6  f7fffffe          BL       SDIO_GetResponse
0000ea  6068              STR      r0,[r5,#4]            ;424  ; CSD_Tab
0000ec  2008              MOVS     r0,#8                 ;424
0000ee  f7fffffe          BL       SDIO_GetResponse
0000f2  60a8              STR      r0,[r5,#8]            ;425  ; CSD_Tab
0000f4  200c              MOVS     r0,#0xc               ;425
0000f6  f7fffffe          BL       SDIO_GetResponse
0000fa  60e8              STR      r0,[r5,#0xc]          ;425  ; CSD_Tab
                  |L38.252|
0000fc  4620              MOV      r0,r4                 ;430
0000fe  e7c2              B        |L38.134|
;;;432    
                          ENDP

                  |L38.256|
                          DCD      ||.data||
                  |L38.260|
                          DCD      ||.bss||+0x38

                          AREA ||i.SD_NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  SD_NVIC_Configuration PROC
;;;3156    */
;;;3157   void SD_NVIC_Configuration (void)
000000  b508              PUSH     {r3,lr}
;;;3158   {
;;;3159     NVIC_InitTypeDef NVIC_InitStructure;
;;;3160   
;;;3161     /* Configure the NVIC Preemption Priority Bits */
;;;3162     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;3163   
;;;3164     NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
00000a  2031              MOVS     r0,#0x31
00000c  f88d0000          STRB     r0,[sp,#0]
;;;3165     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000010  2001              MOVS     r0,#1
000012  f88d0001          STRB     r0,[sp,#1]
;;;3166     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000016  2102              MOVS     r1,#2
000018  f88d1002          STRB     r1,[sp,#2]
;;;3167     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  f88d0003          STRB     r0,[sp,#3]
;;;3168     NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;3169   }
000026  bd08              POP      {r3,pc}
;;;3170   
                          ENDP


                          AREA ||i.SD_PowerOFF||, CODE, READONLY, ALIGN=1

                  SD_PowerOFF PROC
;;;320     */
;;;321    SD_Error SD_PowerOFF(void)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323      SD_Error errorstatus = SD_OK;
000002  242a              MOVS     r4,#0x2a
;;;324    
;;;325      /* Set Power State to OFF */
;;;326      SDIO_SetPowerState(SDIO_PowerState_OFF);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       SDIO_SetPowerState
;;;327    
;;;328      return(errorstatus);
00000a  4620              MOV      r0,r4
;;;329    }
00000c  bd10              POP      {r4,pc}
;;;330    
                          ENDP


                          AREA ||i.SD_PowerON||, CODE, READONLY, ALIGN=2

                  SD_PowerON PROC
;;;168     */
;;;169    SD_Error SD_PowerON(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;170    {
;;;171      SD_Error errorstatus = SD_OK;
;;;172      uint32_t response = 0, count = 0;
000004  2700              MOVS     r7,#0
;;;173      bool validvoltage = FALSE;
;;;174      uint32_t SDType = SD_STD_CAPACITY;
;;;175    
;;;176      /* Power ON Sequence -------------------------------------------------------*/
;;;177      /* Configure the SDIO peripheral */
;;;178      SDIO_InitStructure.SDIO_ClockDiv = SDIO_INIT_CLK_DIV; /* HCLK = 72MHz, SDIOCLK = 72MHz, SDIO_CK = HCLK/(178 + 2) = 400 KHz */
000006  4875              LDR      r0,|L41.476|
000008  21b2              MOVS     r1,#0xb2
;;;179      SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising ;
00000a  46bb              MOV      r11,r7
00000c  7501              STRB     r1,[r0,#0x14]         ;178
;;;180      SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
00000e  6007              STR      r7,[r0,#0]  ; SDIO_InitStructure
;;;181      SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
000010  6047              STR      r7,[r0,#4]  ; SDIO_InitStructure
;;;182      SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
000012  6087              STR      r7,[r0,#8]  ; SDIO_InitStructure
;;;183      SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;//SDIO_HardwareFlowControl_Enable;//;
000014  60c7              STR      r7,[r0,#0xc]  ; SDIO_InitStructure
000016  463d              MOV      r5,r7                 ;172
000018  463e              MOV      r6,r7                 ;173
00001a  46b8              MOV      r8,r7                 ;174
00001c  465c              MOV      r4,r11                ;179
;;;184      SDIO_Init(&SDIO_InitStructure);
00001e  6107              STR      r7,[r0,#0x10]  ; SDIO_InitStructure
000020  f7fffffe          BL       SDIO_Init
;;;185    
;;;186      /* Set Power State to ON */
;;;187      SDIO_SetPowerState(SDIO_PowerState_ON);
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       SDIO_SetPowerState
;;;188    
;;;189      /* Enable SDIO Clock */
;;;190      SDIO_ClockCmd(ENABLE);
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       SDIO_ClockCmd
;;;191    
;;;192      /* CMD0: GO_IDLE_STATE -------------------------------------------------------*/
;;;193      /* No CMD response required */
;;;194      SDIO_CmdInitStructure.SDIO_Argument = 0x0;
000030  f8dfa1a8          LDR      r10,|L41.476|
;;;195      SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_GO_IDLE_STATE;	   //cmd0
;;;196      SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_No;	   //无响应
;;;197      SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;198      SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;		   //CPSM在开始发送数据之前等待数据传输结束
000034  f44f6180          MOV      r1,#0x400
000038  f10a0a18          ADD      r10,r10,#0x18         ;194
;;;199      SDIO_SendCommand(&SDIO_CmdInitStructure);
00003c  4650              MOV      r0,r10
00003e  f8ca4000          STR      r4,[r10,#0]           ;195  ; SDIO_CmdInitStructure
000042  f8ca4004          STR      r4,[r10,#4]           ;196  ; SDIO_CmdInitStructure
000046  f8ca4008          STR      r4,[r10,#8]           ;197  ; SDIO_CmdInitStructure
00004a  e9ca4103          STRD     r4,r1,[r10,#0xc]
00004e  f7fffffe          BL       SDIO_SendCommand
000052  f04f092a          MOV      r9,#0x2a
000056  f2427410          MOV      r4,#0x2710
00005a  e001              B        |L41.96|
                  |L41.92|
00005c  1e64              SUBS     r4,r4,#1
00005e  d025              BEQ      |L41.172|
                  |L41.96|
000060  2080              MOVS     r0,#0x80
000062  f7fffffe          BL       SDIO_GetFlagStatus
000066  2800              CMP      r0,#0
000068  d0f8              BEQ      |L41.92|
00006a  b1fc              CBZ      r4,|L41.172|
00006c  f24050ff          MOV      r0,#0x5ff
000070  f7fffffe          BL       SDIO_ClearFlag
000074  4648              MOV      r0,r9
                  |L41.118|
;;;200    
;;;201      errorstatus = CmdError();	   			//	检测是否正确接收到CMD0
;;;202    
;;;203      if (errorstatus != SD_OK)
000076  282a              CMP      r0,#0x2a
000078  d17e              BNE      |L41.376|
;;;204      {
;;;205        /* CMD Response TimeOut (wait for CMDSENT flag) */
;;;206        return(errorstatus);
;;;207      }
;;;208    
;;;209      /* CMD8: SEND_IF_COND --------------------------------------------------------*/
;;;210      /* Send CMD8 to verify SD card interface operating condition */
;;;211      /* Argument: - [31:12]: Reserved (shall be set to '0')
;;;212                   - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
;;;213                   - [7:0]: Check Pattern (recommended 0xAA) */
;;;214      /* CMD Response: R7 */
;;;215      SDIO_CmdInitStructure.SDIO_Argument = SD_CHECK_PATTERN;	  //接收到命令SD会返回这个参数
00007a  f44f71d5          MOV      r1,#0x1aa
;;;216      SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_IF_COND;	  //CMD8
00007e  f8ca1000          STR      r1,[r10,#0]  ; SDIO_CmdInitStructure
000082  2108              MOVS     r1,#8
;;;217      SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;  //r7
000084  f8ca1004          STR      r1,[r10,#4]  ; SDIO_CmdInitStructure
000088  2140              MOVS     r1,#0x40
00008a  e9ca1b02          STRD     r1,r11,[r10,#8]
;;;218      SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;			  //关闭等待
;;;219      SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;220      SDIO_SendCommand(&SDIO_CmdInitStructure);
00008e  4853              LDR      r0,|L41.476|
000090  0109              LSLS     r1,r1,#4              ;219
000092  46d1              MOV      r9,r10                ;215
000094  3018              ADDS     r0,r0,#0x18
000096  f8ca1010          STR      r1,[r10,#0x10]  ; SDIO_CmdInitStructure
00009a  f7fffffe          BL       SDIO_SendCommand
00009e  4a50              LDR      r2,|L41.480|
0000a0  242a              MOVS     r4,#0x2a
0000a2  f2427010          MOV      r0,#0x2710
0000a6  6b51              LDR      r1,[r2,#0x34]
0000a8  4692              MOV      r10,r2
0000aa  e005              B        |L41.184|
                  |L41.172|
0000ac  2003              MOVS     r0,#3
0000ae  e7e2              B        |L41.118|
                  |L41.176|
0000b0  f8da1034          LDR      r1,[r10,#0x34]
0000b4  f1a00001          SUB      r0,r0,#1
                  |L41.184|
0000b8  f0110f45          TST      r1,#0x45
0000bc  d005              BEQ      |L41.202|
0000be  b108              CBZ      r0,|L41.196|
0000c0  0748              LSLS     r0,r1,#29
0000c2  d505              BPL      |L41.208|
                  |L41.196|
0000c4  2403              MOVS     r4,#3
0000c6  2004              MOVS     r0,#4
0000c8  e006              B        |L41.216|
                  |L41.202|
0000ca  2800              CMP      r0,#0
0000cc  d1f0              BNE      |L41.176|
0000ce  e7f9              B        |L41.196|
                  |L41.208|
0000d0  0648              LSLS     r0,r1,#25
0000d2  d503              BPL      |L41.220|
0000d4  242a              MOVS     r4,#0x2a
0000d6  2040              MOVS     r0,#0x40
                  |L41.216|
0000d8  f7fffffe          BL       SDIO_ClearFlag
                  |L41.220|
;;;221    
;;;222      errorstatus = CmdResp7Error();
;;;223    
;;;224      if (errorstatus == SD_OK)
0000dc  2c2a              CMP      r4,#0x2a
0000de  d029              BEQ      |L41.308|
;;;225      {
;;;226        CardType = SDIO_STD_CAPACITY_SD_CARD_V2_0; /* SD Card 2.0 */
;;;227        SDType = SD_HIGH_CAPACITY;	 //这个变量用作acmd41的参数，用来询问是sdsc卡还是sdhc卡 
;;;228      }
;;;229      else		  //无响应，说明是1.x的或mmc的卡   
;;;230      {
;;;231        /* CMD55 */
;;;232        SDIO_CmdInitStructure.SDIO_Argument = 0x00;
0000e0  4648              MOV      r0,r9
;;;233        SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
0000e2  2137              MOVS     r1,#0x37
0000e4  e9c0b100          STRD     r11,r1,[r0,#0]
;;;234        SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
0000e8  2140              MOVS     r1,#0x40
0000ea  e9c91b02          STRD     r1,r11,[r9,#8]
;;;235        SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;236        SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;237        SDIO_SendCommand(&SDIO_CmdInitStructure);
0000ee  483b              LDR      r0,|L41.476|
0000f0  0109              LSLS     r1,r1,#4              ;236
0000f2  3018              ADDS     r0,r0,#0x18
0000f4  f8c91010          STR      r1,[r9,#0x10]  ; SDIO_CmdInitStructure
0000f8  f7fffffe          BL       SDIO_SendCommand
;;;238        errorstatus = CmdResp1Error(SDIO_APP_CMD);
0000fc  2037              MOVS     r0,#0x37
0000fe  f7fffffe          BL       CmdResp1Error
                  |L41.258|
;;;239      }
;;;240      /* CMD55 */	   
;;;241      //为什么在else里和else外面都要发送CMD55?        
;;;242      //发送cmd55，用于检测是sd卡还是mmc卡，或是不支持的卡 
;;;243      SDIO_CmdInitStructure.SDIO_Argument = 0x00;
000102  4648              MOV      r0,r9
000104  2200              MOVS     r2,#0
;;;244      SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
000106  2137              MOVS     r1,#0x37
;;;245      SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000108  e9c02100          STRD     r2,r1,[r0,#0]
00010c  46cb              MOV      r11,r9                ;243
00010e  f04f0940          MOV      r9,#0x40
000112  e9c09202          STRD     r9,r2,[r0,#8]
;;;246      SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;247      SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;248      SDIO_SendCommand(&SDIO_CmdInitStructure);
000116  4831              LDR      r0,|L41.476|
000118  f44f6180          MOV      r1,#0x400             ;247
00011c  3018              ADDS     r0,r0,#0x18
00011e  f8cb1010          STR      r1,[r11,#0x10]  ; SDIO_CmdInitStructure
000122  f7fffffe          BL       SDIO_SendCommand
;;;249      errorstatus = CmdResp1Error(SDIO_APP_CMD); //是否响应，没响应的是mmc或不支持的卡
000126  2037              MOVS     r0,#0x37
000128  f7fffffe          BL       CmdResp1Error
00012c  4604              MOV      r4,r0
;;;250    
;;;251      /* If errorstatus is Command TimeOut, it is a MMC card */
;;;252      /* If errorstatus is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
;;;253         or SD card 1.x */
;;;254     
;;;255      if (errorstatus == SD_OK)	 //响应了cmd55，是sd卡，可能为1.x,可能为2.0 
00012e  282a              CMP      r0,#0x2a
000130  d040              BEQ      |L41.436|
000132  e051              B        |L41.472|
                  |L41.308|
000134  482b              LDR      r0,|L41.484|
000136  2101              MOVS     r1,#1                 ;226
000138  f04f4880          MOV      r8,#0x40000000        ;227
00013c  6041              STR      r1,[r0,#4]            ;227  ; CardType
00013e  e7e0              B        |L41.258|
                  |L41.320|
;;;256      {
;;;257        /*下面开始循环地发送sdio支持的电压范围，循环一定次数*/
;;;258    	/* SD CARD */							 
;;;259        /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
;;;260        while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
;;;261        {
;;;262    	  //因为下面要用到ACMD41，是ACMD命令，在发送ACMD命令前都要先向卡发送CMD55   
;;;263          /* SEND CMD55 APP_CMD with RCA as 0 */
;;;264          SDIO_CmdInitStructure.SDIO_Argument = 0x00;
000140  465c              MOV      r4,r11
000142  2600              MOVS     r6,#0
;;;265          SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
000144  2037              MOVS     r0,#0x37
;;;266          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000146  f8cb9008          STR      r9,[r11,#8]  ; SDIO_CmdInitStructure
00014a  e9c46000          STRD     r6,r0,[r4,#0]
;;;267          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;268          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;269          SDIO_SendCommand(&SDIO_CmdInitStructure);
00014e  4823              LDR      r0,|L41.476|
000150  f44f6780          MOV      r7,#0x400             ;268
000154  3018              ADDS     r0,r0,#0x18
000156  e9c46703          STRD     r6,r7,[r4,#0xc]
00015a  f7fffffe          BL       SDIO_SendCommand
;;;270    
;;;271          errorstatus = CmdResp1Error(SDIO_APP_CMD);
00015e  2037              MOVS     r0,#0x37
000160  f7fffffe          BL       CmdResp1Error
;;;272    
;;;273          if (errorstatus != SD_OK)	//没响应CMD55，返回 
000164  282a              CMP      r0,#0x2a
000166  d12f              BNE      |L41.456|
;;;274          {
;;;275            return(errorstatus);
;;;276          }
;;;277    	  //acmd41，命令参数由支持的电压范围及HCS位组成，HCS位置一来区分卡是SDSc还是sdhc   
;;;278          SDIO_CmdInitStructure.SDIO_Argument = SD_VOLTAGE_WINDOW_SD | SDType;	//参数为主机可供电压范围及hcs位
000168  491f              LDR      r1,|L41.488|
00016a  ea480001          ORR      r0,r8,r1
;;;279          SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SD_APP_OP_COND;
00016e  6020              STR      r0,[r4,#0]  ; SDIO_CmdInitStructure
000170  2029              MOVS     r0,#0x29
000172  e9c40901          STRD     r0,r9,[r4,#4]
000176  e000              B        |L41.378|
                  |L41.376|
000178  e026              B        |L41.456|
                  |L41.378|
;;;280          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;281          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;282          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;283          SDIO_SendCommand(&SDIO_CmdInitStructure);
00017a  4818              LDR      r0,|L41.476|
00017c  e9c46703          STRD     r6,r7,[r4,#0xc]       ;279
000180  3018              ADDS     r0,r0,#0x18
000182  f7fffffe          BL       SDIO_SendCommand
000186  242a              MOVS     r4,#0x2a
000188  4651              MOV      r1,r10
                  |L41.394|
00018a  6b48              LDR      r0,[r1,#0x34]
00018c  f0100f45          TST      r0,#0x45
000190  d0fb              BEQ      |L41.394|
000192  0740              LSLS     r0,r0,#29
000194  d502              BPL      |L41.412|
000196  2403              MOVS     r4,#3
000198  2004              MOVS     r0,#4
00019a  e001              B        |L41.416|
                  |L41.412|
00019c  f24050ff          MOV      r0,#0x5ff
                  |L41.416|
0001a0  f7fffffe          BL       SDIO_ClearFlag
;;;284    
;;;285          errorstatus = CmdResp3Error();	//检测是否正确接收到数据
;;;286          if (errorstatus != SD_OK)
0001a4  2c2a              CMP      r4,#0x2a
0001a6  d117              BNE      |L41.472|
;;;287          {
;;;288            return(errorstatus);			//没正确接收到acmd41，出错，返回 
;;;289          }
;;;290    
;;;291          response = SDIO_GetResponse(SDIO_RESP1);
0001a8  2000              MOVS     r0,#0
0001aa  f7fffffe          BL       SDIO_GetResponse
;;;292          validvoltage = (bool) (((response >> 31) == 1) ? 1 : 0);	 //读取卡的ocr寄存器的pwr_up位，
0001ae  0fc6              LSRS     r6,r0,#31
0001b0  4607              MOV      r7,r0                 ;291
;;;293    	  															//看是否已工作在正常电压
;;;294          count++;													//计算循环次数 
0001b2  1c6d              ADDS     r5,r5,#1
                  |L41.436|
0001b4  b91e              CBNZ     r6,|L41.446|
0001b6  f64f70ff          MOV      r0,#0xffff            ;260
0001ba  4285              CMP      r5,r0                 ;260
0001bc  d3c0              BCC      |L41.320|
                  |L41.446|
;;;295        }
;;;296        if (count >= SD_MAX_VOLT_TRIAL)								//循环检测超过一定次数还没上电
0001be  f64f70ff          MOV      r0,#0xffff
0001c2  4285              CMP      r5,r0
0001c4  d302              BCC      |L41.460|
;;;297        {
;;;298          errorstatus = SD_INVALID_VOLTRANGE;						//SDIO不支持card的供电电压
0001c6  201b              MOVS     r0,#0x1b
                  |L41.456|
;;;299          return(errorstatus);
;;;300        }
;;;301    	 /*检查卡返回信息中的HCS位*/ 
;;;302        if (response &= SD_HIGH_CAPACITY)			//判断ocr中的ccs位 ，如果是sdsc卡则不执行下面的语句
;;;303        {
;;;304          CardType = SDIO_HIGH_CAPACITY_SD_CARD;   //把卡类型从初始化的sdsc型改为sdhc型
;;;305        }
;;;306    
;;;307      }/* else MMC Card */
;;;308    
;;;309      return(errorstatus);
;;;310    }
0001c8  e8bd9ff0          POP      {r4-r12,pc}
                  |L41.460|
0001cc  f0174f80          TST      r7,#0x40000000        ;302
0001d0  d002              BEQ      |L41.472|
0001d2  4804              LDR      r0,|L41.484|
0001d4  2102              MOVS     r1,#2                 ;304
0001d6  6041              STR      r1,[r0,#4]            ;304  ; CardType
                  |L41.472|
0001d8  4620              MOV      r0,r4                 ;309
0001da  e7f5              B        |L41.456|
;;;311    
                          ENDP

                  |L41.476|
                          DCD      ||.bss||+0x20
                  |L41.480|
                          DCD      0x40018000
                  |L41.484|
                          DCD      ||.data||
                  |L41.488|
                          DCD      0x80100000

                          AREA ||i.SD_ProcessIRQSrc||, CODE, READONLY, ALIGN=2

                  SD_ProcessIRQSrc PROC
;;;2081     */
;;;2082   SD_Error SD_ProcessIRQSrc(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2083   {
;;;2084     uint32_t count = 0, restwords = 0;
;;;2085     /* 如果数据传输模式为中断模式，发送/接收数据按下面if语句进行处理 */
;;;2086     if (DeviceMode == SD_INTERRUPT_MODE)
000004  4d63              LDR      r5,|L42.404|
000006  2400              MOVS     r4,#0                 ;2084
000008  68e8              LDR      r0,[r5,#0xc]  ; DeviceMode
00000a  2801              CMP      r0,#1
00000c  d140              BNE      |L42.144|
;;;2087     {
;;;2088       if (SDIO_GetITStatus(SDIO_IT_RXFIFOHF) != RESET)
00000e  03c0              LSLS     r0,r0,#15
000010  f7fffffe          BL       SDIO_GetITStatus
000014  b158              CBZ      r0,|L42.46|
                  |L42.22|
;;;2089       {
;;;2090          /* 如果接收FIFO半满：FIFO中至少还有8个字，则从接收FIFO中读出 SD_HALFFIFO (8)个字*/
;;;2091   	  for (count = 0; count < SD_HALFFIFO; count++)
;;;2092         {
;;;2093           *(DestBuffer + count) = SDIO_ReadData();
000016  f7fffffe          BL       SDIO_ReadData
00001a  6a69              LDR      r1,[r5,#0x24]  ; DestBuffer
00001c  f8410024          STR      r0,[r1,r4,LSL #2]
000020  1c64              ADDS     r4,r4,#1              ;2091
000022  2c08              CMP      r4,#8                 ;2091
000024  d3f7              BCC      |L42.22|
;;;2094         }
;;;2095         DestBuffer += SD_HALFFIFO;
000026  6a68              LDR      r0,[r5,#0x24]  ; DestBuffer
000028  3020              ADDS     r0,r0,#0x20
;;;2096         NumberOfBytes += SD_HALFFIFOBYTES;
00002a  6268              STR      r0,[r5,#0x24]  ; DestBuffer
00002c  e02d              B        |L42.138|
                  |L42.46|
;;;2097       }
;;;2098   	/* 如果发送FIFO半空：FIFO中至少还可以写入8个字 */
;;;2099       else if (SDIO_GetITStatus(SDIO_IT_TXFIFOHE) != RESET)
00002e  f44f4080          MOV      r0,#0x4000
000032  f7fffffe          BL       SDIO_GetITStatus
000036  b358              CBZ      r0,|L42.144|
;;;2100       {
;;;2101   	 /* 如果剩下的待发送的数据字节小于SD_HALFFIFOBYTES(32)个字节(8个字)，则只发送剩下的字 */
;;;2102         if ((TotalNumberOfBytes - NumberOfBytes) < SD_HALFFIFOBYTES)
000038  69e9              LDR      r1,[r5,#0x1c]  ; NumberOfBytes
00003a  6928              LDR      r0,[r5,#0x10]  ; TotalNumberOfBytes
00003c  1a41              SUBS     r1,r0,r1
00003e  2920              CMP      r1,#0x20
000040  d218              BCS      |L42.116|
;;;2103         {
;;;2104           restwords = ((TotalNumberOfBytes - NumberOfBytes) %  4 == 0) ?
000042  69e9              LDR      r1,[r5,#0x1c]  ; NumberOfBytes
000044  1a41              SUBS     r1,r0,r1
000046  0789              LSLS     r1,r1,#30
;;;2105                       ((TotalNumberOfBytes - NumberOfBytes) / 4) :
;;;2106                       ((TotalNumberOfBytes - NumberOfBytes) / 4 + 1);
000048  69e9              LDR      r1,[r5,#0x1c]  ; NumberOfBytes
00004a  eba00001          SUB      r0,r0,r1
00004e  ea4f0690          LSR      r6,r0,#2
000052  d00c              BEQ      |L42.110|
000054  1c76              ADDS     r6,r6,#1
000056  e00a              B        |L42.110|
                  |L42.88|
;;;2107   
;;;2108           for (count = 0; count < restwords;  count++, SrcBuffer++, NumberOfBytes += 4)
;;;2109           {
;;;2110             SDIO_WriteData(*SrcBuffer);
000058  6a28              LDR      r0,[r5,#0x20]  ; SrcBuffer
00005a  6800              LDR      r0,[r0,#0]
00005c  f7fffffe          BL       SDIO_WriteData
000060  6a28              LDR      r0,[r5,#0x20]         ;2108  ; SrcBuffer
000062  1c64              ADDS     r4,r4,#1              ;2108
000064  1d00              ADDS     r0,r0,#4              ;2108
000066  6228              STR      r0,[r5,#0x20]         ;2108  ; SrcBuffer
000068  69e8              LDR      r0,[r5,#0x1c]         ;2108  ; NumberOfBytes
00006a  1d00              ADDS     r0,r0,#4              ;2108
00006c  61e8              STR      r0,[r5,#0x1c]         ;2108  ; NumberOfBytes
                  |L42.110|
00006e  42b4              CMP      r4,r6                 ;2108
000070  d3f2              BCC      |L42.88|
000072  e00d              B        |L42.144|
                  |L42.116|
;;;2111           }
;;;2112         }
;;;2113   	   /* 如果剩下的待发送的数据字节大于或等于SD_HALFFIFOBYTES(32)个字节(8个字)，则发送SD_HALFFIFO(8)个字 */
;;;2114         else
;;;2115         {
;;;2116           for (count = 0; count < SD_HALFFIFO; count++)
;;;2117           {
;;;2118             SDIO_WriteData(*(SrcBuffer + count));
000074  6a28              LDR      r0,[r5,#0x20]  ; SrcBuffer
000076  f8500024          LDR      r0,[r0,r4,LSL #2]
00007a  f7fffffe          BL       SDIO_WriteData
00007e  1c64              ADDS     r4,r4,#1              ;2116
000080  2c08              CMP      r4,#8                 ;2116
000082  d3f7              BCC      |L42.116|
;;;2119           }
;;;2120   
;;;2121           SrcBuffer += SD_HALFFIFO;
000084  6a28              LDR      r0,[r5,#0x20]  ; SrcBuffer
000086  3020              ADDS     r0,r0,#0x20
000088  6228              STR      r0,[r5,#0x20]  ; SrcBuffer
                  |L42.138|
;;;2122           NumberOfBytes += SD_HALFFIFOBYTES;
00008a  69e8              LDR      r0,[r5,#0x1c]  ; NumberOfBytes
00008c  3020              ADDS     r0,r0,#0x20
00008e  61e8              STR      r0,[r5,#0x1c]  ; NumberOfBytes
                  |L42.144|
;;;2123         }
;;;2124       }
;;;2125     }
;;;2126     /* 数据传输结束 */
;;;2127     if (SDIO_GetITStatus(SDIO_IT_DATAEND) != RESET)
000090  f44f7680          MOV      r6,#0x100
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       SDIO_GetITStatus
00009a  2400              MOVS     r4,#0                 ;2084
;;;2128     {
;;;2129     /* 如果数据传输模式是中断模式，则还要检查接收FIFO中是否还有未读出的有效数据 */
;;;2130       if (DeviceMode != SD_DMA_MODE)
;;;2131       {
;;;2132   	/* 如果接收FIFO中还有未读出的有效数据，则将其读出 */
;;;2133   	  while ((SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET)  &&  (NumberOfBytes < TotalNumberOfBytes))
;;;2134         {
;;;2135           *DestBuffer = SDIO_ReadData();
;;;2136           DestBuffer++;
;;;2137           NumberOfBytes += 4;
;;;2138         }
;;;2139       }
;;;2140   	/* 停止数据传输 */
;;;2141       if (StopCondition == 1)
;;;2142       {
;;;2143         TransferError = SD_StopTransfer();
;;;2144       }
;;;2145       else
;;;2146       {
;;;2147         TransferError = SD_OK;
;;;2148       }
;;;2149       SDIO_ClearITPendingBit(SDIO_IT_DATAEND);
;;;2150       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
00009c  f24c383a          MOV      r8,#0xc33a
0000a0  b348              CBZ      r0,|L42.246|
0000a2  68e8              LDR      r0,[r5,#0xc]          ;2130  ; DeviceMode
0000a4  b190              CBZ      r0,|L42.204|
0000a6  0377              LSLS     r7,r6,#13             ;2133
                  |L42.168|
0000a8  4638              MOV      r0,r7                 ;2133
0000aa  f7fffffe          BL       SDIO_GetFlagStatus
0000ae  b168              CBZ      r0,|L42.204|
0000b0  69e8              LDR      r0,[r5,#0x1c]         ;2133  ; NumberOfBytes
0000b2  6929              LDR      r1,[r5,#0x10]         ;2133  ; TotalNumberOfBytes
0000b4  4288              CMP      r0,r1                 ;2133
0000b6  d209              BCS      |L42.204|
0000b8  f7fffffe          BL       SDIO_ReadData
0000bc  4601              MOV      r1,r0                 ;2135
0000be  6a68              LDR      r0,[r5,#0x24]         ;2135  ; DestBuffer
0000c0  c002              STM      r0!,{r1}              ;2135
0000c2  6268              STR      r0,[r5,#0x24]         ;2137  ; DestBuffer
0000c4  69e8              LDR      r0,[r5,#0x1c]         ;2137  ; NumberOfBytes
0000c6  1d00              ADDS     r0,r0,#4              ;2137
0000c8  61e8              STR      r0,[r5,#0x1c]         ;2137  ; NumberOfBytes
0000ca  e7ed              B        |L42.168|
                  |L42.204|
0000cc  6968              LDR      r0,[r5,#0x14]         ;2141  ; StopCondition
0000ce  2801              CMP      r0,#1                 ;2141
0000d0  d00e              BEQ      |L42.240|
0000d2  202a              MOVS     r0,#0x2a              ;2147
                  |L42.212|
0000d4  7028              STRB     r0,[r5,#0]            ;2147
0000d6  4630              MOV      r0,r6                 ;2149
0000d8  f7fffffe          BL       SDIO_ClearITPendingBit
0000dc  2100              MOVS     r1,#0
0000de  4640              MOV      r0,r8
0000e0  f7fffffe          BL       SDIO_ITConfig
;;;2151                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2152                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2153       TransferEnd = 1;
0000e4  2001              MOVS     r0,#1
0000e6  61a8              STR      r0,[r5,#0x18]  ; TransferEnd
;;;2154       NumberOfBytes = 0;
0000e8  61ec              STR      r4,[r5,#0x1c]  ; NumberOfBytes
;;;2155       return(TransferError);
0000ea  7828              LDRB     r0,[r5,#0]  ; TransferError
                  |L42.236|
;;;2156     }
;;;2157      /* 已发送/接收数据块，但是CRC校验失败 */
;;;2158     if (SDIO_GetITStatus(SDIO_IT_DCRCFAIL) != RESET)
;;;2159     {
;;;2160       SDIO_ClearITPendingBit(SDIO_IT_DCRCFAIL);
;;;2161       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
;;;2162                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2163                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2164       NumberOfBytes = 0;
;;;2165       TransferError = SD_DATA_CRC_FAIL;
;;;2166       return(SD_DATA_CRC_FAIL);
;;;2167     }
;;;2168     /* 数据超时 */
;;;2169     if (SDIO_GetITStatus(SDIO_IT_DTIMEOUT) != RESET)
;;;2170     {
;;;2171       SDIO_ClearITPendingBit(SDIO_IT_DTIMEOUT);
;;;2172       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
;;;2173                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2174                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2175       NumberOfBytes = 0;
;;;2176       TransferError = SD_DATA_TIMEOUT;
;;;2177       return(SD_DATA_TIMEOUT);
;;;2178     }
;;;2179     /* 接收FIFO上溢错误 */
;;;2180     if (SDIO_GetITStatus(SDIO_IT_RXOVERR) != RESET)
;;;2181     {
;;;2182       SDIO_ClearITPendingBit(SDIO_IT_RXOVERR);
;;;2183       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
;;;2184                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2185                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2186       NumberOfBytes = 0;
;;;2187       TransferError = SD_RX_OVERRUN;
;;;2188       return(SD_RX_OVERRUN);
;;;2189     }
;;;2190     /* 发送FIFO下溢错误 */
;;;2191     if (SDIO_GetITStatus(SDIO_IT_TXUNDERR) != RESET)
;;;2192     {
;;;2193       SDIO_ClearITPendingBit(SDIO_IT_TXUNDERR);
;;;2194       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
;;;2195                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2196                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2197       NumberOfBytes = 0;
;;;2198       TransferError = SD_TX_UNDERRUN;
;;;2199       return(SD_TX_UNDERRUN);
;;;2200     }
;;;2201      /* 在宽总线模式下，在所有数据线上都没有检测到起始位 */
;;;2202     if (SDIO_GetITStatus(SDIO_IT_STBITERR) != RESET)
;;;2203     {
;;;2204       SDIO_ClearITPendingBit(SDIO_IT_STBITERR);
;;;2205       SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND |
;;;2206                     SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |
;;;2207                     SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
;;;2208       NumberOfBytes = 0;
;;;2209       TransferError = SD_START_BIT_ERR;
;;;2210       return(SD_START_BIT_ERR);
;;;2211     }
;;;2212   
;;;2213     return(SD_OK);
;;;2214   }
0000ec  e8bd81f0          POP      {r4-r8,pc}
                  |L42.240|
0000f0  f7fffffe          BL       SD_StopTransfer
0000f4  e7ee              B        |L42.212|
                  |L42.246|
0000f6  2002              MOVS     r0,#2                 ;2158
0000f8  f7fffffe          BL       SDIO_GetITStatus
0000fc  b150              CBZ      r0,|L42.276|
0000fe  2002              MOVS     r0,#2                 ;2160
000100  f7fffffe          BL       SDIO_ClearITPendingBit
000104  2100              MOVS     r1,#0                 ;2161
000106  4640              MOV      r0,r8                 ;2161
000108  f7fffffe          BL       SDIO_ITConfig
00010c  61ec              STR      r4,[r5,#0x1c]         ;2164  ; NumberOfBytes
00010e  2002              MOVS     r0,#2                 ;2165
000110  7028              STRB     r0,[r5,#0]            ;2165
000112  e7eb              B        |L42.236|
                  |L42.276|
000114  2008              MOVS     r0,#8                 ;2169
000116  f7fffffe          BL       SDIO_GetITStatus
00011a  b150              CBZ      r0,|L42.306|
00011c  2008              MOVS     r0,#8                 ;2171
00011e  f7fffffe          BL       SDIO_ClearITPendingBit
000122  2100              MOVS     r1,#0                 ;2172
000124  4640              MOV      r0,r8                 ;2172
000126  f7fffffe          BL       SDIO_ITConfig
00012a  61ec              STR      r4,[r5,#0x1c]         ;2175  ; NumberOfBytes
00012c  2004              MOVS     r0,#4                 ;2176
00012e  7028              STRB     r0,[r5,#0]            ;2176
000130  e7dc              B        |L42.236|
                  |L42.306|
000132  2020              MOVS     r0,#0x20              ;2180
000134  f7fffffe          BL       SDIO_GetITStatus
000138  b150              CBZ      r0,|L42.336|
00013a  2020              MOVS     r0,#0x20              ;2182
00013c  f7fffffe          BL       SDIO_ClearITPendingBit
000140  2100              MOVS     r1,#0                 ;2183
000142  4640              MOV      r0,r8                 ;2183
000144  f7fffffe          BL       SDIO_ITConfig
000148  61ec              STR      r4,[r5,#0x1c]         ;2186  ; NumberOfBytes
00014a  2006              MOVS     r0,#6                 ;2187
00014c  7028              STRB     r0,[r5,#0]            ;2187
00014e  e7cd              B        |L42.236|
                  |L42.336|
000150  2010              MOVS     r0,#0x10              ;2191
000152  f7fffffe          BL       SDIO_GetITStatus
000156  b150              CBZ      r0,|L42.366|
000158  2010              MOVS     r0,#0x10              ;2193
00015a  f7fffffe          BL       SDIO_ClearITPendingBit
00015e  2100              MOVS     r1,#0                 ;2194
000160  4640              MOV      r0,r8                 ;2194
000162  f7fffffe          BL       SDIO_ITConfig
000166  61ec              STR      r4,[r5,#0x1c]         ;2197  ; NumberOfBytes
000168  2005              MOVS     r0,#5                 ;2198
00016a  7028              STRB     r0,[r5,#0]            ;2198
00016c  e7be              B        |L42.236|
                  |L42.366|
00016e  f44f7600          MOV      r6,#0x200             ;2202
000172  4630              MOV      r0,r6                 ;2202
000174  f7fffffe          BL       SDIO_GetITStatus
000178  b150              CBZ      r0,|L42.400|
00017a  4630              MOV      r0,r6                 ;2204
00017c  f7fffffe          BL       SDIO_ClearITPendingBit
000180  2100              MOVS     r1,#0                 ;2205
000182  4640              MOV      r0,r8                 ;2205
000184  f7fffffe          BL       SDIO_ITConfig
000188  61ec              STR      r4,[r5,#0x1c]         ;2208  ; NumberOfBytes
00018a  2007              MOVS     r0,#7                 ;2209
00018c  7028              STRB     r0,[r5,#0]            ;2209
00018e  e7ad              B        |L42.236|
                  |L42.400|
000190  202a              MOVS     r0,#0x2a              ;2213
000192  e7ab              B        |L42.236|
;;;2215   
                          ENDP

                  |L42.404|
                          DCD      ||.data||

                          AREA ||i.SD_ReadBlock||, CODE, READONLY, ALIGN=2

                  SD_ReadBlock PROC
;;;779      */
;;;780    SD_Error SD_ReadBlock(uint32_t addr, uint32_t *readbuff, uint16_t BlockSize)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;781    {
000004  4606              MOV      r6,r0
000006  000c              MOVS     r4,r1
000008  4615              MOV      r5,r2
;;;782      SD_Error errorstatus = SD_OK;
;;;783      uint32_t count = 0, *tempbuff = readbuff;
;;;784      uint8_t power = 0;
;;;785    
;;;786      if (NULL == readbuff)
00000a  d032              BEQ      |L43.114|
;;;787      {
;;;788        errorstatus = SD_INVALID_PARAMETER;
;;;789        return(errorstatus);
;;;790      }
;;;791    
;;;792      TransferError = SD_OK;
00000c  4f77              LDR      r7,|L43.492|
00000e  202a              MOVS     r0,#0x2a
000010  7038              STRB     r0,[r7,#0]
;;;793      TransferEnd = 0;
000012  f04f0a00          MOV      r10,#0
000016  f8c7a018          STR      r10,[r7,#0x18]  ; TransferEnd
;;;794      TotalNumberOfBytes = 0;
;;;795    
;;;796       /* 关闭SDIO数据通道状态机(DPSM) */
;;;797      SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
00001a  f8dfb1d8          LDR      r11,|L43.500|
00001e  4a74              LDR      r2,|L43.496|
000020  4659              MOV      r1,r11
000022  f8c7a010          STR      r10,[r7,#0x10]  ; TotalNumberOfBytes
000026  e9c12a00          STRD     r2,r10,[r1,#0]
;;;798      SDIO_DataInitStructure.SDIO_DataLength = 0;
;;;799      SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
;;;800      SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
00002a  f8cba008          STR      r10,[r11,#8]  ; SDIO_DataInitStructure
;;;801      SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
00002e  f8cba00c          STR      r10,[r11,#0xc]  ; SDIO_DataInitStructure
;;;802      SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;
000032  f8cba010          STR      r10,[r11,#0x10]  ; SDIO_DataInitStructure
;;;803      SDIO_DataConfig(&SDIO_DataInitStructure);
000036  4658              MOV      r0,r11
000038  f8cba014          STR      r10,[r11,#0x14]  ; SDIO_DataInitStructure
00003c  f7fffffe          BL       SDIO_DataConfig
;;;804      SDIO_DMACmd(DISABLE);					/* 关闭SDIO DMA请求 */
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       SDIO_DMACmd
;;;805      /* 确认卡未上锁 */
;;;806      if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       SDIO_GetResponse
00004c  0180              LSLS     r0,r0,#6
00004e  d502              BPL      |L43.86|
;;;807      {
;;;808        errorstatus = SD_LOCK_UNLOCK_FAILED;
000050  200e              MOVS     r0,#0xe
                  |L43.82|
;;;809        return(errorstatus);
;;;810      }
;;;811      /* 对于标准容量SD卡，写数据块长度由CMD16指定，而对于高容量SD卡，写数据块长度固定为512B */
;;;812      if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;813      {
;;;814        BlockSize = 512;
;;;815        addr /= 512;
;;;816      }
;;;817      if ((BlockSize > 0) && (BlockSize <= 2048) && ((BlockSize & (BlockSize - 1)) == 0))
;;;818      {
;;;819        power = convert_from_bytes_to_power_of_two(BlockSize);
;;;820    
;;;821         /* CMD16: SET_BLOCKLEN ----------------------------------------------------------*/
;;;822        /* 发送 CMD16 设置卡的数据块长度 */
;;;823        /* 参数: - [31:0]: 数据块长度 */
;;;824        /* 响应类型: R1 */
;;;825        SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
;;;826        SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
;;;827        SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;828        SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;829        SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;830        SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;831    
;;;832        errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
;;;833    
;;;834        if (SD_OK != errorstatus)
;;;835        {
;;;836          return(errorstatus);
;;;837        }
;;;838      }
;;;839      else
;;;840      {
;;;841        errorstatus = SD_INVALID_PARAMETER;
;;;842        return(errorstatus);
;;;843      }
;;;844       /* 初始化并使能SDIO数据通道状态机(DPSM) */
;;;845      SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;846      SDIO_DataInitStructure.SDIO_DataLength = BlockSize;
;;;847      /* SDIO_DataBlockSize用于设置主机数据块长度DBCKSIZE位(SDIO_DCTRL[7:4]) */
;;;848      SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) power << 4;
;;;849      SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
;;;850      SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;851      SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
;;;852      SDIO_DataConfig(&SDIO_DataInitStructure);
;;;853    
;;;854      TotalNumberOfBytes = BlockSize;
;;;855      StopCondition = 0;
;;;856      DestBuffer = readbuff;
;;;857    
;;;858      /* CMD17: READ_SINGLE_BLOCK -------------------------------------------------------*/
;;;859      /* 发送 CMD17 开始读一个数据块 */
;;;860      /* 参数: - [31:0]: 数据地址 */
;;;861      /* 响应类型: R1 */
;;;862      SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)addr;
;;;863      SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_READ_SINGLE_BLOCK;
;;;864      SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;865      SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;866      //SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_Pend;
;;;867      SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;868      SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;869    
;;;870      errorstatus = CmdResp1Error(SDIO_READ_SINGLE_BLOCK);
;;;871    
;;;872      if (errorstatus != SD_OK)
;;;873      {
;;;874        return(errorstatus);
;;;875      }
;;;876      /* 单数据块传输结束后，不需要发送停止传输命令(因为我们发送的命令就是要求卡发送一个数据块) */
;;;877      /* 数据传输模式为中断模式 -------------------------------------------------------------*/
;;;878      /* In case of single block transfer, no need of stop transfer at all.*/
;;;879      if (DeviceMode == SD_POLLING_MODE)
;;;880      {
;;;881         /* 当下列标志都不为1时，继续接收数据 */
;;;882        while (!(SDIO->STA &(SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL 
;;;883    						| SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND 
;;;884    						| SDIO_FLAG_STBITERR)))
;;;885        {
;;;886    	/* 如果接收FIFO半满：FIFO中至少还有8个字，则从接收FIFO中读出8个字*/
;;;887          if (SDIO_GetFlagStatus(SDIO_FLAG_RXFIFOHF) != RESET)
;;;888          {
;;;889            for (count = 0; count < 8; count++)
;;;890            {
;;;891    		 /* 从接收FIFO中读出1个字 */
;;;892              *(tempbuff + count) = SDIO_ReadData();
;;;893            }
;;;894            tempbuff += 8;
;;;895          }
;;;896        }
;;;897    	 /* 数据超时 */
;;;898        if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
;;;899        {
;;;900          SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
;;;901          errorstatus = SD_DATA_TIMEOUT;
;;;902          return(errorstatus);
;;;903        }
;;;904    	/* 已发送/接收数据块，但是CRC校验失败 */
;;;905        else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;906        {
;;;907          SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;908          errorstatus = SD_DATA_CRC_FAIL;
;;;909          return(errorstatus);
;;;910        }
;;;911    	/* 接收FIFO上溢错误 */
;;;912        else if (SDIO_GetFlagStatus(SDIO_FLAG_RXOVERR) != RESET)
;;;913        {
;;;914          SDIO_ClearFlag(SDIO_FLAG_RXOVERR);
;;;915          errorstatus = SD_RX_OVERRUN;
;;;916          return(errorstatus);
;;;917        }
;;;918    	/* 在宽总线模式下，在所有数据线上都没有检测到起始位 */
;;;919        else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;920        {
;;;921          SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;922          errorstatus = SD_START_BIT_ERR;
;;;923          return(errorstatus);
;;;924        }
;;;925    	 /* 如果接收FIFO中还有未读出的有效数据，则将其读出 */
;;;926        while (SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET)
;;;927        {
;;;928          *tempbuff = SDIO_ReadData();	  /* 从接收FIFO中读出1个字 */
;;;929          tempbuff++;
;;;930        }
;;;931    
;;;932        /* 清除所有静态标志 */
;;;933        SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;934      } 
;;;935      /* 数据传输模式为中断模式 -------------------------*/
;;;936      else if (DeviceMode == SD_INTERRUPT_MODE)
;;;937      {	 
;;;938      /* 使能下列中断 */
;;;939        SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_RXFIFOHF | SDIO_IT_STBITERR, ENABLE);
;;;940        while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;941        {} /* 等待数据传输结束 */
;;;942        if (TransferError != SD_OK)
;;;943        {
;;;944          return(TransferError);
;;;945        }
;;;946      }
;;;947       /* 数据传输模式为DMA模式 ------------------------*/
;;;948      else if (DeviceMode == SD_DMA_MODE)
;;;949      {
;;;950        SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
;;;951        SDIO_DMACmd(ENABLE);
;;;952        DMA_RxConfiguration(readbuff, BlockSize);
;;;953        while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET)
;;;954        {}
;;;955      }
;;;956      return(errorstatus);
;;;957    }
000052  e8bd8ff8          POP      {r3-r11,pc}
                  |L43.86|
000056  6878              LDR      r0,[r7,#4]            ;812  ; CardType
000058  46b8              MOV      r8,r7                 ;812
00005a  f44f7900          MOV      r9,#0x200             ;814
00005e  2802              CMP      r0,#2                 ;812
000060  d101              BNE      |L43.102|
000062  464d              MOV      r5,r9                 ;814
000064  0a76              LSRS     r6,r6,#9              ;815
                  |L43.102|
000066  1e68              SUBS     r0,r5,#1              ;817
000068  f5b06f00          CMP      r0,#0x800             ;817
00006c  d201              BCS      |L43.114|
00006e  4205              TST      r5,r0                 ;817
000070  d001              BEQ      |L43.118|
                  |L43.114|
000072  2026              MOVS     r0,#0x26              ;841
000074  e7ed              B        |L43.82|
                  |L43.118|
000076  4628              MOV      r0,r5                 ;819
000078  f7fffffe          BL       convert_from_bytes_to_power_of_two
00007c  9000              STR      r0,[sp,#0]            ;825
00007e  485d              LDR      r0,|L43.500|
000080  2110              MOVS     r1,#0x10              ;826
000082  3814              SUBS     r0,r0,#0x14           ;825
000084  4657              MOV      r7,r10                ;828
000086  e9c05100          STRD     r5,r1,[r0,#0]         ;826
00008a  3008              ADDS     r0,r0,#8              ;829
00008c  2140              MOVS     r1,#0x40              ;827
00008e  f44f6a80          MOV      r10,#0x400            ;829
000092  e8a00482          STM      r0!,{r1,r7,r10}       ;829
000096  4857              LDR      r0,|L43.500|
000098  3814              SUBS     r0,r0,#0x14           ;830
00009a  f7fffffe          BL       SDIO_SendCommand
00009e  2010              MOVS     r0,#0x10              ;832
0000a0  f7fffffe          BL       CmdResp1Error
0000a4  282a              CMP      r0,#0x2a              ;834
0000a6  d1d4              BNE      |L43.82|
0000a8  4658              MOV      r0,r11                ;845
0000aa  4951              LDR      r1,|L43.496|
0000ac  e9c01500          STRD     r1,r5,[r0,#0]         ;845
0000b0  9900              LDR      r1,[sp,#0]            ;848
0000b2  4850              LDR      r0,|L43.500|
0000b4  0109              LSLS     r1,r1,#4              ;848
0000b6  f8cb1008          STR      r1,[r11,#8]           ;849  ; SDIO_DataInitStructure
0000ba  2102              MOVS     r1,#2                 ;849
0000bc  e9cb1703          STRD     r1,r7,[r11,#0xc]      ;849
0000c0  2101              MOVS     r1,#1                 ;851
0000c2  f8cb1014          STR      r1,[r11,#0x14]        ;852  ; SDIO_DataInitStructure
0000c6  f7fffffe          BL       SDIO_DataConfig
0000ca  e9c85704          STRD     r5,r7,[r8,#0x10]      ;852
0000ce  4849              LDR      r0,|L43.500|
0000d0  2111              MOVS     r1,#0x11              ;863
0000d2  3814              SUBS     r0,r0,#0x14           ;862
0000d4  f8c84024          STR      r4,[r8,#0x24]         ;863  ; DestBuffer
0000d8  e9c06100          STRD     r6,r1,[r0,#0]         ;863
0000dc  3008              ADDS     r0,r0,#8              ;864
0000de  2140              MOVS     r1,#0x40              ;864
0000e0  e8a00482          STM      r0!,{r1,r7,r10}       ;864
0000e4  4843              LDR      r0,|L43.500|
0000e6  3814              SUBS     r0,r0,#0x14           ;868
0000e8  f7fffffe          BL       SDIO_SendCommand
0000ec  2011              MOVS     r0,#0x11              ;870
0000ee  f7fffffe          BL       CmdResp1Error
0000f2  4606              MOV      r6,r0                 ;870
0000f4  282a              CMP      r0,#0x2a              ;872
0000f6  d1ac              BNE      |L43.82|
0000f8  f8d8000c          LDR      r0,[r8,#0xc]          ;879  ; DeviceMode
0000fc  4647              MOV      r7,r8                 ;879
0000fe  2802              CMP      r0,#2                 ;879
000100  d011              BEQ      |L43.294|
000102  2801              CMP      r0,#1                 ;936
000104  d04e              BEQ      |L43.420|
000106  b390              CBZ      r0,|L43.366|
000108  e06d              B        |L43.486|
                  |L43.266|
00010a  4650              MOV      r0,r10                ;887
00010c  f7fffffe          BL       SDIO_GetFlagStatus
000110  b170              CBZ      r0,|L43.304|
000112  2500              MOVS     r5,#0                 ;889
                  |L43.276|
000114  f7fffffe          BL       SDIO_ReadData
000118  f8440025          STR      r0,[r4,r5,LSL #2]     ;892
00011c  1c6d              ADDS     r5,r5,#1              ;889
00011e  2d08              CMP      r5,#8                 ;889
000120  d3f8              BCC      |L43.276|
000122  3420              ADDS     r4,r4,#0x20           ;894
000124  e004              B        |L43.304|
                  |L43.294|
000126  4f34              LDR      r7,|L43.504|
000128  f44f4a00          MOV      r10,#0x8000           ;887
00012c  f240682a          MOV      r8,#0x62a             ;882
                  |L43.304|
000130  6b78              LDR      r0,[r7,#0x34]         ;882
000132  ea100f08          TST      r0,r8                 ;882
000136  d0e8              BEQ      |L43.266|
000138  2008              MOVS     r0,#8                 ;898
00013a  f7fffffe          BL       SDIO_GetFlagStatus
00013e  b120              CBZ      r0,|L43.330|
000140  2008              MOVS     r0,#8                 ;900
000142  f7fffffe          BL       SDIO_ClearFlag
000146  2004              MOVS     r0,#4                 ;901
000148  e783              B        |L43.82|
                  |L43.330|
00014a  2002              MOVS     r0,#2                 ;905
00014c  f7fffffe          BL       SDIO_GetFlagStatus
000150  b120              CBZ      r0,|L43.348|
000152  2002              MOVS     r0,#2                 ;907
000154  f7fffffe          BL       SDIO_ClearFlag
000158  2002              MOVS     r0,#2                 ;908
00015a  e77a              B        |L43.82|
                  |L43.348|
00015c  2020              MOVS     r0,#0x20              ;912
00015e  f7fffffe          BL       SDIO_GetFlagStatus
000162  b128              CBZ      r0,|L43.368|
000164  2020              MOVS     r0,#0x20              ;914
000166  f7fffffe          BL       SDIO_ClearFlag
00016a  2006              MOVS     r0,#6                 ;915
00016c  e771              B        |L43.82|
                  |L43.366|
00016e  e028              B        |L43.450|
                  |L43.368|
000170  464d              MOV      r5,r9                 ;919
000172  4648              MOV      r0,r9                 ;919
000174  f7fffffe          BL       SDIO_GetFlagStatus
000178  b140              CBZ      r0,|L43.396|
00017a  4628              MOV      r0,r5                 ;921
00017c  f7fffffe          BL       SDIO_ClearFlag
000180  2007              MOVS     r0,#7                 ;922
000182  e766              B        |L43.82|
                  |L43.388|
000184  f7fffffe          BL       SDIO_ReadData
000188  c401              STM      r4!,{r0}              ;928
00018a  e001              B        |L43.400|
                  |L43.396|
00018c  f44f1500          MOV      r5,#0x200000          ;926
                  |L43.400|
000190  4628              MOV      r0,r5                 ;926
000192  f7fffffe          BL       SDIO_GetFlagStatus
000196  2800              CMP      r0,#0                 ;926
000198  d1f4              BNE      |L43.388|
00019a  f24050ff          MOV      r0,#0x5ff             ;933
00019e  f7fffffe          BL       SDIO_ClearFlag
0001a2  e020              B        |L43.486|
                  |L43.420|
0001a4  2101              MOVS     r1,#1                 ;939
0001a6  f248302a          MOV      r0,#0x832a            ;939
0001aa  f7fffffe          BL       SDIO_ITConfig
                  |L43.430|
0001ae  69b8              LDR      r0,[r7,#0x18]         ;940  ; TransferEnd
0001b0  b910              CBNZ     r0,|L43.440|
0001b2  7838              LDRB     r0,[r7,#0]            ;940  ; TransferError
0001b4  282a              CMP      r0,#0x2a              ;940
0001b6  d0fa              BEQ      |L43.430|
                  |L43.440|
0001b8  7838              LDRB     r0,[r7,#0]            ;942  ; TransferError
0001ba  282a              CMP      r0,#0x2a              ;942
0001bc  d013              BEQ      |L43.486|
0001be  7838              LDRB     r0,[r7,#0]            ;944  ; TransferError
0001c0  e747              B        |L43.82|
                  |L43.450|
0001c2  2101              MOVS     r1,#1                 ;950
0001c4  f240302a          MOV      r0,#0x32a             ;950
0001c8  f7fffffe          BL       SDIO_ITConfig
0001cc  2001              MOVS     r0,#1                 ;951
0001ce  f7fffffe          BL       SDIO_DMACmd
0001d2  4629              MOV      r1,r5                 ;952
0001d4  4620              MOV      r0,r4                 ;952
0001d6  f7fffffe          BL       DMA_RxConfiguration
0001da  4c08              LDR      r4,|L43.508|
                  |L43.476|
0001dc  4620              MOV      r0,r4                 ;953
0001de  f7fffffe          BL       DMA_GetFlagStatus
0001e2  2800              CMP      r0,#0                 ;953
0001e4  d0fa              BEQ      |L43.476|
                  |L43.486|
0001e6  4630              MOV      r0,r6                 ;956
0001e8  e733              B        |L43.82|
;;;958    
                          ENDP

0001ea  0000              DCW      0x0000
                  |L43.492|
                          DCD      ||.data||
                  |L43.496|
                          DCD      0x000fffff
                  |L43.500|
                          DCD      ||.bss||+0x4c
                  |L43.504|
                          DCD      0x40018000
                  |L43.508|
                          DCD      0x10002000

                          AREA ||i.SD_ReadMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_ReadMultiBlocks PROC
;;;966      */
;;;967    SD_Error SD_ReadMultiBlocks(uint32_t addr, uint32_t *readbuff, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;968    {
000004  4680              MOV      r8,r0
000006  000c              MOVS     r4,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;969      SD_Error errorstatus = SD_OK;
;;;970      uint32_t count = 0, *tempbuff = readbuff;
;;;971      uint8_t power = 0;
;;;972    
;;;973      if (NULL == readbuff)
00000c  d04f              BEQ      |L44.174|
;;;974      {
;;;975        errorstatus = SD_INVALID_PARAMETER;
;;;976        return(errorstatus);
;;;977      }
;;;978    
;;;979      TransferError = SD_OK;
00000e  4d8c              LDR      r5,|L44.576|
000010  202a              MOVS     r0,#0x2a
000012  7028              STRB     r0,[r5,#0]
;;;980      TransferEnd = 0;
000014  f04f0a00          MOV      r10,#0
000018  f8c5a018          STR      r10,[r5,#0x18]  ; TransferEnd
;;;981      TotalNumberOfBytes = 0;
;;;982    
;;;983      /* 关闭SDIO数据通道状态机(DPSM) */
;;;984      SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
00001c  498a              LDR      r1,|L44.584|
00001e  4a89              LDR      r2,|L44.580|
000020  f8c5a010          STR      r10,[r5,#0x10]  ; TotalNumberOfBytes
000024  e9c12a00          STRD     r2,r10,[r1,#0]
;;;985      SDIO_DataInitStructure.SDIO_DataLength = 0;
;;;986      SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
;;;987      SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
000028  f8c1a008          STR      r10,[r1,#8]  ; SDIO_DataInitStructure
;;;988      SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
00002c  f8c1a00c          STR      r10,[r1,#0xc]  ; SDIO_DataInitStructure
;;;989      SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;
000030  f8c1a010          STR      r10,[r1,#0x10]  ; SDIO_DataInitStructure
;;;990      SDIO_DataConfig(&SDIO_DataInitStructure);
000034  4608              MOV      r0,r1
000036  f8c1a014          STR      r10,[r1,#0x14]  ; SDIO_DataInitStructure
00003a  f7fffffe          BL       SDIO_DataConfig
;;;991      SDIO_DMACmd(DISABLE);				/* 关闭SDIO DMA请求 */
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SDIO_DMACmd
;;;992       /* 确认卡未上锁 */
;;;993      if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       SDIO_GetResponse
00004a  0180              LSLS     r0,r0,#6
00004c  d502              BPL      |L44.84|
;;;994      {
;;;995        errorstatus = SD_LOCK_UNLOCK_FAILED;
00004e  200e              MOVS     r0,#0xe
                  |L44.80|
;;;996        return(errorstatus);
;;;997      }
;;;998      /* 对于标准容量SD卡，写数据块长度由CMD16指定，而对于高容量SD卡，写数据块长度固定为512B */
;;;999      if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;1000     {
;;;1001       BlockSize = 512;
;;;1002       addr /= 512;
;;;1003     }
;;;1004     /* 分别设置卡和主机的数据块长度 */
;;;1005     if ((BlockSize > 0) && (BlockSize <= 2048) && (0 == (BlockSize & (BlockSize - 1))))
;;;1006     {
;;;1007       power = convert_from_bytes_to_power_of_two(BlockSize);
;;;1008   
;;;1009       /* CMD16: SET_BLOCKLEN ----------------------------------------------------------*/
;;;1010       /* 发送 CMD16 设置卡的数据块长度 */
;;;1011       /* 参数: - [31:0]: 数据块长度 */
;;;1012       /* 响应类型: R1 */
;;;1013       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
;;;1014       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
;;;1015       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1016       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1017       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1018       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1019   
;;;1020       errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
;;;1021   
;;;1022       if (SD_OK != errorstatus)
;;;1023       {
;;;1024         return(errorstatus);
;;;1025       }
;;;1026     }
;;;1027     else
;;;1028     {
;;;1029       errorstatus = SD_INVALID_PARAMETER;
;;;1030       return(errorstatus);
;;;1031     }
;;;1032   
;;;1033     if (NumberOfBlocks > 1)
;;;1034     {
;;;1035       /* Common to all modes */
;;;1036       if (NumberOfBlocks * BlockSize > SD_MAX_DATA_LENGTH)
;;;1037       {
;;;1038         errorstatus = SD_INVALID_PARAMETER;
;;;1039         return(errorstatus);
;;;1040       }
;;;1041   
;;;1042       TotalNumberOfBytes = NumberOfBlocks * BlockSize;
;;;1043       StopCondition = 1;
;;;1044       DestBuffer = readbuff;
;;;1045   	 /* 初始化并使能SDIO数据通道状态机(DPSM) */
;;;1046       SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;1047       SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
;;;1048   	 /* SDIO_DataBlockSize用于设置主机数据块长度DBCKSIZE位(SDIO_DCTRL[7:4]) */
;;;1049       SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) power << 4;
;;;1050       SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
;;;1051       SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;1052       SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
;;;1053       SDIO_DataConfig(&SDIO_DataInitStructure);
;;;1054   
;;;1055       /* CMD18: READ_MULTIPLE_BLOCK ---------------------------------------------------*/
;;;1056       /* 发送 CMD18 开始读多个数据块 */
;;;1057       /* 参数: - [31:0]: 数据地址 */
;;;1058       /* 响应类型: R1 */
;;;1059       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)addr;
;;;1060       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_READ_MULT_BLOCK;
;;;1061       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1062       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1063       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1064       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1065   
;;;1066       errorstatus = CmdResp1Error(SDIO_READ_MULT_BLOCK);
;;;1067   
;;;1068       if (errorstatus != SD_OK)
;;;1069       {
;;;1070         return(errorstatus);
;;;1071       }
;;;1072   	 /* 数据传输模式为轮询模式 ------------------------------*/
;;;1073       if (DeviceMode == SD_POLLING_MODE)
;;;1074       {
;;;1075          /* 当下列标志都不为 1 时，继续接收数据 */
;;;1076         while (!(SDIO->STA &(SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DATAEND | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_STBITERR)))
;;;1077         {
;;;1078            /* 如果接收FIFO半满：FIFO中至少还有8个字，则从接收FIFO中读出 SD_HALFFIFO (8)个字*/
;;;1079   		if (SDIO_GetFlagStatus(SDIO_FLAG_RXFIFOHF) != RESET)
;;;1080           {
;;;1081             for (count = 0; count < SD_HALFFIFO; count++)
;;;1082             {
;;;1083               *(tempbuff + count) = SDIO_ReadData(); /* 从接收FIFO中读出1个字 */
;;;1084             }
;;;1085             tempbuff += SD_HALFFIFO;
;;;1086           }
;;;1087         }
;;;1088   	   /* 数据超时 */
;;;1089         if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
;;;1090         {
;;;1091           SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
;;;1092           errorstatus = SD_DATA_TIMEOUT;
;;;1093           return(errorstatus);
;;;1094         }
;;;1095   	   /* 已发送/接收数据块，但是CRC校验失败 */
;;;1096         else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;1097         {
;;;1098           SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;1099           errorstatus = SD_DATA_CRC_FAIL;
;;;1100           return(errorstatus);
;;;1101         }
;;;1102   	  /* 接收FIFO上溢错误 */
;;;1103         else if (SDIO_GetFlagStatus(SDIO_FLAG_RXOVERR) != RESET)
;;;1104         {
;;;1105           SDIO_ClearFlag(SDIO_FLAG_RXOVERR);
;;;1106           errorstatus = SD_RX_OVERRUN;
;;;1107           return(errorstatus);
;;;1108         }
;;;1109   	  /* 在宽总线模式下，在所有数据线上都没有检测到起始位 */
;;;1110         else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;1111         {
;;;1112           SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;1113           errorstatus = SD_START_BIT_ERR;
;;;1114           return(errorstatus);
;;;1115         }
;;;1116   	   /* 如果接收FIFO中还有未读出的有效数据，则将其读出 */
;;;1117         while (SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET)
;;;1118         {
;;;1119           *tempbuff = SDIO_ReadData();
;;;1120           tempbuff++;
;;;1121         }
;;;1122   	  /* 数据传输结束后(已接收到NumberOfBlocks * BlockSize个字节)，发送停止传输命令(CMD12) */
;;;1123         /* 我们发送的命令只是要求卡发送多个数据块，而卡不知道究竟要发送几个数据块 */
;;;1124         if (SDIO_GetFlagStatus(SDIO_FLAG_DATAEND) != RESET)
;;;1125         {
;;;1126           /* In Case Of SD-CARD Send Command STOP_TRANSMISSION */
;;;1127           if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType))
;;;1128           {
;;;1129             /* CMD12: STOP_TRANSMISSION ------------------------------------------------*/
;;;1130             /* 发送 CMD12 强制卡停止数据传输 */
;;;1131             /* 参数: - [31:0]: 填充位(‘0’) */
;;;1132             /* 响应类型: R1b(短) */
;;;1133             SDIO_CmdInitStructure.SDIO_Argument = 0x0;
;;;1134             SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_STOP_TRANSMISSION;
;;;1135             SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1136             SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1137             SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1138             SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1139   
;;;1140             errorstatus = CmdResp1Error(SDIO_STOP_TRANSMISSION);
;;;1141   
;;;1142             if (errorstatus != SD_OK)
;;;1143             {
;;;1144               return(errorstatus);
;;;1145             }
;;;1146           }
;;;1147         }
;;;1148         /* Clear all the static flags */
;;;1149         SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;1150       }
;;;1151       else if (DeviceMode == SD_INTERRUPT_MODE)
;;;1152       {
;;;1153         SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_RXFIFOHF | SDIO_IT_STBITERR, ENABLE);
;;;1154         while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1155         {}
;;;1156         if (TransferError != SD_OK)
;;;1157         {
;;;1158           return(TransferError);
;;;1159         }
;;;1160       }
;;;1161   	/* 数据传输模式为DMA模式 ------------------------------*/
;;;1162       else if (DeviceMode == SD_DMA_MODE)
;;;1163       {
;;;1164         SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
;;;1165         SDIO_DMACmd(ENABLE);
;;;1166         DMA_RxConfiguration(readbuff, (NumberOfBlocks * BlockSize));
;;;1167         while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET)
;;;1168         {}
;;;1169         while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1170         {}
;;;1171         if (TransferError != SD_OK)
;;;1172         {
;;;1173           return(TransferError);
;;;1174         }
;;;1175       }
;;;1176     }
;;;1177     return(errorstatus);
;;;1178   }
000050  e8bd8ff8          POP      {r3-r11,pc}
                  |L44.84|
000054  6868              LDR      r0,[r5,#4]            ;999  ; CardType
000056  46a9              MOV      r9,r5                 ;999
000058  2802              CMP      r0,#2                 ;999
00005a  d102              BNE      |L44.98|
00005c  0207              LSLS     r7,r0,#8              ;1001
00005e  ea4f2858          LSR      r8,r8,#9              ;1002
                  |L44.98|
000062  1e78              SUBS     r0,r7,#1              ;1005
000064  f5b06f00          CMP      r0,#0x800             ;1005
000068  d221              BCS      |L44.174|
00006a  4207              TST      r7,r0                 ;1005
00006c  d11f              BNE      |L44.174|
00006e  4638              MOV      r0,r7                 ;1007
000070  f7fffffe          BL       convert_from_bytes_to_power_of_two
000074  f8dfb1d0          LDR      r11,|L44.584|
000078  9000              STR      r0,[sp,#0]            ;1013
00007a  f1ab0b14          SUB      r11,r11,#0x14         ;1013
00007e  4658              MOV      r0,r11                ;1013
000080  2110              MOVS     r1,#0x10              ;1014
000082  e9c07100          STRD     r7,r1,[r0,#0]         ;1014
000086  2140              MOVS     r1,#0x40              ;1015
000088  e9cb1a02          STRD     r1,r10,[r11,#8]       ;1015
00008c  0109              LSLS     r1,r1,#4              ;1017
00008e  f8cb1010          STR      r1,[r11,#0x10]        ;1018  ; SDIO_CmdInitStructure
000092  f7fffffe          BL       SDIO_SendCommand
000096  2010              MOVS     r0,#0x10              ;1020
000098  f7fffffe          BL       CmdResp1Error
00009c  4605              MOV      r5,r0                 ;1020
00009e  282a              CMP      r0,#0x2a              ;1022
0000a0  d1d6              BNE      |L44.80|
0000a2  2e01              CMP      r6,#1                 ;1033
0000a4  d93c              BLS      |L44.288|
0000a6  437e              MULS     r6,r7,r6              ;1036
0000a8  f1b67f00          CMP      r6,#0x2000000         ;1036
0000ac  d301              BCC      |L44.178|
                  |L44.174|
0000ae  2026              MOVS     r0,#0x26              ;1038
0000b0  e7ce              B        |L44.80|
                  |L44.178|
0000b2  464f              MOV      r7,r9                 ;1042
0000b4  f8c94024          STR      r4,[r9,#0x24]         ;1046  ; DestBuffer
0000b8  2101              MOVS     r1,#1                 ;1043
0000ba  4863              LDR      r0,|L44.584|
0000bc  e9c76104          STRD     r6,r1,[r7,#0x10]      ;1046
0000c0  4a60              LDR      r2,|L44.580|
0000c2  e9c02600          STRD     r2,r6,[r0,#0]         ;1046
0000c6  9a00              LDR      r2,[sp,#0]            ;1049
0000c8  46d1              MOV      r9,r10                ;1051
0000ca  0112              LSLS     r2,r2,#4              ;1049
0000cc  6082              STR      r2,[r0,#8]            ;1050  ; SDIO_DataInitStructure
0000ce  2202              MOVS     r2,#2                 ;1050
0000d0  60c2              STR      r2,[r0,#0xc]          ;1051  ; SDIO_DataInitStructure
0000d2  e9c0a104          STRD     r10,r1,[r0,#0x10]     ;1051
0000d6  4655              MOV      r5,r10                ;1051
0000d8  f7fffffe          BL       SDIO_DataConfig
0000dc  4641              MOV      r1,r8                 ;1059
0000de  f8cb1000          STR      r1,[r11,#0]           ;1060  ; SDIO_CmdInitStructure
0000e2  4658              MOV      r0,r11                ;1059
0000e4  46d8              MOV      r8,r11                ;1059
0000e6  2112              MOVS     r1,#0x12              ;1060
0000e8  f04f0b40          MOV      r11,#0x40             ;1061
0000ec  60c5              STR      r5,[r0,#0xc]          ;1062  ; SDIO_CmdInitStructure
0000ee  e9c01b01          STRD     r1,r11,[r0,#4]        ;1062
0000f2  4855              LDR      r0,|L44.584|
0000f4  f44f6a80          MOV      r10,#0x400            ;1063
0000f8  3814              SUBS     r0,r0,#0x14           ;1064
0000fa  f8c8a010          STR      r10,[r8,#0x10]        ;1064  ; SDIO_CmdInitStructure
0000fe  f7fffffe          BL       SDIO_SendCommand
000102  2012              MOVS     r0,#0x12              ;1066
000104  f7fffffe          BL       CmdResp1Error
000108  4605              MOV      r5,r0                 ;1066
00010a  282a              CMP      r0,#0x2a              ;1068
00010c  d1a0              BNE      |L44.80|
00010e  68f9              LDR      r1,[r7,#0xc]          ;1073  ; DeviceMode
000110  f240302a          MOV      r0,#0x32a             ;1076
000114  2902              CMP      r1,#2                 ;1073
000116  d012              BEQ      |L44.318|
000118  2901              CMP      r1,#1                 ;1151
00011a  d067              BEQ      |L44.492|
00011c  2900              CMP      r1,#0                 ;1162
00011e  d075              BEQ      |L44.524|
                  |L44.288|
000120  e08b              B        |L44.570|
                  |L44.290|
000122  f44f4000          MOV      r0,#0x8000            ;1079
000126  f7fffffe          BL       SDIO_GetFlagStatus
00012a  b140              CBZ      r0,|L44.318|
00012c  2600              MOVS     r6,#0                 ;1081
                  |L44.302|
00012e  f7fffffe          BL       SDIO_ReadData
000132  f8440026          STR      r0,[r4,r6,LSL #2]     ;1083
000136  1c76              ADDS     r6,r6,#1              ;1081
000138  2e08              CMP      r6,#8                 ;1081
00013a  d3f8              BCC      |L44.302|
00013c  3420              ADDS     r4,r4,#0x20           ;1085
                  |L44.318|
00013e  4843              LDR      r0,|L44.588|
000140  6b40              LDR      r0,[r0,#0x34]         ;1076
000142  f240312a          MOV      r1,#0x32a             ;1076
000146  4208              TST      r0,r1                 ;1076
000148  d0eb              BEQ      |L44.290|
00014a  2008              MOVS     r0,#8                 ;1089
00014c  f7fffffe          BL       SDIO_GetFlagStatus
000150  b120              CBZ      r0,|L44.348|
000152  2008              MOVS     r0,#8                 ;1091
000154  f7fffffe          BL       SDIO_ClearFlag
000158  2004              MOVS     r0,#4                 ;1092
                  |L44.346|
00015a  e779              B        |L44.80|
                  |L44.348|
00015c  2002              MOVS     r0,#2                 ;1096
00015e  f7fffffe          BL       SDIO_GetFlagStatus
000162  b120              CBZ      r0,|L44.366|
000164  2002              MOVS     r0,#2                 ;1098
000166  f7fffffe          BL       SDIO_ClearFlag
00016a  2002              MOVS     r0,#2                 ;1099
00016c  e770              B        |L44.80|
                  |L44.366|
00016e  2020              MOVS     r0,#0x20              ;1103
000170  f7fffffe          BL       SDIO_GetFlagStatus
000174  b120              CBZ      r0,|L44.384|
000176  2020              MOVS     r0,#0x20              ;1105
000178  f7fffffe          BL       SDIO_ClearFlag
00017c  2006              MOVS     r0,#6                 ;1106
00017e  e767              B        |L44.80|
                  |L44.384|
000180  f44f7600          MOV      r6,#0x200             ;1110
000184  4630              MOV      r0,r6                 ;1110
000186  f7fffffe          BL       SDIO_GetFlagStatus
00018a  b140              CBZ      r0,|L44.414|
00018c  4630              MOV      r0,r6                 ;1112
00018e  f7fffffe          BL       SDIO_ClearFlag
000192  2007              MOVS     r0,#7                 ;1113
000194  e75c              B        |L44.80|
                  |L44.406|
000196  f7fffffe          BL       SDIO_ReadData
00019a  c401              STM      r4!,{r0}              ;1119
00019c  e001              B        |L44.418|
                  |L44.414|
00019e  f44f1600          MOV      r6,#0x200000          ;1117
                  |L44.418|
0001a2  4630              MOV      r0,r6                 ;1117
0001a4  f7fffffe          BL       SDIO_GetFlagStatus
0001a8  2800              CMP      r0,#0                 ;1117
0001aa  d1f4              BNE      |L44.406|
0001ac  f44f7080          MOV      r0,#0x100             ;1124
0001b0  f7fffffe          BL       SDIO_GetFlagStatus
0001b4  b1a8              CBZ      r0,|L44.482|
0001b6  6878              LDR      r0,[r7,#4]            ;1127  ; CardType
0001b8  b118              CBZ      r0,|L44.450|
0001ba  2802              CMP      r0,#2                 ;1127
0001bc  d001              BEQ      |L44.450|
0001be  2801              CMP      r0,#1                 ;1127
0001c0  d10f              BNE      |L44.482|
                  |L44.450|
0001c2  4649              MOV      r1,r9                 ;1133
0001c4  220c              MOVS     r2,#0xc               ;1134
0001c6  e8880806          STM      r8,{r1,r2,r11}        ;1134
0001ca  481f              LDR      r0,|L44.584|
0001cc  e9c89a03          STRD     r9,r10,[r8,#0xc]      ;1138
0001d0  3814              SUBS     r0,r0,#0x14           ;1138
0001d2  f7fffffe          BL       SDIO_SendCommand
0001d6  200c              MOVS     r0,#0xc               ;1140
0001d8  f7fffffe          BL       CmdResp1Error
0001dc  4605              MOV      r5,r0                 ;1140
0001de  282a              CMP      r0,#0x2a              ;1142
0001e0  d1bb              BNE      |L44.346|
                  |L44.482|
0001e2  f24050ff          MOV      r0,#0x5ff             ;1149
0001e6  f7fffffe          BL       SDIO_ClearFlag
0001ea  e026              B        |L44.570|
                  |L44.492|
0001ec  2101              MOVS     r1,#1                 ;1153
0001ee  f248302a          MOV      r0,#0x832a            ;1153
0001f2  f7fffffe          BL       SDIO_ITConfig
                  |L44.502|
0001f6  69b8              LDR      r0,[r7,#0x18]         ;1154  ; TransferEnd
0001f8  b910              CBNZ     r0,|L44.512|
0001fa  7838              LDRB     r0,[r7,#0]            ;1154  ; TransferError
0001fc  282a              CMP      r0,#0x2a              ;1154
0001fe  d0fa              BEQ      |L44.502|
                  |L44.512|
000200  7838              LDRB     r0,[r7,#0]            ;1156  ; TransferError
000202  282a              CMP      r0,#0x2a              ;1156
000204  d019              BEQ      |L44.570|
000206  7838              LDRB     r0,[r7,#0]            ;1173  ; TransferError
000208  e722              B        |L44.80|
00020a  e7ff              B        |L44.524|
                  |L44.524|
00020c  2101              MOVS     r1,#1                 ;1164
00020e  f7fffffe          BL       SDIO_ITConfig
000212  2001              MOVS     r0,#1                 ;1165
000214  f7fffffe          BL       SDIO_DMACmd
000218  4631              MOV      r1,r6                 ;1165
00021a  4620              MOV      r0,r4                 ;1166
00021c  f7fffffe          BL       DMA_RxConfiguration
000220  4c0b              LDR      r4,|L44.592|
                  |L44.546|
000222  4620              MOV      r0,r4                 ;1167
000224  f7fffffe          BL       DMA_GetFlagStatus
000228  2800              CMP      r0,#0                 ;1167
00022a  d0fa              BEQ      |L44.546|
                  |L44.556|
00022c  69b8              LDR      r0,[r7,#0x18]         ;1169  ; TransferEnd
00022e  2800              CMP      r0,#0                 ;1169
000230  d1e6              BNE      |L44.512|
000232  7838              LDRB     r0,[r7,#0]            ;1169  ; TransferError
000234  282a              CMP      r0,#0x2a              ;1169
000236  d0f9              BEQ      |L44.556|
000238  e7e2              B        |L44.512|
                  |L44.570|
00023a  4628              MOV      r0,r5                 ;1177
00023c  e708              B        |L44.80|
;;;1179   
                          ENDP

00023e  0000              DCW      0x0000
                  |L44.576|
                          DCD      ||.data||
                  |L44.580|
                          DCD      0x000fffff
                  |L44.584|
                          DCD      ||.bss||+0x4c
                  |L44.588|
                          DCD      0x40018000
                  |L44.592|
                          DCD      0x10002000

                          AREA ||i.SD_SelectDeselect||, CODE, READONLY, ALIGN=2

                  SD_SelectDeselect PROC
;;;750     */
;;;751    SD_Error SD_SelectDeselect(uint32_t addr)
000000  4909              LDR      r1,|L45.40|
;;;752    {
000002  b510              PUSH     {r4,lr}
;;;753      SD_Error errorstatus = SD_OK;
;;;754    
;;;755      /* Send CMD7 SDIO_SEL_DESEL_CARD */
;;;756      /* CMD7: SELECT/DESELECT_CARD -----------------------------------------------------*/
;;;757      /* 发送 CMD7 选择被寻址的SD卡 */
;;;758      /* 参数: - [31:16]: 相对卡地址RCA
;;;759               - [15:0]: 填充位(‘0’) */
;;;760      /* 响应类型: R1 */
;;;761      SDIO_CmdInitStructure.SDIO_Argument =  addr;
;;;762      SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEL_DESEL_CARD;
000004  6008              STR      r0,[r1,#0]  ; SDIO_CmdInitStructure
000006  2007              MOVS     r0,#7
;;;763      SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000008  6048              STR      r0,[r1,#4]  ; SDIO_CmdInitStructure
00000a  2040              MOVS     r0,#0x40
;;;764      SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
00000c  6088              STR      r0,[r1,#8]  ; SDIO_CmdInitStructure
00000e  2000              MOVS     r0,#0
;;;765      SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
000010  60c8              STR      r0,[r1,#0xc]  ; SDIO_CmdInitStructure
000012  f44f6080          MOV      r0,#0x400
;;;766      SDIO_SendCommand(&SDIO_CmdInitStructure);
000016  6108              STR      r0,[r1,#0x10]  ; SDIO_CmdInitStructure
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       SDIO_SendCommand
;;;767    
;;;768      errorstatus = CmdResp1Error(SDIO_SEL_DESEL_CARD);
00001e  e8bd4010          POP      {r4,lr}
000022  2007              MOVS     r0,#7
000024  f7ffbffe          B.W      CmdResp1Error
;;;769    
;;;770      return(errorstatus);
;;;771    }
;;;772    
                          ENDP

                  |L45.40|
                          DCD      ||.bss||+0x38

                          AREA ||i.SD_SendSDStatus||, CODE, READONLY, ALIGN=2

                  SD_SendSDStatus PROC
;;;1944     */
;;;1945   SD_Error SD_SendSDStatus(uint32_t *psdstatus)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1946   {
000004  4604              MOV      r4,r0
;;;1947     SD_Error errorstatus = SD_OK;
;;;1948     uint32_t count = 0;
;;;1949     /* 确认SD卡未上锁 */
;;;1950     if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SDIO_GetResponse
00000c  0180              LSLS     r0,r0,#6
00000e  d502              BPL      |L46.22|
;;;1951     {
;;;1952       errorstatus = SD_LOCK_UNLOCK_FAILED;
000010  200e              MOVS     r0,#0xe
                  |L46.18|
;;;1953       return(errorstatus);
;;;1954     }
;;;1955   
;;;1956      /* 由于SD状态是通过数据线发送的，因此要设置卡和主机的数据块长度 */
;;;1957     /* CMD16: SET_BLOCKLEN ----------------------------------------------------------*/
;;;1958     /* 发送 CMD16 设置卡的数据块长度 */
;;;1959     /* 参数: - [31:0]: 数据块长度 */
;;;1960     /* 响应类型: R1 */
;;;1961     SDIO_CmdInitStructure.SDIO_Argument = 64;
;;;1962     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
;;;1963     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1964     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1965     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1966     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1967   
;;;1968     errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
;;;1969   
;;;1970     if (errorstatus != SD_OK)
;;;1971     {
;;;1972       return(errorstatus);
;;;1973     }
;;;1974   
;;;1975     /* CMD55: APP_CMD ---------------------------------*/
;;;1976     /* 必须在发送 ACMD13 之前发送 CMD55 通知卡，下面一条命令是应用特定命令 */
;;;1977     /* 参数: - [31:16]: 相对卡地址RCA 
;;;1978               - [15:0]: 保留('0') */
;;;1979     /* 响应类型: R1 */
;;;1980     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
;;;1981     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
;;;1982     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1983     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1984     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1985     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1986     errorstatus = CmdResp1Error(SDIO_APP_CMD);
;;;1987   
;;;1988     if (errorstatus != SD_OK)
;;;1989     {
;;;1990       return(errorstatus);
;;;1991     }
;;;1992      /* 主机的数据块长度在初始化DPSM时设置 */
;;;1993     /* 初始化并使能SDIO数据通道状态机(DPSM) */
;;;1994     SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;1995     SDIO_DataInitStructure.SDIO_DataLength = 64;
;;;1996     SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_64b;
;;;1997     SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
;;;1998     SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;1999     SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
;;;2000     SDIO_DataConfig(&SDIO_DataInitStructure);
;;;2001   
;;;2002     /* ACMD13: SD_STATUS --------------------------------------------------------------*/
;;;2003     /* 发送 ACMD13 要求卡发送状态寄存器(这里指SD状态，因为该命令是在紧随CMD55之后发送的) */
;;;2004     /* 参数: - [31:0]: 填充位(‘0’) */
;;;2005     /* 响应类型: R1 */
;;;2006     SDIO_CmdInitStructure.SDIO_Argument = 0;
;;;2007     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SD_APP_STAUS;
;;;2008     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;2009     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;2010     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;2011     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;2012     errorstatus = CmdResp1Error(SDIO_SD_APP_STAUS);
;;;2013   
;;;2014     if (errorstatus != SD_OK)
;;;2015     {
;;;2016       return(errorstatus);
;;;2017     }
;;;2018      /* 当下列标志都不为1时，继续接收数据 */
;;;2019     while (!(SDIO->STA &(SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR)))
;;;2020     {	/* 如果接收FIFO半满：FIFO中至少还有8个字，则从接收FIFO中读出8个字 */
;;;2021       if (SDIO_GetFlagStatus(SDIO_FLAG_RXFIFOHF) != RESET)
;;;2022       {
;;;2023         for (count = 0; count < 8; count++)
;;;2024         {
;;;2025           *(psdstatus + count) = SDIO_ReadData();
;;;2026         }
;;;2027         psdstatus += 8;
;;;2028       }
;;;2029     }
;;;2030      /* 数据超时 */ 
;;;2031     if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
;;;2032     {
;;;2033       SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
;;;2034       errorstatus = SD_DATA_TIMEOUT;
;;;2035       return(errorstatus);
;;;2036     }
;;;2037     /* 已接收数据块，但CRC校验错误 */
;;;2038     else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;2039     {
;;;2040       SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;2041       errorstatus = SD_DATA_CRC_FAIL;
;;;2042       return(errorstatus);
;;;2043     }
;;;2044      /* 接收FIFO上溢错误 */
;;;2045     else if (SDIO_GetFlagStatus(SDIO_FLAG_RXOVERR) != RESET)
;;;2046     {
;;;2047       SDIO_ClearFlag(SDIO_FLAG_RXOVERR);
;;;2048       errorstatus = SD_RX_OVERRUN;
;;;2049       return(errorstatus);
;;;2050     }
;;;2051     /* 在宽总线模式下，在所有数据线上都没有检测到起始位 */
;;;2052     else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;2053     {
;;;2054       SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;2055       errorstatus = SD_START_BIT_ERR;
;;;2056       return(errorstatus);
;;;2057     }
;;;2058     /* 接收FIFO中还有未读出的有效数据 */
;;;2059     while (SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET)
;;;2060     {
;;;2061       *psdstatus = SDIO_ReadData();
;;;2062       psdstatus++;
;;;2063     }
;;;2064   
;;;2065     /* Clear all the static status flags*/
;;;2066     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;2067     /* SD状态的数据包格式属于宽幅数据，先接收的是高字节 */
;;;2068     psdstatus -= 16;
;;;2069     for (count = 0; count < 16; count++)
;;;2070     {
;;;2071       psdstatus[count] = ((psdstatus[count] & SD_0TO7BITS) << 24) |((psdstatus[count] & SD_8TO15BITS) << 8) |
;;;2072                          ((psdstatus[count] & SD_16TO23BITS) >> 8) |((psdstatus[count] & SD_24TO31BITS) >> 24);
;;;2073     }
;;;2074     return(errorstatus);
;;;2075   }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L46.22|
000016  4e50              LDR      r6,|L46.344|
000018  2540              MOVS     r5,#0x40              ;1961
00001a  2010              MOVS     r0,#0x10              ;1962
00001c  e9c65000          STRD     r5,r0,[r6,#0]         ;1962
000020  f1060108          ADD      r1,r6,#8              ;1966
000024  2700              MOVS     r7,#0                 ;1964
000026  f44f6880          MOV      r8,#0x400             ;1965
00002a  e8a101a0          STM      r1!,{r5,r7,r8}        ;1966
00002e  4630              MOV      r0,r6                 ;1966
000030  f7fffffe          BL       SDIO_SendCommand
000034  2010              MOVS     r0,#0x10              ;1968
000036  f7fffffe          BL       CmdResp1Error
00003a  282a              CMP      r0,#0x2a              ;1970
00003c  d1e9              BNE      |L46.18|
00003e  4847              LDR      r0,|L46.348|
000040  46b9              MOV      r9,r7                 ;1983
000042  1d31              ADDS     r1,r6,#4              ;1984
000044  6880              LDR      r0,[r0,#8]            ;1980  ; RCA
000046  4647              MOV      r7,r8                 ;1984
000048  0400              LSLS     r0,r0,#16             ;1980
00004a  6030              STR      r0,[r6,#0]            ;1981  ; SDIO_CmdInitStructure
00004c  2037              MOVS     r0,#0x37              ;1981
00004e  f8c68010          STR      r8,[r6,#0x10]         ;1984  ; SDIO_CmdInitStructure
000052  e8a10221          STM      r1!,{r0,r5,r9}        ;1984
000056  4630              MOV      r0,r6                 ;1985
000058  f7fffffe          BL       SDIO_SendCommand
00005c  2037              MOVS     r0,#0x37              ;1986
00005e  f7fffffe          BL       CmdResp1Error
000062  282a              CMP      r0,#0x2a              ;1988
000064  d1d5              BNE      |L46.18|
000066  f1060014          ADD      r0,r6,#0x14           ;1994
00006a  493d              LDR      r1,|L46.352|
00006c  e9c01500          STRD     r1,r5,[r0,#0]         ;1995
000070  2160              MOVS     r1,#0x60              ;1996
000072  6081              STR      r1,[r0,#8]            ;1997  ; SDIO_DataInitStructure
000074  2102              MOVS     r1,#2                 ;1997
000076  e9c01903          STRD     r1,r9,[r0,#0xc]       ;1998
00007a  46a8              MOV      r8,r5                 ;1995
00007c  2101              MOVS     r1,#1                 ;1999
00007e  464d              MOV      r5,r9                 ;1998
000080  6141              STR      r1,[r0,#0x14]         ;2000  ; SDIO_DataInitStructure
000082  f7fffffe          BL       SDIO_DataConfig
000086  200d              MOVS     r0,#0xd               ;2007
000088  f8c68008          STR      r8,[r6,#8]            ;2008  ; SDIO_CmdInitStructure
00008c  e9c65000          STRD     r5,r0,[r6,#0]         ;2008
000090  e9c65703          STRD     r5,r7,[r6,#0xc]       ;2008
000094  4630              MOV      r0,r6                 ;2011
000096  f7fffffe          BL       SDIO_SendCommand
00009a  200d              MOVS     r0,#0xd               ;2012
00009c  f7fffffe          BL       CmdResp1Error
0000a0  4606              MOV      r6,r0                 ;2012
0000a2  282a              CMP      r0,#0x2a              ;2014
0000a4  d1b5              BNE      |L46.18|
0000a6  4f2f              LDR      r7,|L46.356|
0000a8  f44f4900          MOV      r9,#0x8000            ;2021
0000ac  f240682a          MOV      r8,#0x62a             ;2019
                  |L46.176|
0000b0  6b78              LDR      r0,[r7,#0x34]         ;2019
0000b2  ea100f08          TST      r0,r8                 ;2019
0000b6  d008              BEQ      |L46.202|
0000b8  2008              MOVS     r0,#8                 ;2031
0000ba  f7fffffe          BL       SDIO_GetFlagStatus
0000be  b198              CBZ      r0,|L46.232|
0000c0  2008              MOVS     r0,#8                 ;2033
0000c2  f7fffffe          BL       SDIO_ClearFlag
0000c6  2004              MOVS     r0,#4                 ;2034
0000c8  e7a3              B        |L46.18|
                  |L46.202|
0000ca  4648              MOV      r0,r9                 ;2021
0000cc  f7fffffe          BL       SDIO_GetFlagStatus
0000d0  2800              CMP      r0,#0                 ;2021
0000d2  d0ed              BEQ      |L46.176|
0000d4  2500              MOVS     r5,#0                 ;2023
                  |L46.214|
0000d6  f7fffffe          BL       SDIO_ReadData
0000da  f8440025          STR      r0,[r4,r5,LSL #2]     ;2025
0000de  1c6d              ADDS     r5,r5,#1              ;2023
0000e0  2d08              CMP      r5,#8                 ;2023
0000e2  d3f8              BCC      |L46.214|
0000e4  3420              ADDS     r4,r4,#0x20           ;2027
0000e6  e7e3              B        |L46.176|
                  |L46.232|
0000e8  2002              MOVS     r0,#2                 ;2038
0000ea  f7fffffe          BL       SDIO_GetFlagStatus
0000ee  b120              CBZ      r0,|L46.250|
0000f0  2002              MOVS     r0,#2                 ;2040
0000f2  f7fffffe          BL       SDIO_ClearFlag
0000f6  2002              MOVS     r0,#2                 ;2041
0000f8  e78b              B        |L46.18|
                  |L46.250|
0000fa  2020              MOVS     r0,#0x20              ;2045
0000fc  f7fffffe          BL       SDIO_GetFlagStatus
000100  b120              CBZ      r0,|L46.268|
000102  2020              MOVS     r0,#0x20              ;2047
000104  f7fffffe          BL       SDIO_ClearFlag
000108  2006              MOVS     r0,#6                 ;2048
00010a  e782              B        |L46.18|
                  |L46.268|
00010c  f44f7500          MOV      r5,#0x200             ;2052
000110  4628              MOV      r0,r5                 ;2052
000112  f7fffffe          BL       SDIO_GetFlagStatus
000116  b140              CBZ      r0,|L46.298|
000118  4628              MOV      r0,r5                 ;2054
00011a  f7fffffe          BL       SDIO_ClearFlag
00011e  2007              MOVS     r0,#7                 ;2055
000120  e777              B        |L46.18|
                  |L46.290|
000122  f7fffffe          BL       SDIO_ReadData
000126  c401              STM      r4!,{r0}              ;2061
000128  e001              B        |L46.302|
                  |L46.298|
00012a  f44f1500          MOV      r5,#0x200000          ;2059
                  |L46.302|
00012e  4628              MOV      r0,r5                 ;2059
000130  f7fffffe          BL       SDIO_GetFlagStatus
000134  2800              CMP      r0,#0                 ;2059
000136  d1f4              BNE      |L46.290|
000138  f24050ff          MOV      r0,#0x5ff             ;2066
00013c  f7fffffe          BL       SDIO_ClearFlag
000140  3c40              SUBS     r4,r4,#0x40           ;2068
000142  2000              MOVS     r0,#0                 ;2069
                  |L46.324|
000144  f8541020          LDR      r1,[r4,r0,LSL #2]     ;2071
000148  ba09              REV      r1,r1                 ;2071
00014a  f8441020          STR      r1,[r4,r0,LSL #2]     ;2071
00014e  1c40              ADDS     r0,r0,#1              ;2069
000150  2810              CMP      r0,#0x10              ;2069
000152  d3f7              BCC      |L46.324|
000154  4630              MOV      r0,r6                 ;2074
000156  e75c              B        |L46.18|
;;;2076   
                          ENDP

                  |L46.344|
                          DCD      ||.bss||+0x38
                  |L46.348|
                          DCD      ||.data||
                  |L46.352|
                          DCD      0x000fffff
                  |L46.356|
                          DCD      0x40018000

                          AREA ||i.SD_SendStatus||, CODE, READONLY, ALIGN=2

                  SD_SendStatus PROC
;;;1905     */
;;;1906   SD_Error SD_SendStatus(uint32_t *pcardstatus)
000000  b570              PUSH     {r4-r6,lr}
;;;1907   {
000002  0005              MOVS     r5,r0
;;;1908     SD_Error errorstatus = SD_OK;
;;;1909   
;;;1910     if (pcardstatus == NULL)
000004  d01b              BEQ      |L47.62|
;;;1911     {
;;;1912       errorstatus = SD_INVALID_PARAMETER;
;;;1913       return(errorstatus);
;;;1914     }
;;;1915      /* CMD13: SEND_STATUS -------------------------------------------------------------*/
;;;1916     /* 发送 CMD13 要求卡发送状态寄存器(这里指卡状态，如果该命令在紧随CMD55之后发送，则为SD状态) */
;;;1917     /* 参数: - [31:16]: 相对卡地址RCA
;;;1918               - [15:0]: 填充位(‘0’) */
;;;1919     /* 响应类型: R1 */
;;;1920     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
000006  480f              LDR      r0,|L47.68|
000008  6880              LDR      r0,[r0,#8]  ; RCA
00000a  0401              LSLS     r1,r0,#16
00000c  480e              LDR      r0,|L47.72|
;;;1921     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_STATUS;
00000e  6001              STR      r1,[r0,#0]  ; SDIO_CmdInitStructure
000010  210d              MOVS     r1,#0xd
;;;1922     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
000012  6041              STR      r1,[r0,#4]  ; SDIO_CmdInitStructure
000014  2140              MOVS     r1,#0x40
;;;1923     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
000016  6081              STR      r1,[r0,#8]  ; SDIO_CmdInitStructure
000018  2100              MOVS     r1,#0
;;;1924     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
00001a  60c1              STR      r1,[r0,#0xc]  ; SDIO_CmdInitStructure
00001c  f44f6180          MOV      r1,#0x400
;;;1925     SDIO_SendCommand(&SDIO_CmdInitStructure);
000020  6101              STR      r1,[r0,#0x10]  ; SDIO_CmdInitStructure
000022  f7fffffe          BL       SDIO_SendCommand
;;;1926   
;;;1927   
;;;1928     errorstatus = CmdResp1Error(SDIO_SEND_STATUS);
000026  200d              MOVS     r0,#0xd
000028  f7fffffe          BL       CmdResp1Error
00002c  4604              MOV      r4,r0
;;;1929   
;;;1930     if (errorstatus != SD_OK)
00002e  282a              CMP      r0,#0x2a
000030  d104              BNE      |L47.60|
;;;1931     {
;;;1932       return(errorstatus);
;;;1933     }
;;;1934   
;;;1935     *pcardstatus = SDIO_GetResponse(SDIO_RESP1);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       SDIO_GetResponse
;;;1936   
;;;1937     return(errorstatus);
000038  6028              STR      r0,[r5,#0]
00003a  4620              MOV      r0,r4
                  |L47.60|
;;;1938   }
00003c  bd70              POP      {r4-r6,pc}
                  |L47.62|
00003e  2026              MOVS     r0,#0x26              ;1912
000040  bd70              POP      {r4-r6,pc}
;;;1939   
                          ENDP

000042  0000              DCW      0x0000
                  |L47.68|
                          DCD      ||.data||
                  |L47.72|
                          DCD      ||.bss||+0x38

                          AREA ||i.SD_SetDeviceMode||, CODE, READONLY, ALIGN=2

                  SD_SetDeviceMode PROC
;;;726     */
;;;727    SD_Error SD_SetDeviceMode(uint32_t Mode)
000000  212a              MOVS     r1,#0x2a
;;;728    {
;;;729      SD_Error errorstatus = SD_OK;
;;;730    
;;;731      if ((Mode == SD_DMA_MODE) || (Mode == SD_INTERRUPT_MODE) || (Mode == SD_POLLING_MODE))
000002  b130              CBZ      r0,|L48.18|
000004  2801              CMP      r0,#1
000006  d004              BEQ      |L48.18|
000008  2802              CMP      r0,#2
00000a  d002              BEQ      |L48.18|
;;;732      {
;;;733        DeviceMode = Mode;
;;;734      }
;;;735      else
;;;736      {
;;;737        errorstatus = SD_INVALID_PARAMETER;
00000c  2126              MOVS     r1,#0x26
                  |L48.14|
;;;738      }
;;;739      return(errorstatus);
00000e  4608              MOV      r0,r1
;;;740    
;;;741    }
000010  4770              BX       lr
                  |L48.18|
000012  4a01              LDR      r2,|L48.24|
000014  60d0              STR      r0,[r2,#0xc]          ;733  ; DeviceMode
000016  e7fa              B        |L48.14|
;;;742    
                          ENDP

                  |L48.24|
                          DCD      ||.data||

                          AREA ||i.SD_StopTransfer||, CODE, READONLY, ALIGN=2

                  SD_StopTransfer PROC
;;;1769     */
;;;1770   SD_Error SD_StopTransfer(void)
000000  4808              LDR      r0,|L49.36|
;;;1771   {
000002  b510              PUSH     {r4,lr}
;;;1772     SD_Error errorstatus = SD_OK;
;;;1773   
;;;1774     /* CMD12: STOP_TRANSMISSION -------------------------------------------------------*/
;;;1775     /* 发送 CMD12 强制卡停止数据传输 */
;;;1776     /* 参数: - [31:0]: 填充位(‘0’) */
;;;1777     /* 响应类型: R1b(短) */
;;;1778     SDIO_CmdInitStructure.SDIO_Argument = 0x0;
000004  2100              MOVS     r1,#0
;;;1779     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_STOP_TRANSMISSION;
000006  220c              MOVS     r2,#0xc
000008  e9c01200          STRD     r1,r2,[r0,#0]
;;;1780     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
00000c  2240              MOVS     r2,#0x40
00000e  e9c02102          STRD     r2,r1,[r0,#8]
;;;1781     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1782     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
000012  0111              LSLS     r1,r2,#4
;;;1783     SDIO_SendCommand(&SDIO_CmdInitStructure);
000014  6101              STR      r1,[r0,#0x10]  ; SDIO_CmdInitStructure
000016  f7fffffe          BL       SDIO_SendCommand
;;;1784   
;;;1785     errorstatus = CmdResp1Error(SDIO_STOP_TRANSMISSION);
00001a  e8bd4010          POP      {r4,lr}
00001e  200c              MOVS     r0,#0xc
000020  f7ffbffe          B.W      CmdResp1Error
;;;1786   
;;;1787     return(errorstatus);
;;;1788   }
;;;1789   
                          ENDP

                  |L49.36|
                          DCD      ||.bss||+0x38

                          AREA ||i.SD_WriteBlock||, CODE, READONLY, ALIGN=2

                  SD_WriteBlock PROC
;;;1186     */
;;;1187   SD_Error SD_WriteBlock(uint32_t addr, uint32_t *writebuff, uint16_t BlockSize)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1188   {
000004  4680              MOV      r8,r0
;;;1189     SD_Error errorstatus = SD_OK;
;;;1190     uint8_t  power = 0, cardstate = 0;
000006  f04f0000          MOV      r0,#0
00000a  000c              MOVS     r4,r1                 ;1188
00000c  4617              MOV      r7,r2                 ;1188
00000e  f88d0000          STRB     r0,[sp,#0]
;;;1191     uint32_t timeout = 0, bytestransferred = 0;
000012  4605              MOV      r5,r0
;;;1192     uint32_t cardstatus = 0, count = 0, restwords = 0;
;;;1193     uint32_t *tempbuff = writebuff;
;;;1194   
;;;1195     if (writebuff == NULL)
000014  d026              BEQ      |L50.100|
;;;1196     {
;;;1197       errorstatus = SD_INVALID_PARAMETER;
;;;1198       return(errorstatus);
;;;1199     }
;;;1200   
;;;1201     TransferError = SD_OK;
000016  4ea4              LDR      r6,|L50.680|
000018  212a              MOVS     r1,#0x2a
00001a  7031              STRB     r1,[r6,#0]
;;;1202     TransferEnd = 0;
00001c  61b0              STR      r0,[r6,#0x18]  ; TransferEnd
;;;1203     TotalNumberOfBytes = 0;
;;;1204     /* 关闭SDIO数据通道状态机(DPSM) */
;;;1205     SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
00001e  49a4              LDR      r1,|L50.688|
000020  4aa2              LDR      r2,|L50.684|
000022  6130              STR      r0,[r6,#0x10]  ; TotalNumberOfBytes
000024  e9c12000          STRD     r2,r0,[r1,#0]
;;;1206     SDIO_DataInitStructure.SDIO_DataLength = 0;
;;;1207     SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
;;;1208     SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
000028  6088              STR      r0,[r1,#8]  ; SDIO_DataInitStructure
;;;1209     SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
00002a  60c8              STR      r0,[r1,#0xc]  ; SDIO_DataInitStructure
;;;1210     SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;
00002c  6108              STR      r0,[r1,#0x10]  ; SDIO_DataInitStructure
;;;1211     SDIO_DataConfig(&SDIO_DataInitStructure);
00002e  6148              STR      r0,[r1,#0x14]  ; SDIO_DataInitStructure
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       SDIO_DataConfig
;;;1212     /* 关闭SDIO DMA请求 */
;;;1213     SDIO_DMACmd(DISABLE);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       SDIO_DMACmd
;;;1214     /* 确认卡未上锁 */
;;;1215     if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       SDIO_GetResponse
000042  0180              LSLS     r0,r0,#6
000044  d502              BPL      |L50.76|
;;;1216     {
;;;1217       errorstatus = SD_LOCK_UNLOCK_FAILED;
000046  200e              MOVS     r0,#0xe
                  |L50.72|
;;;1218       return(errorstatus);
;;;1219     }
;;;1220      /* 对于标准容量SD卡，写数据块长度由CMD16指定，而对于高容量SD卡，写数据块长度固定为512B */
;;;1221     if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;1222     {
;;;1223       BlockSize = 512;
;;;1224       addr /= 512;
;;;1225     }
;;;1226     /* 分别设置卡和主机的数据块长度 */ 
;;;1227     /* Set the block size, both on controller and card */
;;;1228     if ((BlockSize > 0) && (BlockSize <= 2048) && ((BlockSize & (BlockSize - 1)) == 0))
;;;1229     {
;;;1230       power = convert_from_bytes_to_power_of_two(BlockSize);
;;;1231   	/* CMD16: SET_BLOCKLEN ----------------------------------------------------------*/
;;;1232       /* 发送 CMD16 设置卡的数据块长度 */
;;;1233       /* 参数: - [31:0]: 数据块长度 */
;;;1234       /* 响应类型: R1 */
;;;1235       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
;;;1236       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
;;;1237       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1238       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1239       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1240       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1241   
;;;1242       errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
;;;1243   
;;;1244       if (errorstatus != SD_OK)
;;;1245       {
;;;1246         return(errorstatus);
;;;1247       }
;;;1248     }
;;;1249     else
;;;1250     {
;;;1251       errorstatus = SD_INVALID_PARAMETER;
;;;1252       return(errorstatus);
;;;1253     }
;;;1254     /* CMD13: SEND_STATUS -------------------------------------------------------------*/
;;;1255     /* 发送 CMD13 要求卡发送状态寄存器(这里指卡状态，如果该命令在紧随CMD55之后发送，则为SD状态) */
;;;1256     /* 参数: - [31:16]: 相对卡地址RCA
;;;1257              - [15:0]: 填充位(‘0’) */
;;;1258     /* 响应类型: R1 */
;;;1259     /* Wait till card is ready for data Added */
;;;1260     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
;;;1261     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_STATUS;
;;;1262     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1263     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1264     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1265     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1266   
;;;1267     errorstatus = CmdResp1Error(SDIO_SEND_STATUS);
;;;1268   
;;;1269     if (errorstatus != SD_OK)
;;;1270     {
;;;1271       return(errorstatus);
;;;1272     }
;;;1273   
;;;1274     cardstatus = SDIO_GetResponse(SDIO_RESP1);
;;;1275   
;;;1276     timeout = SD_DATATIMEOUT;
;;;1277     
;;;1278     /* 等待直到卡准备好接收数据(卡状态位READY_FOR_DATA(卡状态位9) = 1)或数据超时 */
;;;1279     while (((cardstatus & 0x00000100) == 0) && (timeout > 0))
;;;1280     {
;;;1281       timeout--;
;;;1282       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
;;;1283       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_STATUS;
;;;1284       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1285       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1286       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1287       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1288   
;;;1289       errorstatus = CmdResp1Error(SDIO_SEND_STATUS);
;;;1290   
;;;1291       if (errorstatus != SD_OK)
;;;1292       {
;;;1293         return(errorstatus);
;;;1294       }
;;;1295       cardstatus = SDIO_GetResponse(SDIO_RESP1);
;;;1296     }
;;;1297   
;;;1298     if (timeout == 0)
;;;1299     {
;;;1300       return(SD_ERROR);
;;;1301     }
;;;1302     /* CMD24: WRITE_SINGLE_BLOCK ------------------------------------------------------*/
;;;1303     /* 发送 CMD24 开始写一个数据块 */
;;;1304     /* 参数: - [31:0]: 数据地址 */
;;;1305     /* 响应类型: R1 */
;;;1306     /* Send CMD24 WRITE_SINGLE_BLOCK */
;;;1307     SDIO_CmdInitStructure.SDIO_Argument = addr;
;;;1308     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_WRITE_SINGLE_BLOCK;
;;;1309     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1310     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1311     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1312     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1313   
;;;1314     errorstatus = CmdResp1Error(SDIO_WRITE_SINGLE_BLOCK);
;;;1315   
;;;1316     if (errorstatus != SD_OK)
;;;1317     {
;;;1318       return(errorstatus);
;;;1319     }
;;;1320   
;;;1321     TotalNumberOfBytes = BlockSize;
;;;1322     StopCondition = 0;
;;;1323     SrcBuffer = writebuff;
;;;1324     /* 初始化并使能SDIO数据通道状态机(DPSM) */
;;;1325     SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;1326     SDIO_DataInitStructure.SDIO_DataLength = BlockSize;
;;;1327     /* SDIO_DataBlockSize用于设置主机数据块长度DBCKSIZE位(SDIO_DCTRL[7:4]) */
;;;1328     SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) power << 4;
;;;1329     SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
;;;1330     SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;1331     SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
;;;1332     SDIO_DataConfig(&SDIO_DataInitStructure);
;;;1333     /* 单数据块传输结束后，不需要发送停止传输命令 */
;;;1334     /* 数据传输模式为轮询模式 -------------------------------------------------------------*/
;;;1335     /* In case of single data block transfer no need of stop command at all */
;;;1336     if (DeviceMode == SD_POLLING_MODE)
;;;1337     {
;;;1338     /* 当下列标志都不为 1 时，继续发送数据 */
;;;1339       while (!(SDIO->STA & (SDIO_FLAG_DBCKEND | SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_STBITERR)))
;;;1340       {
;;;1341   	/* 如果发送FIFO半空：FIFO中至少还可以写入8个字 */
;;;1342         if (SDIO_GetFlagStatus(SDIO_FLAG_TXFIFOHE) != RESET)
;;;1343         {
;;;1344   	  /* 如果剩下的待发送的数据字节小于32个字节(8个字)，则只发送剩下的字 */
;;;1345           if ((TotalNumberOfBytes - bytestransferred) < 32)
;;;1346           {
;;;1347             restwords = ((TotalNumberOfBytes - bytestransferred) % 4 == 0) ? ((TotalNumberOfBytes - bytestransferred) / 4) : (( TotalNumberOfBytes -  bytestransferred) / 4 + 1);
;;;1348   
;;;1349             for (count = 0; count < restwords; count++, tempbuff++, bytestransferred += 4)
;;;1350             {
;;;1351                /* 向发送FIFO中写入1个字 */
;;;1352   			SDIO_WriteData(*tempbuff);
;;;1353             }
;;;1354           }
;;;1355   		 /* 如果剩下的待发送的数据字节大于或等于32个字节(8个字)，则向发送FIFO中写入8个字 */
;;;1356           else
;;;1357           {
;;;1358             for (count = 0; count < 8; count++)
;;;1359             {	 
;;;1360   		  /* 向发送FIFO中写入1个字 */
;;;1361               SDIO_WriteData(*(tempbuff + count));
;;;1362             }
;;;1363             tempbuff += 8;
;;;1364             bytestransferred += 32;
;;;1365           }
;;;1366         }
;;;1367       }
;;;1368   	 /* 数据超时 */
;;;1369       if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
;;;1370       {
;;;1371         SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
;;;1372         errorstatus = SD_DATA_TIMEOUT;
;;;1373         return(errorstatus);
;;;1374       }
;;;1375   	/* 已发送/接收数据块，但是CRC校验失败 */
;;;1376       else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;1377       {
;;;1378         SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;1379         errorstatus = SD_DATA_CRC_FAIL;
;;;1380         return(errorstatus);
;;;1381       }
;;;1382   	/* 发送FIFO下溢错误 */
;;;1383       else if (SDIO_GetFlagStatus(SDIO_FLAG_TXUNDERR) != RESET)
;;;1384       {
;;;1385         SDIO_ClearFlag(SDIO_FLAG_TXUNDERR);
;;;1386         errorstatus = SD_TX_UNDERRUN;
;;;1387         return(errorstatus);
;;;1388       }
;;;1389   	/* 在宽总线模式下，在所有数据线上都没有检测到起始位 */
;;;1390       else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;1391       {
;;;1392         SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;1393         errorstatus = SD_START_BIT_ERR;
;;;1394         return(errorstatus);
;;;1395       }
;;;1396     }
;;;1397      /* 数据传输模式为中断模式 -------------------------*/
;;;1398     else if (DeviceMode == SD_INTERRUPT_MODE)
;;;1399     {
;;;1400       /* 使能下列中断 */
;;;1401   	SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_FLAG_TXFIFOHE | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR, ENABLE);
;;;1402        /* 等待数据传输结束 */
;;;1403   	while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1404       {}
;;;1405       if (TransferError != SD_OK)
;;;1406       {
;;;1407         return(TransferError);
;;;1408       }
;;;1409     }
;;;1410     /* 数据传输模式为DMA模式 ---------------------------*/
;;;1411     else if (DeviceMode == SD_DMA_MODE)
;;;1412     {
;;;1413       /* 使能下列中断 */
;;;1414   	SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR, ENABLE);
;;;1415       /* 配置并使能SDIO DMA发送请求 */
;;;1416   	DMA_TxConfiguration(writebuff, BlockSize);
;;;1417       SDIO_DMACmd(ENABLE);
;;;1418       /* 等待数据传输结束 */
;;;1419   	while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET)
;;;1420       {}
;;;1421       while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1422       {}
;;;1423       if (TransferError != SD_OK)
;;;1424       {
;;;1425         return(TransferError);
;;;1426       }
;;;1427     }
;;;1428   
;;;1429     /* Clear all the static flags */
;;;1430     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;1431   
;;;1432     /* Wait till the card is in programming state */
;;;1433     errorstatus = IsCardProgramming(&cardstate);
;;;1434   
;;;1435     while ((errorstatus == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
;;;1436     {
;;;1437       errorstatus = IsCardProgramming(&cardstate);
;;;1438     }
;;;1439   
;;;1440     return(errorstatus);
;;;1441   }
000048  e8bd9ffc          POP      {r2-r12,pc}
                  |L50.76|
00004c  6870              LDR      r0,[r6,#4]            ;1221  ; CardType
00004e  2802              CMP      r0,#2                 ;1221
000050  d102              BNE      |L50.88|
000052  0207              LSLS     r7,r0,#8              ;1223
000054  ea4f2858          LSR      r8,r8,#9              ;1224
                  |L50.88|
000058  1e78              SUBS     r0,r7,#1              ;1228
00005a  f5b06f00          CMP      r0,#0x800             ;1228
00005e  d201              BCS      |L50.100|
000060  4207              TST      r7,r0                 ;1228
000062  d001              BEQ      |L50.104|
                  |L50.100|
000064  2026              MOVS     r0,#0x26              ;1251
                  |L50.102|
000066  e7ef              B        |L50.72|
                  |L50.104|
000068  4638              MOV      r0,r7                 ;1230
00006a  f7fffffe          BL       convert_from_bytes_to_power_of_two
00006e  f8df9240          LDR      r9,|L50.688|
000072  9001              STR      r0,[sp,#4]            ;1235
000074  f1a90914          SUB      r9,r9,#0x14           ;1235
000078  4648              MOV      r0,r9                 ;1235
00007a  2110              MOVS     r1,#0x10              ;1236
00007c  e9c07100          STRD     r7,r1,[r0,#0]         ;1237
000080  f04f0a40          MOV      r10,#0x40             ;1237
000084  2100              MOVS     r1,#0                 ;1238
000086  e9c9a102          STRD     r10,r1,[r9,#8]        ;1238
00008a  f44f6180          MOV      r1,#0x400             ;1239
00008e  f8c91010          STR      r1,[r9,#0x10]         ;1240  ; SDIO_CmdInitStructure
000092  f7fffffe          BL       SDIO_SendCommand
000096  2010              MOVS     r0,#0x10              ;1242
000098  f7fffffe          BL       CmdResp1Error
00009c  282a              CMP      r0,#0x2a              ;1244
00009e  d1d3              BNE      |L50.72|
0000a0  4881              LDR      r0,|L50.680|
0000a2  46cb              MOV      r11,r9                ;1260
0000a4  6880              LDR      r0,[r0,#8]            ;1260  ; RCA
0000a6  0401              LSLS     r1,r0,#16             ;1260
0000a8  f8c91000          STR      r1,[r9,#0]            ;1261  ; SDIO_CmdInitStructure
0000ac  210d              MOVS     r1,#0xd               ;1261
0000ae  f8c91004          STR      r1,[r9,#4]            ;1262  ; SDIO_CmdInitStructure
0000b2  2140              MOVS     r1,#0x40              ;1262
0000b4  f8c91008          STR      r1,[r9,#8]            ;1263  ; SDIO_CmdInitStructure
0000b8  2100              MOVS     r1,#0                 ;1263
0000ba  f8c9100c          STR      r1,[r9,#0xc]          ;1264  ; SDIO_CmdInitStructure
0000be  487c              LDR      r0,|L50.688|
0000c0  f44f6980          MOV      r9,#0x400             ;1264
0000c4  3814              SUBS     r0,r0,#0x14           ;1265
0000c6  f8cb9010          STR      r9,[r11,#0x10]        ;1265  ; SDIO_CmdInitStructure
0000ca  f7fffffe          BL       SDIO_SendCommand
0000ce  200d              MOVS     r0,#0xd               ;1267
0000d0  f7fffffe          BL       CmdResp1Error
0000d4  282a              CMP      r0,#0x2a              ;1269
0000d6  d1b7              BNE      |L50.72|
0000d8  2000              MOVS     r0,#0                 ;1274
0000da  f7fffffe          BL       SDIO_GetResponse
0000de  46da              MOV      r10,r11               ;1235
0000e0  4e72              LDR      r6,|L50.684|
0000e2  f04f0900          MOV      r9,#0                 ;1190
0000e6  f8dfb1c0          LDR      r11,|L50.680|
0000ea  e01a              B        |L50.290|
                  |L50.236|
0000ec  f8db0008          LDR      r0,[r11,#8]           ;1282  ; RCA
0000f0  1e76              SUBS     r6,r6,#1              ;1281
0000f2  0401              LSLS     r1,r0,#16             ;1282
0000f4  f8ca1000          STR      r1,[r10,#0]           ;1283  ; SDIO_CmdInitStructure
0000f8  210d              MOVS     r1,#0xd               ;1283
0000fa  f8ca1004          STR      r1,[r10,#4]           ;1284  ; SDIO_CmdInitStructure
0000fe  2140              MOVS     r1,#0x40              ;1284
000100  e9ca1902          STRD     r1,r9,[r10,#8]        ;1284
000104  486a              LDR      r0,|L50.688|
000106  0109              LSLS     r1,r1,#4              ;1286
000108  3814              SUBS     r0,r0,#0x14           ;1287
00010a  f8ca1010          STR      r1,[r10,#0x10]        ;1287  ; SDIO_CmdInitStructure
00010e  f7fffffe          BL       SDIO_SendCommand
000112  200d              MOVS     r0,#0xd               ;1289
000114  f7fffffe          BL       CmdResp1Error
000118  282a              CMP      r0,#0x2a              ;1291
00011a  d195              BNE      |L50.72|
00011c  2000              MOVS     r0,#0                 ;1295
00011e  f7fffffe          BL       SDIO_GetResponse
                  |L50.290|
000122  05c0              LSLS     r0,r0,#23             ;1279
000124  d402              BMI      |L50.300|
000126  2e00              CMP      r6,#0                 ;1279
000128  d1e0              BNE      |L50.236|
00012a  e02e              B        |L50.394|
                  |L50.300|
00012c  b36e              CBZ      r6,|L50.394|
00012e  4650              MOV      r0,r10                ;1307
000130  2118              MOVS     r1,#0x18              ;1308
000132  e9c08100          STRD     r8,r1,[r0,#0]         ;1308
000136  2140              MOVS     r1,#0x40              ;1309
000138  e9ca1902          STRD     r1,r9,[r10,#8]        ;1309
00013c  485c              LDR      r0,|L50.688|
00013e  0109              LSLS     r1,r1,#4              ;1311
000140  3814              SUBS     r0,r0,#0x14           ;1312
000142  f8ca1010          STR      r1,[r10,#0x10]        ;1312  ; SDIO_CmdInitStructure
000146  f7fffffe          BL       SDIO_SendCommand
00014a  2018              MOVS     r0,#0x18              ;1314
00014c  f7fffffe          BL       CmdResp1Error
000150  282a              CMP      r0,#0x2a              ;1316
000152  d188              BNE      |L50.102|
000154  465e              MOV      r6,r11                ;1321
000156  f8cb4020          STR      r4,[r11,#0x20]        ;1325  ; SrcBuffer
00015a  4855              LDR      r0,|L50.688|
00015c  e9c67904          STRD     r7,r9,[r6,#0x10]      ;1325
000160  4a52              LDR      r2,|L50.684|
000162  e9c02700          STRD     r2,r7,[r0,#0]         ;1325
000166  9a01              LDR      r2,[sp,#4]            ;1328
000168  2101              MOVS     r1,#1                 ;1331
00016a  0112              LSLS     r2,r2,#4              ;1328
00016c  e9c02902          STRD     r2,r9,[r0,#8]         ;1328
000170  e9c09104          STRD     r9,r1,[r0,#0x10]      ;1332
000174  46d8              MOV      r8,r11                ;1321
000176  f7fffffe          BL       SDIO_DataConfig
00017a  68f0              LDR      r0,[r6,#0xc]          ;1336  ; DeviceMode
00017c  2802              CMP      r0,#2                 ;1336
00017e  d02b              BEQ      |L50.472|
000180  4645              MOV      r5,r8                 ;1398
000182  2801              CMP      r0,#1                 ;1398
000184  d058              BEQ      |L50.568|
000186  b3c8              CBZ      r0,|L50.508|
000188  e07e              B        |L50.648|
                  |L50.394|
00018a  2029              MOVS     r0,#0x29              ;1300
00018c  e75c              B        |L50.72|
                  |L50.398|
00018e  f44f4080          MOV      r0,#0x4000            ;1342
000192  f7fffffe          BL       SDIO_GetFlagStatus
000196  b318              CBZ      r0,|L50.480|
000198  f8d80010          LDR      r0,[r8,#0x10]         ;1345  ; TotalNumberOfBytes
00019c  1b40              SUBS     r0,r0,r5              ;1345
00019e  2820              CMP      r0,#0x20              ;1345
0001a0  d20f              BCS      |L50.450|
0001a2  0781              LSLS     r1,r0,#30             ;1347
0001a4  ea4f0790          LSR      r7,r0,#2              ;1347
0001a8  d000              BEQ      |L50.428|
0001aa  1c7f              ADDS     r7,r7,#1              ;1347
                  |L50.428|
0001ac  2600              MOVS     r6,#0                 ;1349
0001ae  e005              B        |L50.444|
                  |L50.432|
0001b0  6820              LDR      r0,[r4,#0]            ;1352
0001b2  f7fffffe          BL       SDIO_WriteData
0001b6  1c76              ADDS     r6,r6,#1              ;1349
0001b8  1d24              ADDS     r4,r4,#4              ;1349
0001ba  1d2d              ADDS     r5,r5,#4              ;1349
                  |L50.444|
0001bc  42be              CMP      r6,r7                 ;1349
0001be  d20f              BCS      |L50.480|
0001c0  e7f6              B        |L50.432|
                  |L50.450|
0001c2  2600              MOVS     r6,#0                 ;1358
                  |L50.452|
0001c4  f8540026          LDR      r0,[r4,r6,LSL #2]     ;1361
0001c8  f7fffffe          BL       SDIO_WriteData
0001cc  1c76              ADDS     r6,r6,#1              ;1358
0001ce  2e08              CMP      r6,#8                 ;1358
0001d0  d3f8              BCC      |L50.452|
0001d2  3420              ADDS     r4,r4,#0x20           ;1363
0001d4  3520              ADDS     r5,r5,#0x20           ;1364
0001d6  e003              B        |L50.480|
                  |L50.472|
0001d8  f8df90d8          LDR      r9,|L50.692|
0001dc  f2406a1a          MOV      r10,#0x61a            ;1339
                  |L50.480|
0001e0  f8d90034          LDR      r0,[r9,#0x34]         ;1339
0001e4  ea100f0a          TST      r0,r10                ;1339
0001e8  d0d1              BEQ      |L50.398|
0001ea  2008              MOVS     r0,#8                 ;1369
0001ec  f7fffffe          BL       SDIO_GetFlagStatus
0001f0  b128              CBZ      r0,|L50.510|
0001f2  2008              MOVS     r0,#8                 ;1371
0001f4  f7fffffe          BL       SDIO_ClearFlag
0001f8  2004              MOVS     r0,#4                 ;1372
                  |L50.506|
0001fa  e725              B        |L50.72|
                  |L50.508|
0001fc  e02b              B        |L50.598|
                  |L50.510|
0001fe  2002              MOVS     r0,#2                 ;1376
000200  f7fffffe          BL       SDIO_GetFlagStatus
000204  b120              CBZ      r0,|L50.528|
000206  2002              MOVS     r0,#2                 ;1378
000208  f7fffffe          BL       SDIO_ClearFlag
00020c  2002              MOVS     r0,#2                 ;1379
00020e  e71b              B        |L50.72|
                  |L50.528|
000210  2010              MOVS     r0,#0x10              ;1383
000212  f7fffffe          BL       SDIO_GetFlagStatus
000216  b120              CBZ      r0,|L50.546|
000218  2010              MOVS     r0,#0x10              ;1385
00021a  f7fffffe          BL       SDIO_ClearFlag
00021e  2005              MOVS     r0,#5                 ;1386
000220  e712              B        |L50.72|
                  |L50.546|
000222  f44f7400          MOV      r4,#0x200             ;1390
000226  4620              MOV      r0,r4                 ;1390
000228  f7fffffe          BL       SDIO_GetFlagStatus
00022c  b360              CBZ      r0,|L50.648|
00022e  4620              MOV      r0,r4                 ;1392
000230  f7fffffe          BL       SDIO_ClearFlag
000234  2007              MOVS     r0,#7                 ;1393
000236  e707              B        |L50.72|
                  |L50.568|
000238  2101              MOVS     r1,#1                 ;1401
00023a  f244301a          MOV      r0,#0x431a            ;1401
00023e  f7fffffe          BL       SDIO_ITConfig
                  |L50.578|
000242  69a8              LDR      r0,[r5,#0x18]         ;1403  ; TransferEnd
000244  b910              CBNZ     r0,|L50.588|
000246  7828              LDRB     r0,[r5,#0]            ;1403  ; TransferError
000248  282a              CMP      r0,#0x2a              ;1403
00024a  d0fa              BEQ      |L50.578|
                  |L50.588|
00024c  7828              LDRB     r0,[r5,#0]            ;1405  ; TransferError
00024e  282a              CMP      r0,#0x2a              ;1405
000250  d01a              BEQ      |L50.648|
000252  7828              LDRB     r0,[r5,#0]            ;1425  ; TransferError
000254  e6f8              B        |L50.72|
                  |L50.598|
000256  2101              MOVS     r1,#1                 ;1414
000258  f240301a          MOV      r0,#0x31a             ;1414
00025c  f7fffffe          BL       SDIO_ITConfig
000260  4639              MOV      r1,r7                 ;1416
000262  4620              MOV      r0,r4                 ;1416
000264  f7fffffe          BL       DMA_TxConfiguration
000268  2001              MOVS     r0,#1                 ;1417
00026a  f7fffffe          BL       SDIO_DMACmd
00026e  4c12              LDR      r4,|L50.696|
                  |L50.624|
000270  4620              MOV      r0,r4                 ;1419
000272  f7fffffe          BL       DMA_GetFlagStatus
000276  2800              CMP      r0,#0                 ;1419
000278  d0fa              BEQ      |L50.624|
                  |L50.634|
00027a  69a8              LDR      r0,[r5,#0x18]         ;1421  ; TransferEnd
00027c  2800              CMP      r0,#0                 ;1421
00027e  d1e5              BNE      |L50.588|
000280  7828              LDRB     r0,[r5,#0]            ;1421  ; TransferError
000282  282a              CMP      r0,#0x2a              ;1421
000284  d0f9              BEQ      |L50.634|
000286  e7e1              B        |L50.588|
                  |L50.648|
000288  f24050ff          MOV      r0,#0x5ff             ;1430
00028c  f7fffffe          BL       SDIO_ClearFlag
                  |L50.656|
000290  4668              MOV      r0,sp                 ;1437
000292  f7fffffe          BL       IsCardProgramming
000296  282a              CMP      r0,#0x2a              ;1435
000298  d1af              BNE      |L50.506|
00029a  f89d1000          LDRB     r1,[sp,#0]            ;1435
00029e  2907              CMP      r1,#7                 ;1435
0002a0  d0f6              BEQ      |L50.656|
0002a2  2906              CMP      r1,#6                 ;1435
0002a4  d0f4              BEQ      |L50.656|
0002a6  e6cf              B        |L50.72|
;;;1442   
                          ENDP

                  |L50.680|
                          DCD      ||.data||
                  |L50.684|
                          DCD      0x000fffff
                  |L50.688|
                          DCD      ||.bss||+0x4c
                  |L50.692|
                          DCD      0x40018000
                  |L50.696|
                          DCD      0x10002000

                          AREA ||i.SD_WriteMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_WriteMultiBlocks PROC
;;;1450     */
;;;1451   SD_Error SD_WriteMultiBlocks(uint32_t addr, uint32_t *writebuff, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1452   {							     
000004  4681              MOV      r9,r0
;;;1453    
;;;1454     SD_Error errorstatus = SD_OK;
;;;1455     uint8_t  power = 0, cardstate = 0;
000006  f04f0000          MOV      r0,#0
00000a  000c              MOVS     r4,r1                 ;1452
00000c  4616              MOV      r6,r2                 ;1452
00000e  461f              MOV      r7,r3                 ;1452
000010  f88d0000          STRB     r0,[sp,#0]
;;;1456     uint32_t bytestransferred = 0;
000014  4605              MOV      r5,r0
;;;1457     uint32_t count = 0, restwords = 0;
;;;1458     uint32_t *tempbuff = writebuff;
;;;1459   
;;;1460     if (writebuff == NULL)
000016  d062              BEQ      |L51.222|
;;;1461     {
;;;1462       errorstatus = SD_INVALID_PARAMETER;
;;;1463       return(errorstatus);
;;;1464     }
;;;1465   
;;;1466     TransferError = SD_OK;
000018  f8dfa2cc          LDR      r10,|L51.744|
00001c  222a              MOVS     r2,#0x2a
00001e  f88a2000          STRB     r2,[r10,#0]
;;;1467     TransferEnd = 0;
000022  4680              MOV      r8,r0
000024  f8ca0018          STR      r0,[r10,#0x18]  ; TransferEnd
;;;1468     TotalNumberOfBytes = 0;
;;;1469      // 关闭SDIO数据通道状态机(DPSM) //
;;;1470     SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
000028  49b1              LDR      r1,|L51.752|
00002a  4ab0              LDR      r2,|L51.748|
00002c  f8ca0010          STR      r0,[r10,#0x10]  ; TotalNumberOfBytes
000030  e9c12000          STRD     r2,r0,[r1,#0]
;;;1471     SDIO_DataInitStructure.SDIO_DataLength = 0;
;;;1472     SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
;;;1473     SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
000034  6088              STR      r0,[r1,#8]  ; SDIO_DataInitStructure
;;;1474     SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
000036  60c8              STR      r0,[r1,#0xc]  ; SDIO_DataInitStructure
;;;1475     SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;
000038  6108              STR      r0,[r1,#0x10]  ; SDIO_DataInitStructure
;;;1476     SDIO_DataConfig(&SDIO_DataInitStructure);
00003a  6148              STR      r0,[r1,#0x14]  ; SDIO_DataInitStructure
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       SDIO_DataConfig
;;;1477     SDIO_DMACmd(DISABLE); // 关闭SDIO DMA请求 //
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       SDIO_DMACmd
;;;1478      // 确认卡未上锁 //
;;;1479     if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SDIO_GetResponse
00004e  0180              LSLS     r0,r0,#6
000050  d502              BPL      |L51.88|
;;;1480     {
;;;1481       errorstatus = SD_LOCK_UNLOCK_FAILED;
000052  200e              MOVS     r0,#0xe
                  |L51.84|
;;;1482       return(errorstatus);
;;;1483     }
;;;1484      // 对于标准容量SD卡，写数据块长度由CMD16指定，而对于高容量SD卡，写数据块长度固定为512B //
;;;1485     if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;1486     {
;;;1487       BlockSize = 512;
;;;1488       addr /= 512;
;;;1489     }
;;;1490     
;;;1491     // 分别设置卡和主机的数据块长度 // 
;;;1492     if ((BlockSize > 0) && (BlockSize <= 2048) && ((BlockSize & (BlockSize - 1)) == 0))
;;;1493     {
;;;1494       power = convert_from_bytes_to_power_of_two(BlockSize);
;;;1495   	// CMD16: SET_BLOCKLEN ----------------------------------------------------------//
;;;1496       // 发送 CMD16 设置卡的数据块长度 //
;;;1497       // 参数: - [31:0]: 数据块长度 //
;;;1498       // 响应类型: R1 //
;;;1499       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
;;;1500       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCKLEN;
;;;1501       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1502       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1503       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1504       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1505   
;;;1506       errorstatus = CmdResp1Error(SDIO_SET_BLOCKLEN);
;;;1507   
;;;1508       if (errorstatus != SD_OK)
;;;1509       {
;;;1510         return(errorstatus);
;;;1511       }
;;;1512     }
;;;1513     else
;;;1514     {
;;;1515       errorstatus = SD_INVALID_PARAMETER;
;;;1516       return(errorstatus);
;;;1517     }
;;;1518   
;;;1519     // CMD13: SEND_STATUS -------------------------------------------------------------//
;;;1520     /// 发送 CMD13 要求卡发送状态寄存器(这里指卡状态，如果该命令在紧随CMD55之后发送，则为SD状态) //
;;;1521     // 参数: - [31:16]: 相对卡地址RCA
;;;1522      //        - [15:0]: 填充位(‘0’) //
;;;1523     // 响应类型: R1 //
;;;1524     SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
;;;1525     SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_STATUS;
;;;1526     SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1527     SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1528     SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1529     SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1530   
;;;1531     errorstatus = CmdResp1Error(SDIO_SEND_STATUS);
;;;1532   
;;;1533     if (errorstatus != SD_OK)
;;;1534     {
;;;1535       return(errorstatus);
;;;1536     }
;;;1537   
;;;1538     if (NumberOfBlocks > 1)
;;;1539     {
;;;1540       // Common to all modes //
;;;1541       if (NumberOfBlocks * BlockSize > SD_MAX_DATA_LENGTH)
;;;1542       {
;;;1543         errorstatus = SD_INVALID_PARAMETER;
;;;1544         return(errorstatus);
;;;1545       }
;;;1546   	// 设置预擦除写数据块数目(ACMD23)，为加快多块写操作速度 //
;;;1547       if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
;;;1548       {
;;;1549         // CMD55: APP_CMD //
;;;1550         // 必须在发送 ACMD23 之前发送 CMD55 通知卡，下面一条命令是应用特定命令//
;;;1551         // 参数: - [31:16]: 相对卡地址RCA 
;;;1552         //         - [15:0]: 保留('0') //
;;;1553         // 响应类型: R1 //
;;;1554         SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
;;;1555         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_APP_CMD;
;;;1556         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1557         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1558         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1559         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1560   
;;;1561   
;;;1562         errorstatus = CmdResp1Error(SDIO_APP_CMD);
;;;1563   
;;;1564         if (errorstatus != SD_OK)
;;;1565         {
;;;1566           return(errorstatus);
;;;1567         }
;;;1568          // ACMD23: SET_WR_BLK_ERASE_COUNT ----------------------------------------------//
;;;1569         // 发送 ACMD23 设置多块写命令前的预擦除写数据块数目 //
;;;1570         // 参数: - [31:23]: 填充位('0') 
;;;1571          //        - [22:0]: 预擦除写数据块数目 //
;;;1572         // 响应类型: R1 //
;;;1573         SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)NumberOfBlocks;
;;;1574         SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SET_BLOCK_COUNT;
;;;1575         SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1576         SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1577         SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1578         SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1579   
;;;1580         errorstatus = CmdResp1Error(SDIO_SET_BLOCK_COUNT);
;;;1581   
;;;1582         if (errorstatus != SD_OK)
;;;1583         {
;;;1584           return(errorstatus);
;;;1585         }
;;;1586       }
;;;1587   
;;;1588       // CMD23: SET_WR_BLK_ERASE_COUNT -------------------------//
;;;1589       // 发送 CMD25 开始写多个多块 //
;;;1590       // 参数: - [31:0]: 数据地址 //
;;;1591       // 响应类型: R1//
;;;1592       SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)addr;
;;;1593       SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_WRITE_MULT_BLOCK;
;;;1594       SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1595       SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1596       SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1597       SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1598   
;;;1599       errorstatus = CmdResp1Error(SDIO_WRITE_MULT_BLOCK);
;;;1600   
;;;1601       if (SD_OK != errorstatus)
;;;1602       {
;;;1603         return(errorstatus);
;;;1604       }
;;;1605   	 // 初始化并使能SDIO数据通道状态机(DPSM) //
;;;1606       TotalNumberOfBytes = NumberOfBlocks * BlockSize;
;;;1607       StopCondition = 1;
;;;1608       SrcBuffer = writebuff;
;;;1609   
;;;1610       SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;1611       SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
;;;1612   	// SDIO_DataBlockSize用于设置主机数据块长度DBCKSIZE位(SDIO_DCTRL[7:4]) //
;;;1613       SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) power << 4;
;;;1614       SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
;;;1615       SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;1616       SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
;;;1617       SDIO_DataConfig(&SDIO_DataInitStructure);
;;;1618   	//数据传输模式为轮询模式 -------------------------------------------//
;;;1619       if (DeviceMode == SD_POLLING_MODE)
;;;1620       {
;;;1621   	// 当下列标志都不为1时，继续发送数据 //
;;;1622         while (!(SDIO->STA & (SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DATAEND | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_STBITERR)))
;;;1623         {
;;;1624           // 如果剩下的待发送的数据字节大于或等于SD_HALFFIFOBYTES(32)个字节(8个字)，
;;;1625   		//	则发送SD_HALFFIFO(8)个字 //
;;;1626   		if (SDIO_GetFlagStatus(SDIO_FLAG_TXFIFOHE) != RESET)
;;;1627           {
;;;1628             if (!((TotalNumberOfBytes - bytestransferred) < SD_HALFFIFOBYTES))
;;;1629             {
;;;1630               for (count = 0; count < SD_HALFFIFO; count++)
;;;1631               {
;;;1632                 SDIO_WriteData(*(tempbuff + count));  // 向发送FIFO中写入1个字//
;;;1633               }
;;;1634               tempbuff += SD_HALFFIFO;
;;;1635               bytestransferred += SD_HALFFIFOBYTES;
;;;1636             }
;;;1637   		   // 如果剩下的待发送的数据字节小于SD_HALFFIFOBYTES(32)个字节(8个字)，则只发送剩下的字 //
;;;1638             else
;;;1639             {
;;;1640               restwords = ((TotalNumberOfBytes - bytestransferred) % 4 == 0) ? ((TotalNumberOfBytes - bytestransferred) / 4) :
;;;1641                           ((TotalNumberOfBytes - bytestransferred) / 4 + 1);
;;;1642   
;;;1643               for (count = 0; count < restwords; count++, tempbuff++, bytestransferred += 4)
;;;1644               {
;;;1645                 SDIO_WriteData(*tempbuff);
;;;1646               }
;;;1647             }
;;;1648           }
;;;1649         }
;;;1650   	   // 数据超时 //
;;;1651         if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
;;;1652         {
;;;1653           SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
;;;1654           errorstatus = SD_DATA_TIMEOUT;
;;;1655           return(errorstatus);
;;;1656         }
;;;1657   	   // 已发送/接收数据块，但是CRC校验失败 //
;;;1658         else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
;;;1659         {
;;;1660           SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
;;;1661           errorstatus = SD_DATA_CRC_FAIL;
;;;1662           return(errorstatus);
;;;1663         }
;;;1664   	   // 发送FIFO下溢错误 //
;;;1665         else if (SDIO_GetFlagStatus(SDIO_FLAG_TXUNDERR) != RESET)
;;;1666         {
;;;1667           SDIO_ClearFlag(SDIO_FLAG_TXUNDERR);
;;;1668           errorstatus = SD_TX_UNDERRUN;
;;;1669           return(errorstatus);
;;;1670         }
;;;1671   	   // 在宽总线模式下，在所有数据线上都没有检测到起始位 //
;;;1672         else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
;;;1673         {
;;;1674           SDIO_ClearFlag(SDIO_FLAG_STBITERR);
;;;1675           errorstatus = SD_START_BIT_ERR;
;;;1676           return(errorstatus);
;;;1677         }
;;;1678   	   // 数据传输结束后(已发送NumberOfBlocks * BlockSize个字节)，发送停止传输命令(CMD12) //
;;;1679         if (SDIO_GetFlagStatus(SDIO_FLAG_DATAEND) != RESET)
;;;1680         {
;;;1681          if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType))
;;;1682           {
;;;1683             //CMD12: STOP_TRANSMISSION ------------------------------------------------//
;;;1684             // 发送 CMD12 强制卡停止数据传输 //
;;;1685             // 参数: - [31:0]: 填充位(‘0’) //
;;;1686             // 响应类型: R1b(短) //
;;;1687             SDIO_CmdInitStructure.SDIO_Argument = 0x0;
;;;1688             SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_STOP_TRANSMISSION;
;;;1689             SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
;;;1690             SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
;;;1691             SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
;;;1692             SDIO_SendCommand(&SDIO_CmdInitStructure);
;;;1693   
;;;1694   
;;;1695             errorstatus = CmdResp1Error(SDIO_STOP_TRANSMISSION);
;;;1696   
;;;1697             if (errorstatus != SD_OK)
;;;1698             {
;;;1699               return(errorstatus);
;;;1700             }
;;;1701           }
;;;1702         }
;;;1703       }
;;;1704   	 //数据传输模式为中断模式 ---------------------------------///
;;;1705       else if (DeviceMode == SD_INTERRUPT_MODE)
;;;1706       {
;;;1707         SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_TXFIFOHE | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR, ENABLE);
;;;1708         while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1709         {}
;;;1710         if (TransferError != SD_OK)
;;;1711         {
;;;1712           return(TransferError);
;;;1713         }
;;;1714       }
;;;1715   	// 数据传输模式为DMA模式 ---------------------------------//
;;;1716       else if (DeviceMode == SD_DMA_MODE)
;;;1717       {
;;;1718         SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR, ENABLE);
;;;1719         SDIO_DMACmd(ENABLE);
;;;1720         DMA_TxConfiguration(writebuff, (NumberOfBlocks * BlockSize));
;;;1721         while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET)
;;;1722         {}
;;;1723         while ((TransferEnd == 0) && (TransferError == SD_OK))
;;;1724         {}
;;;1725         if (TransferError != SD_OK)
;;;1726         {
;;;1727           return(TransferError);
;;;1728         }
;;;1729       }
;;;1730     }
;;;1731     // Clear all the static flags //
;;;1732     SDIO_ClearFlag(SDIO_STATIC_FLAGS);
;;;1733   
;;;1734     // Wait till the card is in programming state //
;;;1735     errorstatus = IsCardProgramming(&cardstate);
;;;1736   
;;;1737     while ((errorstatus == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
;;;1738     {
;;;1739       errorstatus = IsCardProgramming(&cardstate);
;;;1740     }
;;;1741   
;;;1742     return(errorstatus);
;;;1743   }
000054  e8bd9ffc          POP      {r2-r12,pc}
                  |L51.88|
000058  f8da0004          LDR      r0,[r10,#4]           ;1485  ; CardType
00005c  2802              CMP      r0,#2                 ;1485
00005e  d102              BNE      |L51.102|
000060  0206              LSLS     r6,r0,#8              ;1487
000062  ea4f2959          LSR      r9,r9,#9              ;1488
                  |L51.102|
000066  1e70              SUBS     r0,r6,#1              ;1492
000068  f5b06f00          CMP      r0,#0x800             ;1492
00006c  d237              BCS      |L51.222|
00006e  4206              TST      r6,r0                 ;1492
000070  d135              BNE      |L51.222|
000072  4630              MOV      r0,r6                 ;1494
000074  f7fffffe          BL       convert_from_bytes_to_power_of_two
000078  f8dfb274          LDR      r11,|L51.752|
00007c  9001              STR      r0,[sp,#4]            ;1499
00007e  f1ab0b14          SUB      r11,r11,#0x14         ;1499
000082  4658              MOV      r0,r11                ;1499
000084  2110              MOVS     r1,#0x10              ;1500
000086  e9c06100          STRD     r6,r1,[r0,#0]         ;1500
00008a  2140              MOVS     r1,#0x40              ;1501
00008c  e9cb1802          STRD     r1,r8,[r11,#8]        ;1501
000090  0109              LSLS     r1,r1,#4              ;1503
000092  f8cb1010          STR      r1,[r11,#0x10]        ;1504  ; SDIO_CmdInitStructure
000096  f7fffffe          BL       SDIO_SendCommand
00009a  2010              MOVS     r0,#0x10              ;1506
00009c  f7fffffe          BL       CmdResp1Error
0000a0  282a              CMP      r0,#0x2a              ;1508
0000a2  d1d7              BNE      |L51.84|
0000a4  4890              LDR      r0,|L51.744|
0000a6  f44f6a80          MOV      r10,#0x400            ;1528
0000aa  6880              LDR      r0,[r0,#8]            ;1524  ; RCA
0000ac  0401              LSLS     r1,r0,#16             ;1524
0000ae  4658              MOV      r0,r11                ;1524
0000b0  f04f0b40          MOV      r11,#0x40             ;1526
0000b4  6001              STR      r1,[r0,#0]            ;1525  ; SDIO_CmdInitStructure
0000b6  210d              MOVS     r1,#0xd               ;1525
0000b8  e9c01b01          STRD     r1,r11,[r0,#4]        ;1526
0000bc  2100              MOVS     r1,#0                 ;1527
0000be  e9c01a03          STRD     r1,r10,[r0,#0xc]      ;1528
0000c2  f7fffffe          BL       SDIO_SendCommand
0000c6  200d              MOVS     r0,#0xd               ;1531
0000c8  f7fffffe          BL       CmdResp1Error
0000cc  282a              CMP      r0,#0x2a              ;1533
0000ce  d1c1              BNE      |L51.84|
0000d0  2f01              CMP      r7,#1                 ;1538
0000d2  d95f              BLS      |L51.404|
0000d4  fb07f806          MUL      r8,r7,r6              ;1541
0000d8  f1b87f00          CMP      r8,#0x2000000         ;1541
0000dc  d301              BCC      |L51.226|
                  |L51.222|
0000de  2026              MOVS     r0,#0x26              ;1543
                  |L51.224|
0000e0  e7b8              B        |L51.84|
                  |L51.226|
0000e2  4e81              LDR      r6,|L51.744|
0000e4  6870              LDR      r0,[r6,#4]            ;1547  ; CardType
0000e6  b118              CBZ      r0,|L51.240|
0000e8  2801              CMP      r0,#1                 ;1547
0000ea  d001              BEQ      |L51.240|
0000ec  2802              CMP      r0,#2                 ;1547
0000ee  d122              BNE      |L51.310|
                  |L51.240|
0000f0  68b0              LDR      r0,[r6,#8]            ;1554  ; RCA
0000f2  0401              LSLS     r1,r0,#16             ;1554
0000f4  487e              LDR      r0,|L51.752|
0000f6  3814              SUBS     r0,r0,#0x14           ;1554
0000f8  6001              STR      r1,[r0,#0]            ;1555  ; SDIO_CmdInitStructure
0000fa  2137              MOVS     r1,#0x37              ;1555
0000fc  e9c01b01          STRD     r1,r11,[r0,#4]        ;1555
000100  2100              MOVS     r1,#0                 ;1557
000102  e9c01a03          STRD     r1,r10,[r0,#0xc]      ;1557
000106  f7fffffe          BL       SDIO_SendCommand
00010a  2037              MOVS     r0,#0x37              ;1562
00010c  f7fffffe          BL       CmdResp1Error
000110  282a              CMP      r0,#0x2a              ;1564
000112  d19f              BNE      |L51.84|
000114  4876              LDR      r0,|L51.752|
000116  2117              MOVS     r1,#0x17              ;1574
000118  3814              SUBS     r0,r0,#0x14           ;1573
00011a  f8c0b008          STR      r11,[r0,#8]           ;1575  ; SDIO_CmdInitStructure
00011e  e9c07100          STRD     r7,r1,[r0,#0]         ;1575
000122  2100              MOVS     r1,#0                 ;1576
000124  e9c01a03          STRD     r1,r10,[r0,#0xc]      ;1576
000128  f7fffffe          BL       SDIO_SendCommand
00012c  2017              MOVS     r0,#0x17              ;1580
00012e  f7fffffe          BL       CmdResp1Error
000132  282a              CMP      r0,#0x2a              ;1582
000134  d18e              BNE      |L51.84|
                  |L51.310|
000136  486e              LDR      r0,|L51.752|
000138  2119              MOVS     r1,#0x19              ;1593
00013a  3814              SUBS     r0,r0,#0x14           ;1592
00013c  2700              MOVS     r7,#0                 ;1595
00013e  f8c0b008          STR      r11,[r0,#8]           ;1595  ; SDIO_CmdInitStructure
000142  e9c09100          STRD     r9,r1,[r0,#0]         ;1595
000146  f44f6180          MOV      r1,#0x400             ;1596
00014a  e9c07103          STRD     r7,r1,[r0,#0xc]       ;1596
00014e  f7fffffe          BL       SDIO_SendCommand
000152  2019              MOVS     r0,#0x19              ;1599
000154  f7fffffe          BL       CmdResp1Error
000158  282a              CMP      r0,#0x2a              ;1601
00015a  d1c1              BNE      |L51.224|
00015c  2201              MOVS     r2,#1                 ;1607
00015e  6234              STR      r4,[r6,#0x20]         ;1610  ; SrcBuffer
000160  4863              LDR      r0,|L51.752|
000162  e9c68204          STRD     r8,r2,[r6,#0x10]      ;1610
000166  4961              LDR      r1,|L51.748|
000168  e9c01800          STRD     r1,r8,[r0,#0]         ;1610
00016c  9901              LDR      r1,[sp,#4]            ;1613
00016e  46b1              MOV      r9,r6                 ;1606
000170  0109              LSLS     r1,r1,#4              ;1613
000172  e9c01702          STRD     r1,r7,[r0,#8]         ;1614
000176  e9c07204          STRD     r7,r2,[r0,#0x10]      ;1614
00017a  46ba              MOV      r10,r7                ;1614
00017c  f7fffffe          BL       SDIO_DataConfig
000180  68f1              LDR      r1,[r6,#0xc]          ;1619  ; DeviceMode
000182  f240301a          MOV      r0,#0x31a             ;1622
000186  2902              CMP      r1,#2                 ;1619
000188  d02a              BEQ      |L51.480|
00018a  464d              MOV      r5,r9                 ;1705
00018c  2901              CMP      r1,#1                 ;1705
00018e  d073              BEQ      |L51.632|
000190  2900              CMP      r1,#0                 ;1716
000192  d070              BEQ      |L51.630|
                  |L51.404|
000194  e098              B        |L51.712|
                  |L51.406|
000196  f44f4080          MOV      r0,#0x4000            ;1626
00019a  f7fffffe          BL       SDIO_GetFlagStatus
00019e  b300              CBZ      r0,|L51.482|
0001a0  f8d90010          LDR      r0,[r9,#0x10]         ;1628  ; TotalNumberOfBytes
0001a4  1b40              SUBS     r0,r0,r5              ;1628
0001a6  2820              CMP      r0,#0x20              ;1628
0001a8  d30a              BCC      |L51.448|
0001aa  2600              MOVS     r6,#0                 ;1630
                  |L51.428|
0001ac  f8540026          LDR      r0,[r4,r6,LSL #2]     ;1632
0001b0  f7fffffe          BL       SDIO_WriteData
0001b4  1c76              ADDS     r6,r6,#1              ;1630
0001b6  2e08              CMP      r6,#8                 ;1630
0001b8  d3f8              BCC      |L51.428|
0001ba  3420              ADDS     r4,r4,#0x20           ;1634
0001bc  3520              ADDS     r5,r5,#0x20           ;1635
0001be  e010              B        |L51.482|
                  |L51.448|
0001c0  0781              LSLS     r1,r0,#30             ;1640
0001c2  ea4f0790          LSR      r7,r0,#2              ;1641
0001c6  d000              BEQ      |L51.458|
0001c8  1c7f              ADDS     r7,r7,#1              ;1641
                  |L51.458|
0001ca  2600              MOVS     r6,#0                 ;1643
0001cc  e005              B        |L51.474|
                  |L51.462|
0001ce  6820              LDR      r0,[r4,#0]            ;1645
0001d0  f7fffffe          BL       SDIO_WriteData
0001d4  1c76              ADDS     r6,r6,#1              ;1643
0001d6  1d24              ADDS     r4,r4,#4              ;1643
0001d8  1d2d              ADDS     r5,r5,#4              ;1643
                  |L51.474|
0001da  42be              CMP      r6,r7                 ;1643
0001dc  d201              BCS      |L51.482|
0001de  e7f6              B        |L51.462|
                  |L51.480|
0001e0  4680              MOV      r8,r0                 ;1622
                  |L51.482|
0001e2  4844              LDR      r0,|L51.756|
0001e4  6b41              LDR      r1,[r0,#0x34]         ;1622
0001e6  ea110f08          TST      r1,r8                 ;1622
0001ea  d0d4              BEQ      |L51.406|
0001ec  2008              MOVS     r0,#8                 ;1651
0001ee  f7fffffe          BL       SDIO_GetFlagStatus
0001f2  b120              CBZ      r0,|L51.510|
0001f4  2008              MOVS     r0,#8                 ;1653
0001f6  f7fffffe          BL       SDIO_ClearFlag
0001fa  2004              MOVS     r0,#4                 ;1654
                  |L51.508|
0001fc  e72a              B        |L51.84|
                  |L51.510|
0001fe  2002              MOVS     r0,#2                 ;1658
000200  f7fffffe          BL       SDIO_GetFlagStatus
000204  b120              CBZ      r0,|L51.528|
000206  2002              MOVS     r0,#2                 ;1660
000208  f7fffffe          BL       SDIO_ClearFlag
00020c  2002              MOVS     r0,#2                 ;1661
00020e  e721              B        |L51.84|
                  |L51.528|
000210  2010              MOVS     r0,#0x10              ;1665
000212  f7fffffe          BL       SDIO_GetFlagStatus
000216  b120              CBZ      r0,|L51.546|
000218  2010              MOVS     r0,#0x10              ;1667
00021a  f7fffffe          BL       SDIO_ClearFlag
00021e  2005              MOVS     r0,#5                 ;1668
000220  e718              B        |L51.84|
                  |L51.546|
000222  f44f7400          MOV      r4,#0x200             ;1672
000226  4620              MOV      r0,r4                 ;1672
000228  f7fffffe          BL       SDIO_GetFlagStatus
00022c  b120              CBZ      r0,|L51.568|
00022e  4620              MOV      r0,r4                 ;1674
000230  f7fffffe          BL       SDIO_ClearFlag
000234  2007              MOVS     r0,#7                 ;1675
000236  e70d              B        |L51.84|
                  |L51.568|
000238  f44f7080          MOV      r0,#0x100             ;1679
00023c  f7fffffe          BL       SDIO_GetFlagStatus
000240  b3f0              CBZ      r0,|L51.704|
000242  f8d90004          LDR      r0,[r9,#4]            ;1681  ; CardType
000246  b118              CBZ      r0,|L51.592|
000248  2801              CMP      r0,#1                 ;1681
00024a  d001              BEQ      |L51.592|
00024c  2802              CMP      r0,#2                 ;1681
00024e  d13b              BNE      |L51.712|
                  |L51.592|
000250  4827              LDR      r0,|L51.752|
000252  4651              MOV      r1,r10                ;1687
000254  3814              SUBS     r0,r0,#0x14           ;1687
000256  220c              MOVS     r2,#0xc               ;1688
000258  e8800806          STM      r0,{r1,r2,r11}        ;1688
00025c  f44f6180          MOV      r1,#0x400             ;1691
000260  e9c0a103          STRD     r10,r1,[r0,#0xc]      ;1692
000264  f7fffffe          BL       SDIO_SendCommand
000268  200c              MOVS     r0,#0xc               ;1695
00026a  f7fffffe          BL       CmdResp1Error
00026e  282a              CMP      r0,#0x2a              ;1697
000270  d1c4              BNE      |L51.508|
000272  e029              B        |L51.712|
000274  e000              B        |L51.632|
                  |L51.630|
000276  e00e              B        |L51.662|
                  |L51.632|
000278  2101              MOVS     r1,#1                 ;1707
00027a  f244301a          MOV      r0,#0x431a            ;1707
00027e  f7fffffe          BL       SDIO_ITConfig
                  |L51.642|
000282  69a8              LDR      r0,[r5,#0x18]         ;1708  ; TransferEnd
000284  b910              CBNZ     r0,|L51.652|
000286  7828              LDRB     r0,[r5,#0]            ;1708  ; TransferError
000288  282a              CMP      r0,#0x2a              ;1708
00028a  d0fa              BEQ      |L51.642|
                  |L51.652|
00028c  7828              LDRB     r0,[r5,#0]            ;1710  ; TransferError
00028e  282a              CMP      r0,#0x2a              ;1710
000290  d01a              BEQ      |L51.712|
000292  7828              LDRB     r0,[r5,#0]            ;1727  ; TransferError
000294  e6de              B        |L51.84|
                  |L51.662|
000296  2101              MOVS     r1,#1                 ;1718
000298  f7fffffe          BL       SDIO_ITConfig
00029c  2001              MOVS     r0,#1                 ;1719
00029e  f7fffffe          BL       SDIO_DMACmd
0002a2  4641              MOV      r1,r8                 ;1719
0002a4  4620              MOV      r0,r4                 ;1720
0002a6  f7fffffe          BL       DMA_TxConfiguration
0002aa  4c13              LDR      r4,|L51.760|
                  |L51.684|
0002ac  4620              MOV      r0,r4                 ;1721
0002ae  f7fffffe          BL       DMA_GetFlagStatus
0002b2  2800              CMP      r0,#0                 ;1721
0002b4  d0fa              BEQ      |L51.684|
                  |L51.694|
0002b6  69a8              LDR      r0,[r5,#0x18]         ;1723  ; TransferEnd
0002b8  2800              CMP      r0,#0                 ;1723
0002ba  d1e7              BNE      |L51.652|
0002bc  7828              LDRB     r0,[r5,#0]            ;1723  ; TransferError
0002be  e000              B        |L51.706|
                  |L51.704|
0002c0  e002              B        |L51.712|
                  |L51.706|
0002c2  282a              CMP      r0,#0x2a              ;1723
0002c4  d0f7              BEQ      |L51.694|
0002c6  e7e1              B        |L51.652|
                  |L51.712|
0002c8  f24050ff          MOV      r0,#0x5ff             ;1732
0002cc  f7fffffe          BL       SDIO_ClearFlag
                  |L51.720|
0002d0  4668              MOV      r0,sp                 ;1739
0002d2  f7fffffe          BL       IsCardProgramming
0002d6  282a              CMP      r0,#0x2a              ;1737
0002d8  d190              BNE      |L51.508|
0002da  f89d1000          LDRB     r1,[sp,#0]            ;1737
0002de  2907              CMP      r1,#7                 ;1737
0002e0  d0f6              BEQ      |L51.720|
0002e2  2906              CMP      r1,#6                 ;1737
0002e4  d0f4              BEQ      |L51.720|
0002e6  e6b5              B        |L51.84|
;;;1744   
                          ENDP

                  |L51.744|
                          DCD      ||.data||
                  |L51.748|
                          DCD      0x000fffff
                  |L51.752|
                          DCD      ||.bss||+0x4c
                  |L51.756|
                          DCD      0x40018000
                  |L51.760|
                          DCD      0x10002000

                          AREA ||i.Sd_InitAndTest||, CODE, READONLY, ALIGN=1

                  Sd_InitAndTest PROC
;;;3181    *******************************************************************************/
;;;3182   void Sd_InitAndTest(void)
000000  b510              PUSH     {r4,lr}
;;;3183   {
;;;3184       SD_NVIC_Configuration();
000002  f7fffffe          BL       SD_NVIC_Configuration
;;;3185       Test_SDCard();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      Test_SDCard
;;;3186   }
;;;3187   
                          ENDP


                          AREA ||i.SetRtcTime||, CODE, READONLY, ALIGN=2

                  SetRtcTime PROC
;;;40     *****************************************************/
;;;41     void SetRtcTime(u8 year,u8 month,u8 day,u8 hour,u8 min,u8 sec)
000000  b570              PUSH     {r4-r6,lr}
;;;42     {
;;;43     	unsigned long temp;
;;;44     	temp=year*360*24*3600+(month-1)*30*24*3600+(day-1)*24*3600+hour*3600+min*60+sec;
000002  f44f76b4          MOV      r6,#0x168
000006  4370              MULS     r0,r6,r0
000008  ebc11101          RSB      r1,r1,r1,LSL #4
00000c  eb000041          ADD      r0,r0,r1,LSL #1
000010  4410              ADD      r0,r0,r2
000012  490c              LDR      r1,|L53.68|
000014  381f              SUBS     r0,r0,#0x1f
000016  4348              MULS     r0,r1,r0
000018  e9dd4504          LDRD     r4,r5,[sp,#0x10]      ;42
00001c  ebc31143          RSB      r1,r3,r3,LSL #5
000020  ebc12103          RSB      r1,r1,r3,LSL #8
000024  eb001001          ADD      r0,r0,r1,LSL #4
000028  ebc41104          RSB      r1,r4,r4,LSL #4
00002c  eb000081          ADD      r0,r0,r1,LSL #2
000030  1944              ADDS     r4,r0,r5
;;;45     	RTC_WaitForLastTask();
000032  f7fffffe          BL       RTC_WaitForLastTask
;;;46     	RTC_SetCounter(temp);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       RTC_SetCounter
;;;47     	RTC_WaitForLastTask();
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      RTC_WaitForLastTask
;;;48     }
;;;49     /*****************************************************
                          ENDP

                  |L53.68|
                          DCD      0x00015180

                          AREA ||i.Test_SDCard||, CODE, READONLY, ALIGN=2

                  Test_SDCard PROC
;;;3113   
;;;3114   SD_Error Test_SDCard(void)
000000  b510              PUSH     {r4,lr}
;;;3115   {
000002  b094              SUB      sp,sp,#0x50
;;;3116   	SD_CardInfo qq;
;;;3117   	SD_Error Status = SD_OK;
;;;3118       
;;;3119   	Status = SD_Init();   
000004  f7fffffe          BL       SD_Init
000008  4604              MOV      r4,r0
;;;3120     	if (Status == SD_OK)
00000a  282a              CMP      r0,#0x2a
00000c  d12c              BNE      |L54.104|
;;;3121     	{		  	
;;;3122     	 	//----------------- Read CSD/CID MSD registers ------------------	 
;;;3123      		DBG_Print(3, "SD_Init is ok\r\n");
00000e  a118              ADR      r1,|L54.112|
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       DBG_Print
;;;3124   	 	Status = SD_GetCardInfo(&qq);	 	   
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       SD_GetCardInfo
00001c  4604              MOV      r4,r0
;;;3125     	}								
;;;3126     	if (Status == SD_OK)
00001e  282a              CMP      r0,#0x2a
000020  d122              BNE      |L54.104|
;;;3127     	{																	 
;;;3128   	  	DBG_Print(3, "SD_GetCardInfo is ok\r\n");
000022  a117              ADR      r1,|L54.128|
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       DBG_Print
;;;3129       	Status = SD_SelectDeselect((uint32_t) (qq.RCA << 16));  
00002a  f8bd004c          LDRH     r0,[sp,#0x4c]
00002e  0400              LSLS     r0,r0,#16
000030  f7fffffe          BL       SD_SelectDeselect
000034  4604              MOV      r4,r0
;;;3130     	}
;;;3131   	 
;;;3132     	if (Status == SD_OK)
000036  282a              CMP      r0,#0x2a
000038  d116              BNE      |L54.104|
;;;3133     	{
;;;3134     		DBG_Print(3, "SD_SelectDeselect is ok\r\n");
00003a  a117              ADR      r1,|L54.152|
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       DBG_Print
;;;3135   		// SDIO_BusWide_4b 会进入死循环,至今还未解决			   
;;;3136       	Status = SD_EnableWideBusOperation(SDIO_BusWide_4b); 		  
000042  f44f6000          MOV      r0,#0x800
000046  f7fffffe          BL       SD_EnableWideBusOperation
00004a  4604              MOV      r4,r0
;;;3137     	}	 
;;;3138   	
;;;3139     	if (Status == SD_OK)
00004c  282a              CMP      r0,#0x2a
00004e  d10b              BNE      |L54.104|
;;;3140     	{ 
;;;3141   	    DBG_Print(3, "SD_Erase is ok\r\n"); 
000050  a118              ADR      r1,|L54.180|
000052  2003              MOVS     r0,#3
000054  f7fffffe          BL       DBG_Print
;;;3142      	    Status = SD_SetDeviceMode(SD_DMA_MODE);	
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       SD_SetDeviceMode
00005e  4604              MOV      r4,r0
;;;3143   	    DBG_Print(3, "MicroSD卡读写测试成功\r\n");// 
000060  a119              ADR      r1,|L54.200|
000062  2003              MOVS     r0,#3
000064  f7fffffe          BL       DBG_Print
                  |L54.104|
;;;3144     	}  
;;;3145   	return Status;
;;;3146   }
000068  b014              ADD      sp,sp,#0x50
00006a  4620              MOV      r0,r4                 ;3145
00006c  bd10              POP      {r4,pc}
;;;3147   
                          ENDP

00006e  0000              DCW      0x0000
                  |L54.112|
000070  53445f49          DCB      "SD_Init is ok\r\n",0
000074  6e697420
000078  6973206f
00007c  6b0d0a00
                  |L54.128|
000080  53445f47          DCB      "SD_GetCardInfo is ok\r\n",0
000084  65744361
000088  7264496e
00008c  666f2069
000090  73206f6b
000094  0d0a00  
000097  00                DCB      0
                  |L54.152|
000098  53445f53          DCB      "SD_SelectDeselect is ok\r\n",0
00009c  656c6563
0000a0  74446573
0000a4  656c6563
0000a8  74206973
0000ac  206f6b0d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L54.180|
0000b4  53445f45          DCB      "SD_Erase is ok\r\n",0
0000b8  72617365
0000bc  20697320
0000c0  6f6b0d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L54.200|
0000c8  4d696372          DCB      "MicroSD",191,168,182,193,208,180,178,226,202,212,179,201
0000cc  6f5344bf
0000d0  a8b6c1d0
0000d4  b4b2e2ca
0000d8  d4b3c9  
0000db  b9a60d0a          DCB      185,166,"\r\n",0
0000df  00      

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;41     ********************************************************/
;;;42     void USART_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;43     {
000002  b085              SUB      sp,sp,#0x14
;;;44     	USART_InitTypeDef	USART_InitStructure;
;;;45     	GPIO_InitTypeDef 	GPIO_InitStructure;	
;;;46     	
;;;47     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);	//使能串口1时钟		 高速时钟
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50     	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);	//使能串口2时钟		 低速时钟
;;;51     	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE);	//使能串口3时钟		 低速时钟
;;;52     	//配置USART1 RX （PA.10）为浮空输入
;;;53     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;
00001c  f44f6080          MOV      r0,#0x400
000020  f8ad0010          STRH     r0,[sp,#0x10]
;;;54     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
000024  2403              MOVS     r4,#3
000026  f88d4012          STRB     r4,[sp,#0x12]
;;;55     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
00002a  2004              MOVS     r0,#4
;;;56     	GPIO_Init(GPIOA,&GPIO_InitStructure);
00002c  4d19              LDR      r5,|L55.148|
00002e  f88d0013          STRB     r0,[sp,#0x13]         ;55
000032  a904              ADD      r1,sp,#0x10
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       GPIO_Init
;;;57     	//配置USART1 RX （PA.9）为复用推挽输出
;;;58     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;
00003a  1569              ASRS     r1,r5,#21
00003c  f8ad1010          STRH     r1,[sp,#0x10]
;;;59     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
000040  f88d4012          STRB     r4,[sp,#0x12]
;;;60     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;
000044  2018              MOVS     r0,#0x18
000046  f88d0013          STRB     r0,[sp,#0x13]
;;;61     	GPIO_Init(GPIOA,&GPIO_InitStructure);
00004a  a904              ADD      r1,sp,#0x10
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       GPIO_Init
;;;62     
;;;63     	//******************************************************************************
;;;64     	// 串口1参数初始化定义部分,串口1参数为38400 ， 8 ，1 ，N  接收中断方式
;;;65     	//******************************************************************************
;;;66     	USART_InitStructure.USART_BaudRate=115200;						//设定传输速率
000052  f44f30e1          MOV      r0,#0x1c200
;;;67     	USART_InitStructure.USART_WordLength = USART_WordLength_8b; 	//传输数据位数
000056  9000              STR      r0,[sp,#0]
000058  2000              MOVS     r0,#0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;68         USART_InitStructure.USART_StopBits = USART_StopBits_1; 			//设定停止位个数	
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;69         USART_InitStructure.USART_Parity = USART_Parity_No; 			//不用检验位
000062  f8ad0008          STRH     r0,[sp,#8]
;;;70         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;71     																	//不用流量控制
;;;72         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//使用发送和接收端口
00006a  200c              MOVS     r0,#0xc
;;;73     	USART_Init(USART1,&USART_InitStructure);						//初始化串口1
00006c  4c0a              LDR      r4,|L55.152|
00006e  f8ad000a          STRH     r0,[sp,#0xa]          ;72
000072  4669              MOV      r1,sp
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USART_Init
;;;74     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);  				//使能串口1接收中断
00007a  2201              MOVS     r2,#1
00007c  f2405125          MOV      r1,#0x525
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       USART_ITConfig
;;;75     	USART_Cmd(USART1,ENABLE);										//使能串口1
000086  2101              MOVS     r1,#1
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       USART_Cmd
;;;76     }
00008e  b005              ADD      sp,sp,#0x14
000090  bd30              POP      {r4,r5,pc}
;;;77     
                          ENDP

000092  0000              DCW      0x0000
                  |L55.148|
                          DCD      0x40010800
                  |L55.152|
                          DCD      0x40013800

                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=1

                  Usart1_Init PROC
;;;107     *******************************************************************************/
;;;108    void Usart1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110        USART_Configuration();
000002  f7fffffe          BL       USART_Configuration
;;;111        NVIC_Configuration();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      NVIC_Configuration
;;;112    
;;;113        return;
;;;114    }
;;;115    /*****************************************************
                          ENDP


                          AREA ||i.Usart1_PutChar||, CODE, READONLY, ALIGN=2

                  Usart1_PutChar PROC
;;;120    *****************************************************/
;;;121    void Usart1_PutChar(u8 ch)
000000  b510              PUSH     {r4,lr}
;;;122    {	
;;;123    	USART_SendData(USART1,ch);
000002  4c06              LDR      r4,|L57.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_SendData
                  |L57.12|
;;;124    	while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET); 	//等待数据发送完毕
00000c  2180              MOVS     r1,#0x80
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L57.12|
;;;125    }
000018  bd10              POP      {r4,pc}
;;;126    
                          ENDP

00001a  0000              DCW      0x0000
                  |L57.28|
                          DCD      0x40013800

                          AREA ||i.Usart1_Write||, CODE, READONLY, ALIGN=1

                  Usart1_Write PROC
;;;132    *****************************************************/
;;;133    void Usart1_Write(u8 *p, uint32 ulLen)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {	
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;135    	while(ulLen--)
;;;136    	{
;;;137    		Usart1_PutChar(*p);
;;;138    		p++;
000006  e003              B        |L58.16|
                  |L58.8|
000008  7820              LDRB     r0,[r4,#0]            ;137
00000a  f7fffffe          BL       Usart1_PutChar
00000e  1c64              ADDS     r4,r4,#1
                  |L58.16|
000010  1e6d              SUBS     r5,r5,#1              ;135
000012  d2f9              BCS      |L58.8|
;;;139    	}
;;;140    }
000014  bd70              POP      {r4-r6,pc}
;;;141    /*******************************************************************************
                          ENDP


                          AREA ||i.convert_from_bytes_to_power_of_two||, CODE, READONLY, ALIGN=1

                  convert_from_bytes_to_power_of_two PROC
;;;3009     */
;;;3010   static uint8_t convert_from_bytes_to_power_of_two(uint16_t NumberOfBytes)
000000  2100              MOVS     r1,#0
;;;3011   {
;;;3012     uint8_t count = 0;
;;;3013   
;;;3014     while (NumberOfBytes != 1)
000002  e002              B        |L59.10|
                  |L59.4|
;;;3015     {
;;;3016       NumberOfBytes >>= 1;
000004  0840              LSRS     r0,r0,#1
;;;3017       count++;
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
                  |L59.10|
00000a  2801              CMP      r0,#1                 ;3014
00000c  d1fa              BNE      |L59.4|
;;;3018     }
;;;3019     return(count);
00000e  4608              MOV      r0,r1
;;;3020   }
000010  4770              BX       lr
;;;3021   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  CSD_Tab
                          %        16
                  CID_Tab
                          %        16
                  SDIO_InitStructure
                          %        24
                  SDIO_CmdInitStructure
                          %        20
                  SDIO_DataInitStructure
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Font8x16
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
00001c  00000000          DCB      0x00,0x00,0x00,0x00
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  00000000          DCB      0x00,0x00,0x00,0x00
00002c  00000000          DCB      0x00,0x00,0x00,0x00
000030  00000000          DCB      0x00,0x00,0x00,0x00
000034  00000000          DCB      0x00,0x00,0x00,0x00
000038  00000000          DCB      0x00,0x00,0x00,0x00
00003c  00000000          DCB      0x00,0x00,0x00,0x00
000040  00000000          DCB      0x00,0x00,0x00,0x00
000044  00000000          DCB      0x00,0x00,0x00,0x00
000048  00000000          DCB      0x00,0x00,0x00,0x00
00004c  00000000          DCB      0x00,0x00,0x00,0x00
000050  00000000          DCB      0x00,0x00,0x00,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
000058  00000000          DCB      0x00,0x00,0x00,0x00
00005c  00000000          DCB      0x00,0x00,0x00,0x00
000060  00000000          DCB      0x00,0x00,0x00,0x00
000064  00000000          DCB      0x00,0x00,0x00,0x00
000068  00000000          DCB      0x00,0x00,0x00,0x00
00006c  00000000          DCB      0x00,0x00,0x00,0x00
000070  00000000          DCB      0x00,0x00,0x00,0x00
000074  00000000          DCB      0x00,0x00,0x00,0x00
000078  00000000          DCB      0x00,0x00,0x00,0x00
00007c  00000000          DCB      0x00,0x00,0x00,0x00
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  00000000          DCB      0x00,0x00,0x00,0x00
000088  00000000          DCB      0x00,0x00,0x00,0x00
00008c  00000000          DCB      0x00,0x00,0x00,0x00
000090  00000000          DCB      0x00,0x00,0x00,0x00
000094  00000000          DCB      0x00,0x00,0x00,0x00
000098  00000000          DCB      0x00,0x00,0x00,0x00
00009c  00000000          DCB      0x00,0x00,0x00,0x00
0000a0  00000000          DCB      0x00,0x00,0x00,0x00
0000a4  00000000          DCB      0x00,0x00,0x00,0x00
0000a8  00000000          DCB      0x00,0x00,0x00,0x00
0000ac  00000000          DCB      0x00,0x00,0x00,0x00
0000b0  00000000          DCB      0x00,0x00,0x00,0x00
0000b4  00000000          DCB      0x00,0x00,0x00,0x00
0000b8  00000000          DCB      0x00,0x00,0x00,0x00
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
0000c0  00000000          DCB      0x00,0x00,0x00,0x00
0000c4  00000000          DCB      0x00,0x00,0x00,0x00
0000c8  00000000          DCB      0x00,0x00,0x00,0x00
0000cc  00000000          DCB      0x00,0x00,0x00,0x00
0000d0  00000000          DCB      0x00,0x00,0x00,0x00
0000d4  00000000          DCB      0x00,0x00,0x00,0x00
0000d8  00000000          DCB      0x00,0x00,0x00,0x00
0000dc  00000000          DCB      0x00,0x00,0x00,0x00
0000e0  00000000          DCB      0x00,0x00,0x00,0x00
0000e4  00000000          DCB      0x00,0x00,0x00,0x00
0000e8  00000000          DCB      0x00,0x00,0x00,0x00
0000ec  00000000          DCB      0x00,0x00,0x00,0x00
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
0000f4  00000000          DCB      0x00,0x00,0x00,0x00
0000f8  00000000          DCB      0x00,0x00,0x00,0x00
0000fc  00000000          DCB      0x00,0x00,0x00,0x00
000100  00000000          DCB      0x00,0x00,0x00,0x00
000104  00000000          DCB      0x00,0x00,0x00,0x00
000108  00000000          DCB      0x00,0x00,0x00,0x00
00010c  00000000          DCB      0x00,0x00,0x00,0x00
000110  00000000          DCB      0x00,0x00,0x00,0x00
000114  00000000          DCB      0x00,0x00,0x00,0x00
000118  00000000          DCB      0x00,0x00,0x00,0x00
00011c  00000000          DCB      0x00,0x00,0x00,0x00
000120  00000000          DCB      0x00,0x00,0x00,0x00
000124  00000000          DCB      0x00,0x00,0x00,0x00
000128  00000000          DCB      0x00,0x00,0x00,0x00
00012c  00000000          DCB      0x00,0x00,0x00,0x00
000130  00000000          DCB      0x00,0x00,0x00,0x00
000134  00000000          DCB      0x00,0x00,0x00,0x00
000138  00000000          DCB      0x00,0x00,0x00,0x00
00013c  00000000          DCB      0x00,0x00,0x00,0x00
000140  00000000          DCB      0x00,0x00,0x00,0x00
000144  00000000          DCB      0x00,0x00,0x00,0x00
000148  00000000          DCB      0x00,0x00,0x00,0x00
00014c  00000000          DCB      0x00,0x00,0x00,0x00
000150  00000000          DCB      0x00,0x00,0x00,0x00
000154  00000000          DCB      0x00,0x00,0x00,0x00
000158  00000000          DCB      0x00,0x00,0x00,0x00
00015c  00000000          DCB      0x00,0x00,0x00,0x00
000160  00000000          DCB      0x00,0x00,0x00,0x00
000164  00000000          DCB      0x00,0x00,0x00,0x00
000168  00000000          DCB      0x00,0x00,0x00,0x00
00016c  00000000          DCB      0x00,0x00,0x00,0x00
000170  00000000          DCB      0x00,0x00,0x00,0x00
000174  00000000          DCB      0x00,0x00,0x00,0x00
000178  00000000          DCB      0x00,0x00,0x00,0x00
00017c  00000000          DCB      0x00,0x00,0x00,0x00
000180  00000000          DCB      0x00,0x00,0x00,0x00
000184  00000000          DCB      0x00,0x00,0x00,0x00
000188  00000000          DCB      0x00,0x00,0x00,0x00
00018c  00000000          DCB      0x00,0x00,0x00,0x00
000190  00000000          DCB      0x00,0x00,0x00,0x00
000194  00000000          DCB      0x00,0x00,0x00,0x00
000198  00000000          DCB      0x00,0x00,0x00,0x00
00019c  00000000          DCB      0x00,0x00,0x00,0x00
0001a0  00000000          DCB      0x00,0x00,0x00,0x00
0001a4  00000000          DCB      0x00,0x00,0x00,0x00
0001a8  00000000          DCB      0x00,0x00,0x00,0x00
0001ac  00000000          DCB      0x00,0x00,0x00,0x00
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
0001b4  00000000          DCB      0x00,0x00,0x00,0x00
0001b8  00000000          DCB      0x00,0x00,0x00,0x00
0001bc  00000000          DCB      0x00,0x00,0x00,0x00
0001c0  00000000          DCB      0x00,0x00,0x00,0x00
0001c4  00000000          DCB      0x00,0x00,0x00,0x00
0001c8  00000000          DCB      0x00,0x00,0x00,0x00
0001cc  00000000          DCB      0x00,0x00,0x00,0x00
0001d0  00000000          DCB      0x00,0x00,0x00,0x00
0001d4  00000000          DCB      0x00,0x00,0x00,0x00
0001d8  00000000          DCB      0x00,0x00,0x00,0x00
0001dc  00000000          DCB      0x00,0x00,0x00,0x00
0001e0  00000000          DCB      0x00,0x00,0x00,0x00
0001e4  00000000          DCB      0x00,0x00,0x00,0x00
0001e8  00000000          DCB      0x00,0x00,0x00,0x00
0001ec  00000000          DCB      0x00,0x00,0x00,0x00
0001f0  00000000          DCB      0x00,0x00,0x00,0x00
0001f4  00000000          DCB      0x00,0x00,0x00,0x00
0001f8  00000000          DCB      0x00,0x00,0x00,0x00
0001fc  00000000          DCB      0x00,0x00,0x00,0x00
000200  00000000          DCB      0x00,0x00,0x00,0x00
000204  00000000          DCB      0x00,0x00,0x00,0x00
000208  00000000          DCB      0x00,0x00,0x00,0x00
00020c  00000000          DCB      0x00,0x00,0x00,0x00
000210  00000010          DCB      0x00,0x00,0x00,0x10
000214  10101010          DCB      0x10,0x10,0x10,0x10
000218  10001010          DCB      0x10,0x00,0x10,0x10
00021c  00000000          DCB      0x00,0x00,0x00,0x00
000220  00000024          DCB      0x00,0x00,0x00,0x24
000224  24240000          DCB      0x24,0x24,0x00,0x00
000228  00000000          DCB      0x00,0x00,0x00,0x00
00022c  00000000          DCB      0x00,0x00,0x00,0x00
000230  00000024          DCB      0x00,0x00,0x00,0x24
000234  247e2424          DCB      0x24,0x7e,0x24,0x24
000238  247e2424          DCB      0x24,0x7e,0x24,0x24
00023c  00000000          DCB      0x00,0x00,0x00,0x00
000240  00000010          DCB      0x00,0x00,0x00,0x10
000244  7c90907c          DCB      0x7c,0x90,0x90,0x7c
000248  12127c10          DCB      0x12,0x12,0x7c,0x10
00024c  00000000          DCB      0x00,0x00,0x00,0x00
000250  00000000          DCB      0x00,0x00,0x00,0x00
000254  62640810          DCB      0x62,0x64,0x08,0x10
000258  204c8c00          DCB      0x20,0x4c,0x8c,0x00
00025c  00000000          DCB      0x00,0x00,0x00,0x00
000260  00000000          DCB      0x00,0x00,0x00,0x00
000264  18242050          DCB      0x18,0x24,0x20,0x50
000268  8a844a30          DCB      0x8a,0x84,0x4a,0x30
00026c  00000000          DCB      0x00,0x00,0x00,0x00
000270  00000010          DCB      0x00,0x00,0x00,0x10
000274  10200000          DCB      0x10,0x20,0x00,0x00
000278  00000000          DCB      0x00,0x00,0x00,0x00
00027c  00000000          DCB      0x00,0x00,0x00,0x00
000280  00000810          DCB      0x00,0x00,0x08,0x10
000284  20202020          DCB      0x20,0x20,0x20,0x20
000288  20202010          DCB      0x20,0x20,0x20,0x10
00028c  08000000          DCB      0x08,0x00,0x00,0x00
000290  00002010          DCB      0x00,0x00,0x20,0x10
000294  08080808          DCB      0x08,0x08,0x08,0x08
000298  08080810          DCB      0x08,0x08,0x08,0x10
00029c  20000000          DCB      0x20,0x00,0x00,0x00
0002a0  00000000          DCB      0x00,0x00,0x00,0x00
0002a4  00105438          DCB      0x00,0x10,0x54,0x38
0002a8  38541000          DCB      0x38,0x54,0x10,0x00
0002ac  00000000          DCB      0x00,0x00,0x00,0x00
0002b0  00000000          DCB      0x00,0x00,0x00,0x00
0002b4  0010107c          DCB      0x00,0x10,0x10,0x7c
0002b8  10100000          DCB      0x10,0x10,0x00,0x00
0002bc  00000000          DCB      0x00,0x00,0x00,0x00
0002c0  00000000          DCB      0x00,0x00,0x00,0x00
0002c4  00000000          DCB      0x00,0x00,0x00,0x00
0002c8  00001010          DCB      0x00,0x00,0x10,0x10
0002cc  20000000          DCB      0x20,0x00,0x00,0x00
0002d0  00000000          DCB      0x00,0x00,0x00,0x00
0002d4  0000007c          DCB      0x00,0x00,0x00,0x7c
0002d8  00000000          DCB      0x00,0x00,0x00,0x00
0002dc  00000000          DCB      0x00,0x00,0x00,0x00
0002e0  00000000          DCB      0x00,0x00,0x00,0x00
0002e4  00000000          DCB      0x00,0x00,0x00,0x00
0002e8  00000010          DCB      0x00,0x00,0x00,0x10
0002ec  00000000          DCB      0x00,0x00,0x00,0x00
0002f0  00000000          DCB      0x00,0x00,0x00,0x00
0002f4  00020408          DCB      0x00,0x02,0x04,0x08
0002f8  10204000          DCB      0x10,0x20,0x40,0x00
0002fc  00000000          DCB      0x00,0x00,0x00,0x00
000300  00000038          DCB      0x00,0x00,0x00,0x38
000304  44444c54          DCB      0x44,0x44,0x4c,0x54
000308  64444438          DCB      0x64,0x44,0x44,0x38
00030c  00000000          DCB      0x00,0x00,0x00,0x00
000310  00000010          DCB      0x00,0x00,0x00,0x10
000314  30101010          DCB      0x30,0x10,0x10,0x10
000318  10101038          DCB      0x10,0x10,0x10,0x38
00031c  00000000          DCB      0x00,0x00,0x00,0x00
000320  00000038          DCB      0x00,0x00,0x00,0x38
000324  44040408          DCB      0x44,0x04,0x04,0x08
000328  1020407c          DCB      0x10,0x20,0x40,0x7c
00032c  00000000          DCB      0x00,0x00,0x00,0x00
000330  0000007c          DCB      0x00,0x00,0x00,0x7c
000334  04081038          DCB      0x04,0x08,0x10,0x38
000338  04040478          DCB      0x04,0x04,0x04,0x78
00033c  00000000          DCB      0x00,0x00,0x00,0x00
000340  00000008          DCB      0x00,0x00,0x00,0x08
000344  18284848          DCB      0x18,0x28,0x48,0x48
000348  7c080808          DCB      0x7c,0x08,0x08,0x08
00034c  00000000          DCB      0x00,0x00,0x00,0x00
000350  0000007c          DCB      0x00,0x00,0x00,0x7c
000354  40404078          DCB      0x40,0x40,0x40,0x78
000358  04040478          DCB      0x04,0x04,0x04,0x78
00035c  00000000          DCB      0x00,0x00,0x00,0x00
000360  0000003c          DCB      0x00,0x00,0x00,0x3c
000364  40404078          DCB      0x40,0x40,0x40,0x78
000368  44444438          DCB      0x44,0x44,0x44,0x38
00036c  00000000          DCB      0x00,0x00,0x00,0x00
000370  0000007c          DCB      0x00,0x00,0x00,0x7c
000374  04040810          DCB      0x04,0x04,0x08,0x10
000378  20202020          DCB      0x20,0x20,0x20,0x20
00037c  00000000          DCB      0x00,0x00,0x00,0x00
000380  00000038          DCB      0x00,0x00,0x00,0x38
000384  44444438          DCB      0x44,0x44,0x44,0x38
000388  44444438          DCB      0x44,0x44,0x44,0x38
00038c  00000000          DCB      0x00,0x00,0x00,0x00
000390  00000038          DCB      0x00,0x00,0x00,0x38
000394  4444443c          DCB      0x44,0x44,0x44,0x3c
000398  04040438          DCB      0x04,0x04,0x04,0x38
00039c  00000000          DCB      0x00,0x00,0x00,0x00
0003a0  00000000          DCB      0x00,0x00,0x00,0x00
0003a4  00000010          DCB      0x00,0x00,0x00,0x10
0003a8  00001000          DCB      0x00,0x00,0x10,0x00
0003ac  00000000          DCB      0x00,0x00,0x00,0x00
0003b0  00000000          DCB      0x00,0x00,0x00,0x00
0003b4  00000000          DCB      0x00,0x00,0x00,0x00
0003b8  10001010          DCB      0x10,0x00,0x10,0x10
0003bc  20000000          DCB      0x20,0x00,0x00,0x00
0003c0  00000000          DCB      0x00,0x00,0x00,0x00
0003c4  00040810          DCB      0x00,0x04,0x08,0x10
0003c8  20100804          DCB      0x20,0x10,0x08,0x04
0003cc  00000000          DCB      0x00,0x00,0x00,0x00
0003d0  00000000          DCB      0x00,0x00,0x00,0x00
0003d4  0000007c          DCB      0x00,0x00,0x00,0x7c
0003d8  007c0000          DCB      0x00,0x7c,0x00,0x00
0003dc  00000000          DCB      0x00,0x00,0x00,0x00
0003e0  00000000          DCB      0x00,0x00,0x00,0x00
0003e4  00201008          DCB      0x00,0x20,0x10,0x08
0003e8  04081020          DCB      0x04,0x08,0x10,0x20
0003ec  00000000          DCB      0x00,0x00,0x00,0x00
0003f0  00003844          DCB      0x00,0x00,0x38,0x44
0003f4  44040810          DCB      0x44,0x04,0x08,0x10
0003f8  10001010          DCB      0x10,0x00,0x10,0x10
0003fc  00000000          DCB      0x00,0x00,0x00,0x00
000400  00000000          DCB      0x00,0x00,0x00,0x00
000404  0038445c          DCB      0x00,0x38,0x44,0x5c
000408  545c403c          DCB      0x54,0x5c,0x40,0x3c
00040c  00000000          DCB      0x00,0x00,0x00,0x00
000410  00001824          DCB      0x00,0x00,0x18,0x24
000414  4242427e          DCB      0x42,0x42,0x42,0x7e
000418  42424242          DCB      0x42,0x42,0x42,0x42
00041c  00000000          DCB      0x00,0x00,0x00,0x00
000420  00007c42          DCB      0x00,0x00,0x7c,0x42
000424  42427c42          DCB      0x42,0x42,0x7c,0x42
000428  4242427c          DCB      0x42,0x42,0x42,0x7c
00042c  00000000          DCB      0x00,0x00,0x00,0x00
000430  00003c42          DCB      0x00,0x00,0x3c,0x42
000434  40404040          DCB      0x40,0x40,0x40,0x40
000438  4040423c          DCB      0x40,0x40,0x42,0x3c
00043c  00000000          DCB      0x00,0x00,0x00,0x00
000440  00007c42          DCB      0x00,0x00,0x7c,0x42
000444  42424242          DCB      0x42,0x42,0x42,0x42
000448  4242427c          DCB      0x42,0x42,0x42,0x7c
00044c  00000000          DCB      0x00,0x00,0x00,0x00
000450  00007e40          DCB      0x00,0x00,0x7e,0x40
000454  40407840          DCB      0x40,0x40,0x78,0x40
000458  4040407e          DCB      0x40,0x40,0x40,0x7e
00045c  00000000          DCB      0x00,0x00,0x00,0x00
000460  00007e40          DCB      0x00,0x00,0x7e,0x40
000464  40407840          DCB      0x40,0x40,0x78,0x40
000468  40404040          DCB      0x40,0x40,0x40,0x40
00046c  00000000          DCB      0x00,0x00,0x00,0x00
000470  00003c42          DCB      0x00,0x00,0x3c,0x42
000474  40405e42          DCB      0x40,0x40,0x5e,0x42
000478  4242423c          DCB      0x42,0x42,0x42,0x3c
00047c  00000000          DCB      0x00,0x00,0x00,0x00
000480  00004242          DCB      0x00,0x00,0x42,0x42
000484  42427e42          DCB      0x42,0x42,0x7e,0x42
000488  42424242          DCB      0x42,0x42,0x42,0x42
00048c  00000000          DCB      0x00,0x00,0x00,0x00
000490  00003810          DCB      0x00,0x00,0x38,0x10
000494  10101010          DCB      0x10,0x10,0x10,0x10
000498  10101038          DCB      0x10,0x10,0x10,0x38
00049c  00000000          DCB      0x00,0x00,0x00,0x00
0004a0  00001c08          DCB      0x00,0x00,0x1c,0x08
0004a4  08080808          DCB      0x08,0x08,0x08,0x08
0004a8  08084830          DCB      0x08,0x08,0x48,0x30
0004ac  00000000          DCB      0x00,0x00,0x00,0x00
0004b0  00004244          DCB      0x00,0x00,0x42,0x44
0004b4  48506060          DCB      0x48,0x50,0x60,0x60
0004b8  50484442          DCB      0x50,0x48,0x44,0x42
0004bc  00000000          DCB      0x00,0x00,0x00,0x00
0004c0  00004040          DCB      0x00,0x00,0x40,0x40
0004c4  40404040          DCB      0x40,0x40,0x40,0x40
0004c8  4040407e          DCB      0x40,0x40,0x40,0x7e
0004cc  00000000          DCB      0x00,0x00,0x00,0x00
0004d0  00008282          DCB      0x00,0x00,0x82,0x82
0004d4  c6c6aaaa          DCB      0xc6,0xc6,0xaa,0xaa
0004d8  92928282          DCB      0x92,0x92,0x82,0x82
0004dc  00000000          DCB      0x00,0x00,0x00,0x00
0004e0  00004262          DCB      0x00,0x00,0x42,0x62
0004e4  6252524a          DCB      0x62,0x52,0x52,0x4a
0004e8  4a464642          DCB      0x4a,0x46,0x46,0x42
0004ec  00000000          DCB      0x00,0x00,0x00,0x00
0004f0  00003c42          DCB      0x00,0x00,0x3c,0x42
0004f4  42424242          DCB      0x42,0x42,0x42,0x42
0004f8  4242423c          DCB      0x42,0x42,0x42,0x3c
0004fc  00000000          DCB      0x00,0x00,0x00,0x00
000500  00007c42          DCB      0x00,0x00,0x7c,0x42
000504  4242427c          DCB      0x42,0x42,0x42,0x7c
000508  40404040          DCB      0x40,0x40,0x40,0x40
00050c  00000000          DCB      0x00,0x00,0x00,0x00
000510  00003c42          DCB      0x00,0x00,0x3c,0x42
000514  42424242          DCB      0x42,0x42,0x42,0x42
000518  42424a3c          DCB      0x42,0x42,0x4a,0x3c
00051c  0e000000          DCB      0x0e,0x00,0x00,0x00
000520  00007c42          DCB      0x00,0x00,0x7c,0x42
000524  4242427c          DCB      0x42,0x42,0x42,0x7c
000528  50484442          DCB      0x50,0x48,0x44,0x42
00052c  00000000          DCB      0x00,0x00,0x00,0x00
000530  00003c42          DCB      0x00,0x00,0x3c,0x42
000534  40403c02          DCB      0x40,0x40,0x3c,0x02
000538  0202423c          DCB      0x02,0x02,0x42,0x3c
00053c  00000000          DCB      0x00,0x00,0x00,0x00
000540  00007c10          DCB      0x00,0x00,0x7c,0x10
000544  10101010          DCB      0x10,0x10,0x10,0x10
000548  10101010          DCB      0x10,0x10,0x10,0x10
00054c  00000000          DCB      0x00,0x00,0x00,0x00
000550  00004242          DCB      0x00,0x00,0x42,0x42
000554  42424242          DCB      0x42,0x42,0x42,0x42
000558  4242423c          DCB      0x42,0x42,0x42,0x3c
00055c  00000000          DCB      0x00,0x00,0x00,0x00
000560  00004444          DCB      0x00,0x00,0x44,0x44
000564  44442828          DCB      0x44,0x44,0x28,0x28
000568  28101010          DCB      0x28,0x10,0x10,0x10
00056c  00000000          DCB      0x00,0x00,0x00,0x00
000570  00008282          DCB      0x00,0x00,0x82,0x82
000574  82825454          DCB      0x82,0x82,0x54,0x54
000578  54282828          DCB      0x54,0x28,0x28,0x28
00057c  00000000          DCB      0x00,0x00,0x00,0x00
000580  00004242          DCB      0x00,0x00,0x42,0x42
000584  24181818          DCB      0x24,0x18,0x18,0x18
000588  24244242          DCB      0x24,0x24,0x42,0x42
00058c  00000000          DCB      0x00,0x00,0x00,0x00
000590  00004444          DCB      0x00,0x00,0x44,0x44
000594  44442828          DCB      0x44,0x44,0x28,0x28
000598  10101010          DCB      0x10,0x10,0x10,0x10
00059c  00000000          DCB      0x00,0x00,0x00,0x00
0005a0  00007e02          DCB      0x00,0x00,0x7e,0x02
0005a4  02040810          DCB      0x02,0x04,0x08,0x10
0005a8  2040407e          DCB      0x20,0x40,0x40,0x7e
0005ac  00000000          DCB      0x00,0x00,0x00,0x00
0005b0  00003820          DCB      0x00,0x00,0x38,0x20
0005b4  20202020          DCB      0x20,0x20,0x20,0x20
0005b8  20202038          DCB      0x20,0x20,0x20,0x38
0005bc  00000000          DCB      0x00,0x00,0x00,0x00
0005c0  00000000          DCB      0x00,0x00,0x00,0x00
0005c4  00004020          DCB      0x00,0x00,0x40,0x20
0005c8  10080402          DCB      0x10,0x08,0x04,0x02
0005cc  00000000          DCB      0x00,0x00,0x00,0x00
0005d0  00001c04          DCB      0x00,0x00,0x1c,0x04
0005d4  04040404          DCB      0x04,0x04,0x04,0x04
0005d8  0404041c          DCB      0x04,0x04,0x04,0x1c
0005dc  00000000          DCB      0x00,0x00,0x00,0x00
0005e0  00000000          DCB      0x00,0x00,0x00,0x00
0005e4  10284400          DCB      0x10,0x28,0x44,0x00
0005e8  00000000          DCB      0x00,0x00,0x00,0x00
0005ec  00000000          DCB      0x00,0x00,0x00,0x00
0005f0  00000000          DCB      0x00,0x00,0x00,0x00
0005f4  00000000          DCB      0x00,0x00,0x00,0x00
0005f8  00000000          DCB      0x00,0x00,0x00,0x00
0005fc  ff000000          DCB      0xff,0x00,0x00,0x00
000600  00000010          DCB      0x00,0x00,0x00,0x10
000604  10080000          DCB      0x10,0x08,0x00,0x00
000608  00000000          DCB      0x00,0x00,0x00,0x00
00060c  00000000          DCB      0x00,0x00,0x00,0x00
000610  00000000          DCB      0x00,0x00,0x00,0x00
000614  0078043c          DCB      0x00,0x78,0x04,0x3c
000618  4444443a          DCB      0x44,0x44,0x44,0x3a
00061c  00000000          DCB      0x00,0x00,0x00,0x00
000620  00004040          DCB      0x00,0x00,0x40,0x40
000624  405c6242          DCB      0x40,0x5c,0x62,0x42
000628  4242625c          DCB      0x42,0x42,0x62,0x5c
00062c  00000000          DCB      0x00,0x00,0x00,0x00
000630  00000000          DCB      0x00,0x00,0x00,0x00
000634  003c4240          DCB      0x00,0x3c,0x42,0x40
000638  4040423c          DCB      0x40,0x40,0x42,0x3c
00063c  00000000          DCB      0x00,0x00,0x00,0x00
000640  00000202          DCB      0x00,0x00,0x02,0x02
000644  023a4642          DCB      0x02,0x3a,0x46,0x42
000648  4242463a          DCB      0x42,0x42,0x46,0x3a
00064c  00000000          DCB      0x00,0x00,0x00,0x00
000650  00000000          DCB      0x00,0x00,0x00,0x00
000654  003c4242          DCB      0x00,0x3c,0x42,0x42
000658  7e40423c          DCB      0x7e,0x40,0x42,0x3c
00065c  00000000          DCB      0x00,0x00,0x00,0x00
000660  00000e10          DCB      0x00,0x00,0x0e,0x10
000664  10103c10          DCB      0x10,0x10,0x3c,0x10
000668  10101010          DCB      0x10,0x10,0x10,0x10
00066c  00000000          DCB      0x00,0x00,0x00,0x00
000670  00000000          DCB      0x00,0x00,0x00,0x00
000674  003e4242          DCB      0x00,0x3e,0x42,0x42
000678  42423e02          DCB      0x42,0x42,0x3e,0x02
00067c  023c0000          DCB      0x02,0x3c,0x00,0x00
000680  00004040          DCB      0x00,0x00,0x40,0x40
000684  405c6242          DCB      0x40,0x5c,0x62,0x42
000688  42424242          DCB      0x42,0x42,0x42,0x42
00068c  00000000          DCB      0x00,0x00,0x00,0x00
000690  00000008          DCB      0x00,0x00,0x00,0x08
000694  00080808          DCB      0x00,0x08,0x08,0x08
000698  08080808          DCB      0x08,0x08,0x08,0x08
00069c  00000000          DCB      0x00,0x00,0x00,0x00
0006a0  00000004          DCB      0x00,0x00,0x00,0x04
0006a4  00040404          DCB      0x00,0x04,0x04,0x04
0006a8  04040404          DCB      0x04,0x04,0x04,0x04
0006ac  44380000          DCB      0x44,0x38,0x00,0x00
0006b0  00004040          DCB      0x00,0x00,0x40,0x40
0006b4  40424448          DCB      0x40,0x42,0x44,0x48
0006b8  50684442          DCB      0x50,0x68,0x44,0x42
0006bc  00000000          DCB      0x00,0x00,0x00,0x00
0006c0  00001010          DCB      0x00,0x00,0x10,0x10
0006c4  10101010          DCB      0x10,0x10,0x10,0x10
0006c8  10101010          DCB      0x10,0x10,0x10,0x10
0006cc  00000000          DCB      0x00,0x00,0x00,0x00
0006d0  00000000          DCB      0x00,0x00,0x00,0x00
0006d4  00ec9292          DCB      0x00,0xec,0x92,0x92
0006d8  92929292          DCB      0x92,0x92,0x92,0x92
0006dc  00000000          DCB      0x00,0x00,0x00,0x00
0006e0  00000000          DCB      0x00,0x00,0x00,0x00
0006e4  007c4242          DCB      0x00,0x7c,0x42,0x42
0006e8  42424242          DCB      0x42,0x42,0x42,0x42
0006ec  00000000          DCB      0x00,0x00,0x00,0x00
0006f0  00000000          DCB      0x00,0x00,0x00,0x00
0006f4  003c4242          DCB      0x00,0x3c,0x42,0x42
0006f8  4242423c          DCB      0x42,0x42,0x42,0x3c
0006fc  00000000          DCB      0x00,0x00,0x00,0x00
000700  00000000          DCB      0x00,0x00,0x00,0x00
000704  005c6242          DCB      0x00,0x5c,0x62,0x42
000708  4242625c          DCB      0x42,0x42,0x62,0x5c
00070c  40400000          DCB      0x40,0x40,0x00,0x00
000710  00000000          DCB      0x00,0x00,0x00,0x00
000714  003a4642          DCB      0x00,0x3a,0x46,0x42
000718  4242463a          DCB      0x42,0x42,0x46,0x3a
00071c  02020000          DCB      0x02,0x02,0x00,0x00
000720  00000000          DCB      0x00,0x00,0x00,0x00
000724  005c6240          DCB      0x00,0x5c,0x62,0x40
000728  40404040          DCB      0x40,0x40,0x40,0x40
00072c  00000000          DCB      0x00,0x00,0x00,0x00
000730  00000000          DCB      0x00,0x00,0x00,0x00
000734  003c4240          DCB      0x00,0x3c,0x42,0x40
000738  3c02423c          DCB      0x3c,0x02,0x42,0x3c
00073c  00000000          DCB      0x00,0x00,0x00,0x00
000740  00000020          DCB      0x00,0x00,0x00,0x20
000744  20782020          DCB      0x20,0x78,0x20,0x20
000748  2020221c          DCB      0x20,0x20,0x22,0x1c
00074c  00000000          DCB      0x00,0x00,0x00,0x00
000750  00000000          DCB      0x00,0x00,0x00,0x00
000754  00424242          DCB      0x00,0x42,0x42,0x42
000758  4242423e          DCB      0x42,0x42,0x42,0x3e
00075c  00000000          DCB      0x00,0x00,0x00,0x00
000760  00000000          DCB      0x00,0x00,0x00,0x00
000764  00424242          DCB      0x00,0x42,0x42,0x42
000768  42422418          DCB      0x42,0x42,0x24,0x18
00076c  00000000          DCB      0x00,0x00,0x00,0x00
000770  00000000          DCB      0x00,0x00,0x00,0x00
000774  00828282          DCB      0x00,0x82,0x82,0x82
000778  9292aa44          DCB      0x92,0x92,0xaa,0x44
00077c  00000000          DCB      0x00,0x00,0x00,0x00
000780  00000000          DCB      0x00,0x00,0x00,0x00
000784  00424224          DCB      0x00,0x42,0x42,0x24
000788  18244242          DCB      0x18,0x24,0x42,0x42
00078c  00000000          DCB      0x00,0x00,0x00,0x00
000790  00000000          DCB      0x00,0x00,0x00,0x00
000794  00424242          DCB      0x00,0x42,0x42,0x42
000798  42423e02          DCB      0x42,0x42,0x3e,0x02
00079c  023c0000          DCB      0x02,0x3c,0x00,0x00
0007a0  00000000          DCB      0x00,0x00,0x00,0x00
0007a4  007e0204          DCB      0x00,0x7e,0x02,0x04
0007a8  1820407e          DCB      0x18,0x20,0x40,0x7e
0007ac  00000000          DCB      0x00,0x00,0x00,0x00
0007b0  00000810          DCB      0x00,0x00,0x08,0x10
0007b4  10102040          DCB      0x10,0x10,0x20,0x40
0007b8  20101010          DCB      0x20,0x10,0x10,0x10
0007bc  08000000          DCB      0x08,0x00,0x00,0x00
0007c0  00101010          DCB      0x00,0x10,0x10,0x10
0007c4  10101010          DCB      0x10,0x10,0x10,0x10
0007c8  10101010          DCB      0x10,0x10,0x10,0x10
0007cc  10101000          DCB      0x10,0x10,0x10,0x00
0007d0  00002010          DCB      0x00,0x00,0x20,0x10
0007d4  10100804          DCB      0x10,0x10,0x08,0x04
0007d8  08101010          DCB      0x08,0x10,0x10,0x10
0007dc  20000000          DCB      0x20,0x00,0x00,0x00
0007e0  00000000          DCB      0x00,0x00,0x00,0x00
0007e4  00002254          DCB      0x00,0x00,0x22,0x54
0007e8  88000000          DCB      0x88,0x00,0x00,0x00
0007ec  00000000          DCB      0x00,0x00,0x00,0x00
0007f0  00000000          DCB      0x00,0x00,0x00,0x00
0007f4  00000000          DCB      0x00,0x00,0x00,0x00
0007f8  00000000          DCB      0x00,0x00,0x00,0x00
0007fc  00000000          DCB      0x00,0x00,0x00,0x00
                  codeGB_16
000800  caf50100          DCB      0xca,0xf5,0x01,0x00
000804  01200110          DCB      0x01,0x20,0x01,0x10
000808  0100fffe          DCB      0x01,0x00,0xff,0xfe
00080c  01000380          DCB      0x01,0x00,0x03,0x80
000810  05400520          DCB      0x05,0x40,0x05,0x20
000814  09101118          DCB      0x09,0x10,0x11,0x18
000818  210ec104          DCB      0x21,0x0e,0xc1,0x04
00081c  01000100          DCB      0x01,0x00,0x01,0x00
000820  0000c9cc          DCB      0x00,0x00,0xc9,0xcc
000824  01000080          DCB      0x01,0x00,0x00,0x80
000828  7ffc0420          DCB      0x7f,0xfc,0x04,0x20
00082c  02403ff8          DCB      0x02,0x40,0x3f,0xf8
000830  22482428          DCB      0x22,0x48,0x24,0x28
000834  3fe82448          DCB      0x3f,0xe8,0x24,0x48
000838  244827c8          DCB      0x24,0x48,0x27,0xc8
00083c  24482408          DCB      0x24,0x48,0x24,0x08
000840  20282010          DCB      0x20,0x28,0x20,0x10
000844  b5e70100          DCB      0xb5,0xe7,0x01,0x00
000848  01000100          DCB      0x01,0x00,0x01,0x00
00084c  3ff82108          DCB      0x3f,0xf8,0x21,0x08
000850  21083ff8          DCB      0x21,0x08,0x3f,0xf8
000854  21082108          DCB      0x21,0x08,0x21,0x08
000858  21083ff8          DCB      0x21,0x08,0x3f,0xf8
00085c  21080102          DCB      0x21,0x08,0x01,0x02
000860  010200fe          DCB      0x01,0x02,0x00,0xfe
000864  0000d7d3          DCB      0x00,0x00,0xd7,0xd3
000868  00003ff0          DCB      0x00,0x00,0x3f,0xf0
00086c  00200040          DCB      0x00,0x20,0x00,0x40
000870  00800100          DCB      0x00,0x80,0x01,0x00
000874  01000104          DCB      0x01,0x00,0x01,0x04
000878  fffe0100          DCB      0xff,0xfe,0x01,0x00
00087c  01000100          DCB      0x01,0x00,0x01,0x00
000880  01000100          DCB      0x01,0x00,0x01,0x00
000884  05000200          DCB      0x05,0x00,0x02,0x00
000888  bfc60608          DCB      0xbf,0xc6,0x06,0x08
00088c  78880848          DCB      0x78,0x88,0x08,0x48
000890  0848fe08          DCB      0x08,0x48,0xfe,0x08
000894  18881c48          DCB      0x18,0x88,0x1c,0x48
000898  2a48280e          DCB      0x2a,0x48,0x28,0x0e
00089c  48788b88          DCB      0x48,0x78,0x8b,0x88
0008a0  08080808          DCB      0x08,0x08,0x08,0x08
0008a4  08080808          DCB      0x08,0x08,0x08,0x08
0008a8  0808bcbc          DCB      0x08,0x08,0xbc,0xbc
0008ac  10201020          DCB      0x10,0x20,0x10,0x20
0008b0  1020fdfe          DCB      0x10,0x20,0xfd,0xfe
0008b4  10201420          DCB      0x10,0x20,0x14,0x20
0008b8  19fc3108          DCB      0x19,0xfc,0x31,0x08
0008bc  d0881090          DCB      0xd0,0x88,0x10,0x90
0008c0  10601060          DCB      0x10,0x60,0x10,0x60
0008c4  1090110e          DCB      0x10,0x90,0x11,0x0e
0008c8  56042000          DCB      0x56,0x04,0x20,0x00
0008cc  d3d00100          DCB      0xd3,0xd0,0x01,0x00
0008d0  01007ffe          DCB      0x01,0x00,0x7f,0xfe
0008d4  02000400          DCB      0x02,0x00,0x04,0x00
0008d8  0ff01810          DCB      0x0f,0xf0,0x18,0x10
0008dc  28104ff0          DCB      0x28,0x10,0x4f,0xf0
0008e0  88100810          DCB      0x88,0x10,0x08,0x10
0008e4  0ff00810          DCB      0x0f,0xf0,0x08,0x10
0008e8  08900870          DCB      0x08,0x90,0x08,0x70
0008ec  0820cfde          DCB      0x08,0x20,0xcf,0xde
0008f0  0000fbf8          DCB      0x00,0x00,0xfb,0xf8
0008f4  920893f8          DCB      0x92,0x08,0x93,0xf8
0008f8  a208a208          DCB      0xa2,0x08,0xa2,0x08
0008fc  93f88a80          DCB      0x93,0xf8,0x8a,0x80
000900  8a48aa50          DCB      0x8a,0x48,0xaa,0x50
000904  92208220          DCB      0x92,0x20,0x82,0x20
000908  8210828e          DCB      0x82,0x10,0x82,0x8e
00090c  83048200          DCB      0x83,0x04,0x82,0x00
000910  b9ab0000          DCB      0xb9,0xab,0x00,0x00
000914  04400640          DCB      0x04,0x40,0x06,0x40
000918  04400820          DCB      0x04,0x40,0x08,0x20
00091c  08101018          DCB      0x08,0x10,0x10,0x18
000920  220e4304          DCB      0x22,0x0e,0x43,0x04
000924  02000420          DCB      0x02,0x00,0x04,0x20
000928  081011f8          DCB      0x08,0x10,0x11,0xf8
00092c  3f181010          DCB      0x3f,0x18,0x10,0x10
000930  0000cbbe          DCB      0x00,0x00,0xcb,0xbe
000934  00003ffc          DCB      0x00,0x00,0x3f,0xfc
000938  00040004          DCB      0x00,0x04,0x00,0x04
00093c  7fe40004          DCB      0x7f,0xe4,0x00,0x04
000940  00043fc4          DCB      0x00,0x04,0x3f,0xc4
000944  20442044          DCB      0x20,0x44,0x20,0x44
000948  3fc42044          DCB      0x3f,0xc4,0x20,0x44
00094c  20040014          DCB      0x20,0x04,0x00,0x14
000950  00080000          DCB      0x00,0x08,0x00,0x00
000954  d7a80100          DCB      0xd7,0xa8,0x01,0x00
000958  01003ff8          DCB      0x01,0x00,0x3f,0xf8
00095c  02000200          DCB      0x02,0x00,0x02,0x00
000960  fffe0400          DCB      0xff,0xfe,0x04,0x00
000964  08200ff0          DCB      0x08,0x20,0x0f,0xf0
000968  00200040          DCB      0x00,0x20,0x00,0x40
00096c  02800100          DCB      0x02,0x80,0x01,0x00
000970  00800040          DCB      0x00,0x80,0x00,0x40
000974  0000d2b5          DCB      0x00,0x00,0xd2,0xb5
000978  04400440          DCB      0x04,0x40,0x04,0x40
00097c  04400444          DCB      0x04,0x40,0x04,0x44
000980  4446244c          DCB      0x44,0x46,0x24,0x4c
000984  24481450          DCB      0x24,0x48,0x14,0x50
000988  1c501460          DCB      0x1c,0x50,0x14,0x60
00098c  04400440          DCB      0x04,0x40,0x04,0x40
000990  0444fffe          DCB      0x04,0x44,0xff,0xfe
000994  00000000          DCB      0x00,0x00,0x00,0x00
000998  bfaa0000          DCB      0xbf,0xaa,0x00,0x00
00099c  7ffe0420          DCB      0x7f,0xfe,0x04,0x20
0009a0  04200420          DCB      0x04,0x20,0x04,0x20
0009a4  0420fffe          DCB      0x04,0x20,0xff,0xfe
0009a8  04200420          DCB      0x04,0x20,0x04,0x20
0009ac  04200820          DCB      0x04,0x20,0x08,0x20
0009b0  08201020          DCB      0x08,0x20,0x10,0x20
0009b4  20204020          DCB      0x20,0x20,0x40,0x20
0009b8  0000b7a2          DCB      0x00,0x00,0xb7,0xa2
0009bc  02002240          DCB      0x02,0x00,0x22,0x40
0009c0  22302210          DCB      0x22,0x30,0x22,0x10
0009c4  7ffe2400          DCB      0x7f,0xfe,0x24,0x00
0009c8  040007e0          DCB      0x04,0x00,0x07,0xe0
0009cc  0c200a20          DCB      0x0c,0x20,0x0a,0x20
0009d0  0a201140          DCB      0x0a,0x20,0x11,0x40
0009d4  20804160          DCB      0x20,0x80,0x41,0x60
0009d8  861c1808          DCB      0x86,0x1c,0x18,0x08
0009dc  b0e5101c          DCB      0xb0,0xe5,0x10,0x1c
0009e0  11e01100          DCB      0x11,0xe0,0x11,0x00
0009e4  1100fd00          DCB      0x11,0x00,0xfd,0x00
0009e8  11fc3984          DCB      0x11,0xfc,0x39,0x84
0009ec  35485548          DCB      0x35,0x48,0x55,0x48
0009f0  52309210          DCB      0x52,0x30,0x92,0x10
0009f4  12301448          DCB      0x12,0x30,0x14,0x48
0009f8  108e1104          DCB      0x10,0x8e,0x11,0x04
0009fc  0000b9a4          DCB      0x00,0x00,0xb9,0xa4
000a00  00003ffc          DCB      0x00,0x00,0x3f,0xfc
000a04  01000100          DCB      0x01,0x00,0x01,0x00
000a08  01000100          DCB      0x01,0x00,0x01,0x00
000a0c  01000100          DCB      0x01,0x00,0x01,0x00
000a10  01000100          DCB      0x01,0x00,0x01,0x00
000a14  01000100          DCB      0x01,0x00,0x01,0x00
000a18  0100fffe          DCB      0x01,0x00,0xff,0xfe
000a1c  00000000          DCB      0x00,0x00,0x00,0x00
000a20  bfd81000          DCB      0xbf,0xd8,0x10,0x00
000a24  10201010          DCB      0x10,0x20,0x10,0x10
000a28  fdfe1104          DCB      0xfd,0xfe,0x11,0x04
000a2c  1050148c          DCB      0x10,0x50,0x14,0x8c
000a30  19043000          DCB      0x19,0x04,0x30,0x00
000a34  d1fc1020          DCB      0xd1,0xfc,0x10,0x20
000a38  10201020          DCB      0x10,0x20,0x10,0x20
000a3c  102053fe          DCB      0x10,0x20,0x53,0xfe
000a40  2000c9e8          DCB      0x20,0x00,0xc9,0xe8
000a44  400021f0          DCB      0x40,0x00,0x21,0xf0
000a48  31102110          DCB      0x31,0x10,0x21,0x10
000a4c  01100110          DCB      0x01,0x10,0x01,0x10
000a50  e20e25f8          DCB      0xe2,0x0e,0x25,0xf8
000a54  21082108          DCB      0x21,0x08,0x21,0x08
000a58  20902090          DCB      0x20,0x90,0x20,0x90
000a5c  28603090          DCB      0x28,0x60,0x30,0x90
000a60  230e0c04          DCB      0x23,0x0e,0x0c,0x04
000a64  b1b80800          DCB      0xb1,0xb8,0x08,0x00
000a68  0ff00820          DCB      0x0f,0xf0,0x08,0x20
000a6c  14202240          DCB      0x14,0x20,0x22,0x40
000a70  41800240          DCB      0x41,0x80,0x02,0x40
000a74  0c30301e          DCB      0x0c,0x30,0x30,0x1e
000a78  dff41110          DCB      0xdf,0xf4,0x11,0x10
000a7c  1ff01110          DCB      0x1f,0xf0,0x11,0x10
000a80  11101ff0          DCB      0x11,0x10,0x1f,0xf0
000a84  1010bcbc          DCB      0x10,0x10,0xbc,0xbc
000a88  10201020          DCB      0x10,0x20,0x10,0x20
000a8c  1020fdfe          DCB      0x10,0x20,0xfd,0xfe
000a90  10201420          DCB      0x10,0x20,0x14,0x20
000a94  19fc3108          DCB      0x19,0xfc,0x31,0x08
000a98  d0881090          DCB      0xd0,0x88,0x10,0x90
000a9c  10601060          DCB      0x10,0x60,0x10,0x60
000aa0  1090110e          DCB      0x10,0x90,0x11,0x0e
000aa4  56042000          DCB      0x56,0x04,0x20,0x00
000aa8  caf50100          DCB      0xca,0xf5,0x01,0x00
000aac  01200110          DCB      0x01,0x20,0x01,0x10
000ab0  0100fffe          DCB      0x01,0x00,0xff,0xfe
000ab4  01000380          DCB      0x01,0x00,0x03,0x80
000ab8  05400520          DCB      0x05,0x40,0x05,0x20
000abc  09101118          DCB      0x09,0x10,0x11,0x18
000ac0  210ec104          DCB      0x21,0x0e,0xc1,0x04
000ac4  01000100          DCB      0x01,0x00,0x01,0x00
000ac8  0000d6a7          DCB      0x00,0x00,0xd6,0xa7
000acc  01000100          DCB      0x01,0x00,0x01,0x00
000ad0  01007ffe          DCB      0x01,0x00,0x7f,0xfe
000ad4  01000100          DCB      0x01,0x00,0x01,0x00
000ad8  1ff80810          DCB      0x1f,0xf8,0x08,0x10
000adc  04200420          DCB      0x04,0x20,0x04,0x20
000ae0  02400180          DCB      0x02,0x40,0x01,0x80
000ae4  02400c30          DCB      0x02,0x40,0x0c,0x30
000ae8  700e0004          DCB      0x70,0x0e,0x00,0x04
000aec  b3d61040          DCB      0xb3,0xd6,0x10,0x40
000af0  104013fc          DCB      0x10,0x40,0x13,0xfc
000af4  fc401040          DCB      0xfc,0x40,0x10,0x40
000af8  17fe1410          DCB      0x17,0xfe,0x14,0x10
000afc  181037fe          DCB      0x18,0x10,0x37,0xfe
000b00  d0101110          DCB      0xd0,0x10,0x11,0x10
000b04  10d01090          DCB      0x10,0xd0,0x10,0x90
000b08  10105050          DCB      0x10,0x10,0x50,0x50
000b0c  2020c2db          DCB      0x20,0x20,0xc2,0xdb
000b10  40402040          DCB      0x40,0x40,0x20,0x40
000b14  30a02090          DCB      0x30,0xa0,0x20,0x90
000b18  01080206          DCB      0x01,0x08,0x02,0x06
000b1c  e5042110          DCB      0xe5,0x04,0x21,0x10
000b20  213821c0          DCB      0x21,0x38,0x21,0xc0
000b24  21002500          DCB      0x21,0x00,0x25,0x00
000b28  29043104          DCB      0x29,0x04,0x31,0x04
000b2c  20fc0000          DCB      0x20,0xfc,0x00,0x00
000b30  ccb30000          DCB      0xcc,0xb3,0x00,0x00
000b34  11fc1000          DCB      0x11,0xfc,0x10,0x00
000b38  10001000          DCB      0x10,0x00,0x10,0x00
000b3c  fc0013fe          DCB      0xfc,0x00,0x13,0xfe
000b40  10401060          DCB      0x10,0x40,0x10,0x60
000b44  10801c88          DCB      0x10,0x80,0x1c,0x88
000b48  3104c27e          DCB      0x31,0x04,0xc2,0x7e
000b4c  07c60204          DCB      0x07,0xc6,0x02,0x04
000b50  0000b3c7          DCB      0x00,0x00,0xb3,0xc7
000b54  20202028          DCB      0x20,0x20,0x20,0x28
000b58  202427fe          DCB      0x20,0x24,0x27,0xfe
000b5c  fc202424          DCB      0xfc,0x20,0x24,0x24
000b60  27a624a4          DCB      0x27,0xa6,0x24,0xa4
000b64  24a83ca8          DCB      0x24,0xa8,0x3c,0xa8
000b68  e4904792          DCB      0xe4,0x90,0x47,0x92
000b6c  092a084a          DCB      0x09,0x2a,0x08,0x4a
000b70  11840000          DCB      0x11,0x84,0x00,0x00
000b74  cdf50008          DCB      0xcd,0xf5,0x00,0x08
000b78  7ffc0100          DCB      0x7f,0xfc,0x01,0x00
000b7c  01000100          DCB      0x01,0x00,0x01,0x00
000b80  01000108          DCB      0x01,0x00,0x01,0x08
000b84  7ffc0100          DCB      0x7f,0xfc,0x01,0x00
000b88  01000100          DCB      0x01,0x00,0x01,0x00
000b8c  01000100          DCB      0x01,0x00,0x01,0x00
000b90  0104fffe          DCB      0x01,0x04,0xff,0xfe
000b94  0000c1d5          DCB      0x00,0x00,0xc1,0xd5
000b98  02101210          DCB      0x02,0x10,0x12,0x10
000b9c  fa102214          DCB      0xfa,0x10,0x22,0x14
000ba0  2ffe2210          DCB      0x2f,0xfe,0x22,0x10
000ba4  fa102738          DCB      0xfa,0x10,0x27,0x38
000ba8  26b82a54          DCB      0x26,0xb8,0x2a,0x54
000bac  3a54e292          DCB      0x3a,0x54,0xe2,0x92
000bb0  42100210          DCB      0x42,0x10,0x02,0x10
000bb4  02100210          DCB      0x02,0x10,0x02,0x10
000bb8  b1f30010          DCB      0xb1,0xf3,0x00,0x10
000bbc  201011f4          DCB      0x20,0x10,0x11,0xf4
000bc0  0012fc10          DCB      0x00,0x12,0xfc,0x10
000bc4  0bfe4810          DCB      0x0b,0xfe,0x48,0x10
000bc8  28502950          DCB      0x28,0x50,0x29,0x50
000bcc  11702950          DCB      0x11,0x70,0x29,0x50
000bd0  25484548          DCB      0x25,0x48,0x45,0x48
000bd4  816a0386          DCB      0x81,0x6a,0x03,0x86
000bd8  0002              DCB      0x00,0x02

                          AREA ||.data||, DATA, ALIGN=2

                  TransferError
000000  2a                DCB      0x2a
                  char_or_word
000001  00                DCB      0x00
                  horizontal_or_vertical
000002  0000              DCB      0x00,0x00
                  CardType
                          DCD      0x00000000
                  ||RCA||
                          DCD      0x00000000
                  DeviceMode
                          DCD      0x00000002
                  TotalNumberOfBytes
                          DCD      0x00000000
                  StopCondition
                          DCD      0x00000000
                  TransferEnd
                          DCD      0x00000000
                  NumberOfBytes
                          DCD      0x00000000
                  SrcBuffer
                          DCD      0x00000000
                  DestBuffer
                          DCD      0x00000000
